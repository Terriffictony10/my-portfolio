// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

contract Crowdsale {
    address public owner;
    ERC20 public token;
    uint256 public price;
    uint256 public maxTokens;
    uint256 public tokensSold;
    // The root of the Merkle tree containing approved buyers.
    bytes32 public merkleRoot;

    event Buy(uint256 amount, address buyer);
    event Finalize(uint256 tokensSold, uint256 ethRaised);
    event MerkleRootUpdated(bytes32 newMerkleRoot);

    modifier onlyOwner() {
        require(msg.sender == owner, "caller must be owner");
        _;
    }

    constructor(
        ERC20 _token,
        uint256 _price,
        uint256 _maxTokens,
        bytes32 _merkleRoot   // supply the merkle root at deployment
    ) {
        owner = msg.sender;
        token = _token;
        price = _price;
        maxTokens = _maxTokens;
        merkleRoot = _merkleRoot;
    }
    
    /**
     * @notice Purchase tokens by providing the correct ETH amount and a valid Merkle proof.
     * @param _amount The amount of tokens to buy (in token smallest units, e.g. wei for ERC20 with 18 decimals).
     * @param _merkleProof An array of hashes proving that msg.sender is in the whitelist.
     */
    function buyTokens(uint256 _amount, bytes32[] calldata _merkleProof) public payable {
        // Verify the sender is whitelisted.
        // Here we assume that the whitelist was generated by hashing each address with keccak256.
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
        require(
            MerkleProof.verify(_merkleProof, merkleRoot, leaf),
            "Invalid proof: sender is not whitelisted"
        );

        // Check that the ETH sent equals the price times number of tokens (adjusted for decimals)
        require(msg.value == (_amount / 1e18) * price, "Incorrect ETH value");

        // Ensure the contract holds enough tokens.
        require(token.balanceOf(address(this)) >= _amount, "Insufficient token balance");

        // Transfer tokens to the buyer.
        require(token.transfer(msg.sender, _amount), "Token transfer failed");

        tokensSold += _amount;
        emit Buy(_amount, msg.sender);
    }

    /// @notice Update the token price.
    function setPrice(uint256 _price) public onlyOwner {
        price = _price;
    }

    /// @notice Update the Merkle root if the whitelist changes.
    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {
        merkleRoot = _merkleRoot;
        emit MerkleRootUpdated(_merkleRoot);
    }
    
    /**
     * @notice Finalize the crowdsale by transferring remaining tokens and ETH to the owner.
     */
    function finalize() public onlyOwner {
        require(token.transfer(owner, token.balanceOf(address(this))), "Token transfer failed");
        uint256 value = address(this).balance;
        (bool sent, ) = owner.call{value: value}("");
        require(sent, "ETH transfer failed");
        emit Finalize(tokensSold, value);
    }
}
