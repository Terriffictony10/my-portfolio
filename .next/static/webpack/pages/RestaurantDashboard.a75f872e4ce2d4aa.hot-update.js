"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/RestaurantDashboard",{

/***/ "./src/store/interactions.js":
/*!***********************************!*\
  !*** ./src/store/interactions.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNewMenuItem: function() { return /* binding */ addNewMenuItem; },\n/* harmony export */   addTicketOrders: function() { return /* binding */ addTicketOrders; },\n/* harmony export */   bufferItemForTicket: function() { return /* binding */ bufferItemForTicket; },\n/* harmony export */   clearActiveTicket: function() { return /* binding */ clearActiveTicket; },\n/* harmony export */   clockInEmployee: function() { return /* binding */ clockInEmployee; },\n/* harmony export */   clockOutEmployee: function() { return /* binding */ clockOutEmployee; },\n/* harmony export */   createNewJob: function() { return /* binding */ createNewJob; },\n/* harmony export */   createNewRestaurant: function() { return /* binding */ createNewRestaurant; },\n/* harmony export */   createPOS: function() { return /* binding */ createPOS; },\n/* harmony export */   createTicketForPOS: function() { return /* binding */ createTicketForPOS; },\n/* harmony export */   decorateMyRestaurants: function() { return /* binding */ decorateMyRestaurants; },\n/* harmony export */   endService: function() { return /* binding */ endService; },\n/* harmony export */   fetchEmployeeStatusFromServer: function() { return /* binding */ fetchEmployeeStatusFromServer; },\n/* harmony export */   hireNewEmployee: function() { return /* binding */ hireNewEmployee; },\n/* harmony export */   loadAccount: function() { return /* binding */ loadAccount; },\n/* harmony export */   loadAllEmployees: function() { return /* binding */ loadAllEmployees; },\n/* harmony export */   loadAllJobs: function() { return /* binding */ loadAllJobs; },\n/* harmony export */   loadAllMenuItems: function() { return /* binding */ loadAllMenuItems; },\n/* harmony export */   loadAllPOS: function() { return /* binding */ loadAllPOS; },\n/* harmony export */   loadAllRestaurants: function() { return /* binding */ loadAllRestaurants; },\n/* harmony export */   loadAllServices: function() { return /* binding */ loadAllServices; },\n/* harmony export */   loadAllTicketsForPOS: function() { return /* binding */ loadAllTicketsForPOS; },\n/* harmony export */   loadDashboardRestaurantContractData: function() { return /* binding */ loadDashboardRestaurantContractData; },\n/* harmony export */   loadEmployeeRelevantPOS: function() { return /* binding */ loadEmployeeRelevantPOS; },\n/* harmony export */   loadFactory: function() { return /* binding */ loadFactory; },\n/* harmony export */   loadFullTicketDetails: function() { return /* binding */ loadFullTicketDetails; },\n/* harmony export */   loadMenuItemsForPOS: function() { return /* binding */ loadMenuItemsForPOS; },\n/* harmony export */   loadMyRestaurants: function() { return /* binding */ loadMyRestaurants; },\n/* harmony export */   loadNetwork: function() { return /* binding */ loadNetwork; },\n/* harmony export */   loadProvider: function() { return /* binding */ loadProvider; },\n/* harmony export */   ringBufferedItems: function() { return /* binding */ ringBufferedItems; },\n/* harmony export */   setActiveTicket: function() { return /* binding */ setActiveTicket; },\n/* harmony export */   startService: function() { return /* binding */ startService; },\n/* harmony export */   subscribeToEvents: function() { return /* binding */ subscribeToEvents; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abis/Restaurant.json */ \"./src/abis/Restaurant.json\");\n/* harmony import */ var _abis_decentratalityServiceFactory_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../abis/decentratalityServiceFactory.json */ \"./src/abis/decentratalityServiceFactory.json\");\n/* harmony import */ var _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abis/POS.json */ \"./src/abis/POS.json\");\n// src/store/interactions.js\n\n\n\n\n\nlet GlobalRestaurants = [];\nconst loadProvider = async (dispatch)=>{\n    const connection = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.BrowserProvider(window.ethereum);\n    dispatch({\n        type: \"PROVIDER_LOADED\",\n        connection\n    });\n    return connection;\n};\nconst loadAccount = async (provider1, dispatch)=>{\n    const accounts = await provider1.send(\"eth_requestAccounts\", []);\n    const account = ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.getAddress(accounts[0]);\n    dispatch({\n        type: \"ACCOUNT_LOADED\",\n        account\n    });\n    return account;\n};\nconst loadNetwork = async (provider1, dispatch)=>{\n    let { chainId } = await provider1.getNetwork();\n    chainId = Number(chainId);\n    dispatch({\n        type: \"NETWORK_LOADED\",\n        chainId\n    });\n    return chainId;\n};\nconst subscribeToEvents = async function(restaurantFactory, dispatch) {\n    for(var _len = arguments.length, Restaurants = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        Restaurants[_key - 2] = arguments[_key];\n    }\n    restaurantFactory.on(\"RestaurantCreated\", (restaurant1, id, owner, event)=>{\n        const _restaurant = event.args;\n        dispatch({\n            type: \"NEW_RESTAURANT_CREATION_SUCCESS\",\n            _restaurant,\n            event\n        });\n    });\n    for(restaurant in Restaurants){\n        restaurant.on(\"JobAdded\", (id, timestamp, job, event)=>{});\n    }\n};\nconst loadFactory = async (user, address, dispatch)=>{\n    const decentratalityServiceFactory = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(address, _abis_decentratalityServiceFactory_json__WEBPACK_IMPORTED_MODULE_1__.abi, user);\n    dispatch({\n        type: \"DECENTRATALITY_SERVICE_FACTORY_LOADED\",\n        decentratalityServiceFactory\n    });\n    return decentratalityServiceFactory;\n};\nconst loadAllRestaurants = async (user, factory, dispatch)=>{\n    try {\n        const Restaurants = [];\n        // Call the `getAllRestaurants` function from the factory contract\n        const restaurantAddresses = await factory.getAllRestaurants();\n        // Iterate through the returned restaurant addresses\n        for(let i = 0; i < restaurantAddresses.length; i++){\n            const restaurantAddress = restaurantAddresses[i];\n            // Create a new contract instance for the restaurant\n            const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurantAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n            // Fetch restaurant details\n            const name = await restaurantContract.name();\n            const owner = await restaurantContract.owner();\n            const balance = await provider.getBalance(restaurantAddress);\n            // Format the restaurant data\n            Restaurants.push({\n                id: i + 1,\n                address: restaurantAddress,\n                name,\n                owner,\n                balance: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(balance))\n            });\n        }\n        // Update global state or Redux store\n        dispatch({\n            type: \"ALL_RESTAURANTS_LOADED\",\n            Restaurants\n        });\n        return Restaurants;\n    } catch (error) {\n        console.error(\"Error loading all restaurants:\", error);\n        return [];\n    }\n};\nconst loadMyRestaurants = async (provider1, user, Restaurants, dispatch)=>{\n    const myRestaurants = Restaurants.filter((restaurant1)=>restaurant1.owner === user); // Assuming `owner` is the correct key\n    if (myRestaurants.length === 0) return;\n    dispatch({\n        type: \"MY_RESTAURANTS_LOADED\",\n        myRestaurants\n    });\n    return myRestaurants;\n};\nconst decorateMyRestaurants = async (user, myRestaurants)=>{\n    const decoratedRestaurants = [];\n    if (myRestaurants) {\n        for (const restaurant1 of myRestaurants){\n            try {\n                const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurant1.address, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n                const name = await contract.name; // Use the new getName() function\n                const myName = name.toString();\n                const cash = Number(await provider.getBalance(restaurant1.address));\n                decoratedRestaurants.push({\n                    ...restaurant1,\n                    myName,\n                    cash\n                });\n            } catch (error) {\n                console.error(\"Error decorating restaurant \".concat(restaurant1.address, \":\"), error);\n            }\n        }\n    }\n    return decoratedRestaurants;\n};\nconst createNewRestaurant = async (user, factory, restaurantName, totalCostWei, dispatch)=>{\n    try {\n        // Ensure totalCostWei is converted to an integer BigInt by truncating decimals\n        const totalCost = BigInt(Math.floor(Number(totalCostWei)));\n        // Check if the user has enough balance\n        const balance = await provider.getBalance(user.getAddress());\n        if (BigInt(balance) < totalCost) {\n            alert(\"Insufficient funds to create restaurant\");\n            return;\n        }\n        // Call the contract function with the converted total cost\n        const tx = await factory.createRestaurant(restaurantName, totalCost, {\n            value: totalCost\n        });\n        // Wait for the transaction to be mined\n        await tx.wait();\n        // Dispatch success action\n        dispatch({\n            type: \"RESTAURANT_CREATION_SUCCESS\",\n            restaurant: tx\n        });\n    } catch (error) {\n        console.error(\"Error creating restaurant:\", error);\n        dispatch({\n            type: \"RESTAURANT_CREATION_FAIL\",\n            error\n        });\n    }\n};\nconst loadDashboardRestaurantContractData = async (user, Restaurant, dispatch)=>{\n    const contractAddress = Restaurant.address;\n    const abi = _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__;\n    const contract = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n    const name = await contract.name();\n    const myCash = await provider.getBalance(contractAddress);\n    const cash = Number(myCash).toString();\n    dispatch({\n        type: \"DASHBOARD_RESTAURANT_LOADED\",\n        contractAddress,\n        abi,\n        name,\n        cash\n    });\n    return contract;\n};\n// interactions.js\nconst createNewJob = async (provider1, contractAddress, abi, name, wage, dispatch)=>{\n    const user = await provider1.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n    // Call the contract function to add a new job\n    const tx = await contract.addJob(wage, name);\n    // Wait for the transaction to be mined\n    await tx.wait();\n    // Reload all jobs\n    await loadAllJobs(provider1, contractAddress, abi, dispatch);\n};\nconst hireNewEmployee = async (user, contractAddress, abi, jobId, name, employeeAddress, dispatch)=>{\n    try {\n        const user = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Call the contract function to hire a new employee\n        const tx = await contract.hireEmployee(jobId, name, employeeAddress);\n        // Wait for the transaction to be mined\n        await tx.wait();\n        // Reload all employees\n        await loadAllEmployees(provider, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error in hireNewEmployee:\", error);\n    }\n};\nconst loadAllEmployees = async (user, contractAddress, abi, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of employee IDs\n        const employeeIds = await contract.getEmployeeIds();\n        const employeesArray = [];\n        for(let i = 0; i < employeeIds.length; i++){\n            const employeeId = Number(employeeIds[i]); // Convert BigNumber to Number\n            const employee = await contract.employees(employeeId);\n            employeesArray.push({\n                id: employeeId.toString(),\n                jobId: employee.jobId.toString(),\n                name: employee.name,\n                address: employee.employeeAddress,\n                clockStamp: employee.clockStamp.toString(),\n                employeePension: employee.employeePension.toString()\n            });\n        }\n        // Dispatch action to update employees in Redux store\n        dispatch({\n            type: \"EMPLOYEES_LOADED\",\n            employees: employeesArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllEmployees:\", error);\n    }\n};\nconst loadAllJobs = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of job IDs\n        const jobIds = await contract.getJobIds();\n        const jobsArray = [];\n        for(let i = 0; i < jobIds.length; i++){\n            const jobId = Number(jobIds[i]); // Convert BigNumber to Number\n            const job = await contract.jobs(jobId);\n            jobsArray.push({\n                id: jobId.toString(),\n                hourlyWageInWei: job.hourlyWageInWei.toString(),\n                jobName: job.jobName\n            });\n        }\n        // Dispatch action to update jobs in Redux store\n        dispatch({\n            type: \"JOBS_LOADED\",\n            jobs: jobsArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllJobs:\", error.message);\n    }\n};\nconst startService = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        const tx = await contract.startService();\n        const receipt = await tx.wait();\n        // Get the block timestamp from the transaction receipt\n        const block = await provider1.getBlock(receipt.blockNumber);\n        const serviceStartTime = block.timestamp;\n        // Dispatch the service start time\n        dispatch({\n            type: \"SERVICE_STARTED\",\n            serviceStartTime\n        });\n    } catch (error) {\n        console.error(\"Error in startService:\", error);\n    }\n};\nconst loadAllServices = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of service IDs\n        const serviceIds = await contract.getServiceIds();\n        const servicesArray = [];\n        for(let i = 0; i < serviceIds.length; i++){\n            const serviceId = Number(serviceIds[i]);\n            const service = await contract.services(serviceId);\n            servicesArray.push({\n                id: serviceId.toString(),\n                startTime: service.startTime.toString(),\n                endTime: service.endTime.toString(),\n                cost: service.cost.toString(),\n                profit: service.profit.toString(),\n                revenue: service.revenue.toString()\n            });\n        }\n        // Dispatch action to update services in Redux store\n        dispatch({\n            type: \"SERVICES_LOADED\",\n            services: servicesArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllServices:\", error);\n    }\n};\nconst endService = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        const tx = await contract.endService();\n        await tx.wait();\n        // Optionally dispatch an action to update the service status in Redux\n        dispatch({\n            type: \"SERVICE_STOPPED\"\n        });\n    } catch (error) {\n        console.error(\"Error in endService:\", error);\n    }\n};\nconst createPOS = async (provider1, contractAddress, abi, name, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n        // Call the createPOS function on the contract\n        const tx = await contract.createPOS(name);\n        const receipt = await tx.wait();\n        // Extract the POSCreated event from the receipt\n        const event = receipt.logs.map((log)=>{\n            try {\n                return contract.interface.parseLog(log);\n            } catch (e) {\n                return null;\n            }\n        }).find((parsedLog)=>parsedLog && parsedLog.name === \"POSCreated\");\n        if (event) {\n            const posId = event.args.id.toString();\n            const posAddress = event.args.pos;\n        // Dispatch action to update Redux store\n        }\n        // Reload POS list\n        await loadAllPOS(provider1, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error in createPOS:\", error);\n    }\n};\nconst loadAllPOS = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        // Fetch the array of POS IDs\n        const posIds = await contract.getPOSIds();\n        const posArray = [];\n        for(let i = 0; i < posIds.length; i++){\n            const posId = Number(posIds[i]);\n            const posAddress = await contract.POSMapping(posId);\n            const posContract = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            const posName = await posContract.getName();\n            posArray.push({\n                id: posId.toString(),\n                address: posAddress,\n                name: posName.toString()\n            });\n        }\n        // Dispatch action to update POS in Redux store\n        dispatch({\n            type: \"POS_LOADED\",\n            posArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllPOS:\", error);\n    }\n};\nconst loadAllMenuItems = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n        // Get all POS addresses associated with the restaurant\n        const posAddresses = await restaurantContract.getAllPOSAddresses();\n        console.log(\"hello\");\n        if (posAddresses.length === 0) {\n            dispatch({\n                type: \"LOAD_ALL_MENU_ITEMS_SUCCESS\",\n                payload: []\n            });\n            return;\n        }\n        const firstPOSAddress = posAddresses[0];\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(firstPOSAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, provider1);\n        const menuItemIds = await posContract.getMenuItemIds();\n        let menuItems = [];\n        for(let i = 0; i < menuItemIds.length; i++){\n            const id = Number(menuItemIds[i]);\n            const menuItem = await posContract.menu(id);\n            menuItems.push({\n                id: id,\n                cost: ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(menuItem.cost),\n                name: menuItem.name\n            });\n        }\n        dispatch({\n            type: \"LOAD_ALL_MENU_ITEMS_SUCCESS\",\n            payload: menuItems\n        });\n    } catch (error) {\n        console.error(\"Error loading menu items:\", error);\n    }\n};\nconst addNewMenuItem = async (provider1, contractAddress, abi, cost, name, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        // Get all POS addresses from the restaurant contract\n        const posAddresses = await restaurantContract.getAllPOSAddresses();\n        // Loop through each POS address and add the menu item\n        for(let i = 0; i < posAddresses.length; i++){\n            const posAddress = posAddresses[i];\n            // Create a new contract instance for each POS\n            const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            // Call the addMenuItem function on each POS contract\n            const costInWei = ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.parseUnits(cost.toString(), \"ether\");\n            const tx = await posContract.addMenuItem(costInWei, name);\n            await tx.wait();\n        }\n        dispatch({\n            type: \"MENU_ITEM_ADDED\",\n            payload: {\n                cost,\n                name\n            }\n        });\n        await loadAllMenuItems(provider1, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error adding new menu item:\", error);\n    }\n};\n// In interactions.js (near loadAllPOS or after it):\nconst loadEmployeeRelevantPOS = async (provider1, restaurantAddress, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurantAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        const posIds = await restaurantContract.getPOSIds();\n        const posArray = [];\n        for(let i = 0; i < posIds.length; i++){\n            const posId = Number(posIds[i]);\n            const posAddress = await restaurantContract.POSMapping(posId);\n            const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            const posName = await posContract.getName();\n            posArray.push({\n                id: posId.toString(),\n                address: posAddress,\n                name: posName.toString()\n            });\n            console.log(\"1\");\n        }\n        console.log(posArray);\n        // Dispatch an action that specifically stores POS addresses relevant to the current employee's restaurant\n        dispatch({\n            type: \"RELEVANT_POS_LOADED_FOR_EMPLOYEE\",\n            payload: posArray\n        });\n        return posArray;\n    } catch (error) {\n        console.error(\"Error in loadEmployeeRelevantPOS:\", error);\n    }\n};\nconst createTicketForPOS = async (provider1, posAddress, posAbi, ticketName, serverAddress, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, posAbi, signer);\n        // The POS contract extends MenuTicketBase, which has createTicket(_server, _name)\n        const tx = await posContract.createTicket(serverAddress, ticketName);\n        await tx.wait();\n        // After creation, reload tickets so the UI remains up-to-date\n        await loadAllTicketsForPOS(provider1, posAddress, posAbi, dispatch);\n        dispatch({\n            type: \"CREATE_TICKET_SUCCESS\"\n        });\n    } catch (error) {\n        console.error(\"Error creating ticket:\", error);\n        dispatch({\n            type: \"CREATE_TICKET_FAIL\",\n            error\n        });\n    }\n};\n/**\r\n * Loads all tickets from a given POS contract.\r\n * @param provider Ethers provider/signer\r\n * @param posAddress The POS contract address\r\n * @param posAbi The ABI for the POS contract\r\n * @param dispatch Redux dispatch function\r\n */ const loadAllTicketsForPOS = async (provider1, posAddress, posAbi, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        // The POS contract (via MenuTicketBase) has an array TicketIds, so we read that\n        const ticketIds = await posContract.getTicketIds();\n        const ticketsArray = [];\n        for(let i = 0; i < ticketIds.length; i++){\n            const ticketIdBN = ticketIds[i]; // BigInt\n            const ticketId = Number(ticketIdBN);\n            const ticketStruct = await posContract.getTicket(ticketId);\n            // ticketStruct has { name, orders[], server, id, paid }\n            ticketsArray.push({\n                id: ticketStruct.id.toString(),\n                name: ticketStruct.name,\n                server: ticketStruct.server,\n                paid: ticketStruct.paid,\n                posAddress: posAddress // So we know which POS this ticket belongs to\n            });\n        }\n        // Dispatch to store in Redux. \n        // We can store them POS-by-POS or in a single array. \n        // Below, we just push them all into a single array in Redux:\n        dispatch({\n            type: \"TICKETS_LOADED\",\n            payload: {\n                posAddress,\n                tickets: ticketsArray\n            }\n        });\n    } catch (error) {\n        console.error(\"Error loading tickets for POS:\", error);\n        dispatch({\n            type: \"TICKETS_LOAD_FAIL\",\n            error\n        });\n    }\n};\nconst setActiveTicket = async (dispatch, ticket)=>{\n    dispatch({\n        type: \"ACTIVE_TICKET_SET\",\n        payload: ticket\n    });\n};\n/**\r\n * Clears the currently active ticket in Redux.\r\n * @param {Object} dispatch Redux dispatch\r\n */ const clearActiveTicket = async (dispatch)=>{\n    dispatch({\n        type: \"ACTIVE_TICKET_CLEAR\"\n    });\n};\n/**\r\n * Loads all menu items for a given POS contract address and returns them as an array.\r\n * Optionally, you could dispatch a Redux action to store them if desired.\r\n *\r\n * @param {*} provider Ethers provider/signer\r\n * @param {String} posAddress The address of the POS\r\n * @param {Array} posAbi The ABI for the POS contract\r\n * @param {Object} dispatch Redux dispatch\r\n * @returns {Array} An array of menu items [{ id, name, cost }, ...]\r\n */ const loadMenuItemsForPOS = async (provider1, posAddress, posAbi, dispatch)=>{\n    try {\n        // Optional: dispatch({ type: 'MENU_ITEMS_LOAD_REQUEST' });\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        const menuItemIds = await posContract.getMenuItemIds();\n        let menuItems = [];\n        for(let i = 0; i < menuItemIds.length; i++){\n            const id = Number(menuItemIds[i]);\n            const item = await posContract.menu(id);\n            // Convert cost from wei to Ether (or you can store raw wei).\n            menuItems.push({\n                id,\n                name: item.name,\n                cost: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(item.cost))\n            });\n        }\n        // Optional: dispatch({ type: 'MENU_ITEMS_FOR_POS_LOADED', payload: menuItems });\n        return menuItems;\n    } catch (error) {\n        console.error(\"Error loading menu for POS:\", error);\n        // Optional: dispatch({ type: 'MENU_ITEMS_LOAD_FAIL', error });\n        return [];\n    }\n};\nconst addTicketOrders = async (provider1, posAddress, posAbi, ticketId, items, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        const tx = await posContract.addTicketOrders(ticketId, items);\n        await tx.wait();\n        // Optionally reload the updated ticket...\n        // await loadAllTicketsForPOS(provider, posAddress, posAbi, dispatch);\n        dispatch({\n            type: \"ADD_TICKET_ORDERS_SUCCESS\"\n        });\n    } catch (error) {\n        console.error(\"Error adding orders:\", error);\n        dispatch({\n            type: \"ADD_TICKET_ORDERS_FAIL\",\n            error\n        });\n    }\n};\nconst loadFullTicketDetails = async (provider1, posAddress, posAbi, ticketId, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        // Grab the entire ticket struct from the contract\n        const ticketStruct = await posContract.getTicket(ticketId);\n        // ticketStruct -> { name, orders[], server, id, paid }\n        // Convert orders[] from contract (cost in wei) to a friendlier JS array\n        const orders = [];\n        for(let i = 0; i < ticketStruct.orders.length; i++){\n            const orderItem = ticketStruct.orders[i];\n            orders.push({\n                name: orderItem.name,\n                cost: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(orderItem.cost))\n            });\n        }\n        const fullTicket = {\n            id: Number(ticketStruct.id).toString(),\n            name: ticketStruct.name,\n            server: ticketStruct.server,\n            paid: ticketStruct.paid,\n            posAddress,\n            orders\n        };\n        // Dispatch so Redux knows about the fully detailed ticket\n        dispatch({\n            type: \"ACTIVE_TICKET_DETAILS_LOADED\",\n            payload: fullTicket\n        });\n    } catch (error) {\n        console.error(\"Error loading full ticket details:\", error);\n        dispatch({\n            type: \"ACTIVE_TICKET_DETAILS_FAIL\",\n            error\n        });\n    }\n};\nconst bufferItemForTicket = (ticketId, item)=>{\n    return (dispatch)=>{\n        dispatch({\n            type: \"ADD_ITEM_TO_PENDING_BUFFER\",\n            payload: {\n                ticketId,\n                item\n            }\n        });\n    };\n};\n// 2) A function that *rings* all buffered items for a given ticketId\n//    by calling `addTicketOrders` in the POS contract.\nconst ringBufferedItems = async (provider1, posAddress, pendingOrderBuffer, posAbi, ticketId, dispatch, getState)=>{\n    try {\n        const stringId = ticketId.toString();\n        // Get the entire pending buffer\n        const itemsToRing = pendingOrderBuffer[stringId] || [];\n        if (itemsToRing.length === 0) {\n            console.log(\"No items to ring for this ticket.\");\n            return;\n        }\n        // Format them for the contract\n        const rungItems = itemsToRing.map((item)=>({\n                cost: ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.parseUnits(item.cost.toString(), \"ether\"),\n                name: item.name\n            }));\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, posAbi, signer);\n        // Send transaction\n        console.log(\"fun\");\n        const tx = await posContract.addTicketOrders(ticketId, rungItems);\n        await tx.wait();\n        console.log(\"fun\");\n        // Now tell Redux we succeeded\n        dispatch({\n            type: \"ORDER_RING_SUCCESS\",\n            payload: {\n                ticketId: ticketId,\n                rungItems: itemsToRing\n            }\n        });\n        console.log(\"Successfully rang items for ticket: \".concat(stringId));\n    } catch (error) {\n        console.error(\"Error in ringBufferedItems:\", error);\n    }\n};\nconst clockInEmployee = async (provider1, contractAddress, abi, employeeId)=>{\n    const signer = await provider1.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n    const tx = await contract.clockIn(employeeId);\n    await tx.wait();\n};\nconst clockOutEmployee = async (provider1, contractAddress, abi, employeeId)=>{\n    const signer = await provider1.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n    const tx = await contract.clockOut(employeeId);\n    await tx.wait();\n};\n// In store/interactions.js\n// store/interactions.js\nconst fetchEmployeeStatusFromServer = (param)=>{\n    let { signer, contractAddress, abi, jobName } = param;\n    return async (dispatch, getState)=>{\n        try {\n            // 1) The public address of the user\n            const userAddress = await signer.getAddress();\n            // 2) Build the payload\n            const payload = {\n                contractAddress,\n                userAddress,\n                abi,\n                jobName\n            };\n            // 3) POST to your custom route\n            const response = await fetch(\"/api/employeeStatus\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(payload)\n            });\n            if (!response.ok) {\n                throw new Error(\"Server error: \".concat(response.statusText));\n            }\n            const data = await response.json();\n            // 4) Dispatch if you want to store in Redux\n            dispatch({\n                type: \"EMPLOYEE_STATUS_FROM_SERVER\",\n                payload: data\n            });\n        } catch (error) {\n            console.error(\"Error in fetchEmployeeStatusFromServer:\", error);\n            dispatch({\n                type: \"EMPLOYEE_STATUS_FROM_SERVER_ERROR\",\n                error\n            });\n        }\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlDLE1BQU0saUJBQXFDLE9BQXBCUixTQUFTUyxVQUFVO1lBQ3REO1lBRUEsTUFBTUMsT0FBTyxNQUFNVixTQUFTVyxJQUFJO1lBRWhDLDRDQUE0QztZQUM1QzVNLFNBQVM7Z0JBQUVLLE1BQU07Z0JBQStCd0ksU0FBUzhEO1lBQUs7UUFDaEUsRUFBRSxPQUFPNUosT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsMkNBQTJDQTtZQUN6RC9DLFNBQVM7Z0JBQUVLLE1BQU07Z0JBQXFDMEM7WUFBTTtRQUM5RDtJQUNGO0VBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0b3JlL2ludGVyYWN0aW9ucy5qcz8wMGE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9zdG9yZS9pbnRlcmFjdGlvbnMuanNcclxuXHJcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycydcclxuaW1wb3J0IFJFU1RBVVJBTlRfQUJJIGZyb20gXCIuLi9hYmlzL1Jlc3RhdXJhbnQuanNvblwiXHJcbmltcG9ydCBERUNFTlRSQVRBTElUWVNFUlZJQ0VGQUNUT1JZX0FCSSBmcm9tIFwiLi4vYWJpcy9kZWNlbnRyYXRhbGl0eVNlcnZpY2VGYWN0b3J5Lmpzb25cIlxyXG5pbXBvcnQgUE9TX0FCSSBmcm9tIFwiLi4vYWJpcy9QT1MuanNvblwiO1xyXG5pbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gJ3JlYWN0LXJlZHV4J1xyXG5cclxubGV0IEdsb2JhbFJlc3RhdXJhbnRzID0gW11cclxuZXhwb3J0IGNvbnN0IGxvYWRQcm92aWRlciA9IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG5cdGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xyXG4gICAgXHJcbiAgICBcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1BST1ZJREVSX0xPQURFRCcsIGNvbm5lY3Rpb24gfSlcclxuXHJcbiAgICByZXR1cm4gY29ubmVjdGlvblxyXG59XHJcbmV4cG9ydCBjb25zdCBsb2FkQWNjb3VudCA9IGFzeW5jIChwcm92aWRlciwgZGlzcGF0Y2gpID0+IHtcclxuXHRjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfcmVxdWVzdEFjY291bnRzXCIsIFtdKTtcclxuXHRjb25zdCBhY2NvdW50ID0gZXRoZXJzLmdldEFkZHJlc3MoYWNjb3VudHNbMF0pOyBcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdBQ0NPVU5UX0xPQURFRCcsIGFjY291bnR9KVxyXG5cclxuICAgIHJldHVybiBhY2NvdW50XHJcbn1cclxuZXhwb3J0IGNvbnN0IGxvYWROZXR3b3JrID0gYXN5bmMgKHByb3ZpZGVyLCBkaXNwYXRjaCkgPT4ge1xyXG4gICAgbGV0IHsgY2hhaW5JZCB9ID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpXHJcbiAgICBjaGFpbklkID0gTnVtYmVyKGNoYWluSWQpXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdORVRXT1JLX0xPQURFRCcsIGNoYWluSWQgfSlcclxuXHJcbiAgICByZXR1cm4gY2hhaW5JZFxyXG59XHJcbmV4cG9ydCBjb25zdCBzdWJzY3JpYmVUb0V2ZW50cyA9IGFzeW5jIChyZXN0YXVyYW50RmFjdG9yeSwgZGlzcGF0Y2gsIC4uLlJlc3RhdXJhbnRzKSA9PiB7XHJcbiAgICAgICAgcmVzdGF1cmFudEZhY3Rvcnkub24oJ1Jlc3RhdXJhbnRDcmVhdGVkJywgKHJlc3RhdXJhbnQsIGlkLCBvd25lciwgZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBfcmVzdGF1cmFudCA9IGV2ZW50LmFyZ3NcclxuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdORVdfUkVTVEFVUkFOVF9DUkVBVElPTl9TVUNDRVNTJywgX3Jlc3RhdXJhbnQsIGV2ZW50IH0pXHJcbiAgICB9KVxyXG4gICAgICAgIGZvcihyZXN0YXVyYW50IGluIFJlc3RhdXJhbnRzKSB7XHJcbiAgICAgICAgICAgIHJlc3RhdXJhbnQub24oJ0pvYkFkZGVkJywgKGlkLCB0aW1lc3RhbXAsIGpvYiwgZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIFxyXG59XHJcbmV4cG9ydCBjb25zdCBsb2FkRmFjdG9yeSA9IGFzeW5jICh1c2VyLCBhZGRyZXNzLCBkaXNwYXRjaCkgPT4ge1xyXG4gICAgXHJcbiAgICBjb25zdCBkZWNlbnRyYXRhbGl0eVNlcnZpY2VGYWN0b3J5ID0gbmV3IGV0aGVycy5Db250cmFjdChhZGRyZXNzLCBERUNFTlRSQVRBTElUWVNFUlZJQ0VGQUNUT1JZX0FCSS5hYmksIHVzZXIpO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnREVDRU5UUkFUQUxJVFlfU0VSVklDRV9GQUNUT1JZX0xPQURFRCcsIGRlY2VudHJhdGFsaXR5U2VydmljZUZhY3RvcnkgfSlcclxuICAgIHJldHVybiBkZWNlbnRyYXRhbGl0eVNlcnZpY2VGYWN0b3J5XHJcbn1cclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxSZXN0YXVyYW50cyA9IGFzeW5jICh1c2VyLCBmYWN0b3J5LCBkaXNwYXRjaCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBSZXN0YXVyYW50cyA9IFtdO1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLyBDYWxsIHRoZSBgZ2V0QWxsUmVzdGF1cmFudHNgIGZ1bmN0aW9uIGZyb20gdGhlIGZhY3RvcnkgY29udHJhY3RcclxuICAgICAgICBjb25zdCByZXN0YXVyYW50QWRkcmVzc2VzID0gYXdhaXQgZmFjdG9yeS5nZXRBbGxSZXN0YXVyYW50cygpO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJldHVybmVkIHJlc3RhdXJhbnQgYWRkcmVzc2VzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN0YXVyYW50QWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3RhdXJhbnRBZGRyZXNzID0gcmVzdGF1cmFudEFkZHJlc3Nlc1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnN0YW5jZSBmb3IgdGhlIHJlc3RhdXJhbnRcclxuICAgICAgICAgICAgY29uc3QgcmVzdGF1cmFudENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChcclxuICAgICAgICAgICAgICAgIHJlc3RhdXJhbnRBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgUkVTVEFVUkFOVF9BQkksXHJcbiAgICAgICAgICAgICAgICB1c2VyXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBGZXRjaCByZXN0YXVyYW50IGRldGFpbHNcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGF3YWl0IHJlc3RhdXJhbnRDb250cmFjdC5uYW1lKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0Lm93bmVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKHJlc3RhdXJhbnRBZGRyZXNzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZvcm1hdCB0aGUgcmVzdGF1cmFudCBkYXRhXHJcbiAgICAgICAgICAgIFJlc3RhdXJhbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGkgKyAxLFxyXG4gICAgICAgICAgICAgICAgYWRkcmVzczogcmVzdGF1cmFudEFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgb3duZXIsXHJcbiAgICAgICAgICAgICAgICBiYWxhbmNlOiBOdW1iZXIoZXRoZXJzLmZvcm1hdEV0aGVyKGJhbGFuY2UpKSwgLy8gQ29udmVydCBiYWxhbmNlIHRvIEV0aGVyIGZvciBlYXNpZXIgcmVhZGFiaWxpdHlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgZ2xvYmFsIHN0YXRlIG9yIFJlZHV4IHN0b3JlXHJcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIkFMTF9SRVNUQVVSQU5UU19MT0FERURcIiwgUmVzdGF1cmFudHMgfSk7XHJcbiAgICAgICAgcmV0dXJuIFJlc3RhdXJhbnRzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBhbGwgcmVzdGF1cmFudHM6XCIsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkTXlSZXN0YXVyYW50cyA9IGFzeW5jIChwcm92aWRlciwgdXNlciwgUmVzdGF1cmFudHMsIGRpc3BhdGNoKSA9PiB7XHJcbiAgICBjb25zdCBteVJlc3RhdXJhbnRzID0gUmVzdGF1cmFudHMuZmlsdGVyKChyZXN0YXVyYW50KSA9PiByZXN0YXVyYW50Lm93bmVyID09PSB1c2VyKTsgLy8gQXNzdW1pbmcgYG93bmVyYCBpcyB0aGUgY29ycmVjdCBrZXlcclxuICAgIGlmIChteVJlc3RhdXJhbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ01ZX1JFU1RBVVJBTlRTX0xPQURFRCcsIG15UmVzdGF1cmFudHMgfSk7XHJcbiAgICByZXR1cm4gbXlSZXN0YXVyYW50cztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkZWNvcmF0ZU15UmVzdGF1cmFudHMgPSBhc3luYyAodXNlciwgbXlSZXN0YXVyYW50cykgPT4ge1xyXG4gICAgXHJcbiAgICBjb25zdCBkZWNvcmF0ZWRSZXN0YXVyYW50cyA9IFtdO1xyXG5cclxuICAgIGlmIChteVJlc3RhdXJhbnRzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCByZXN0YXVyYW50IG9mIG15UmVzdGF1cmFudHMpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChyZXN0YXVyYW50LmFkZHJlc3MsIFJFU1RBVVJBTlRfQUJJLCB1c2VyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCBjb250cmFjdC5uYW1lOyAvLyBVc2UgdGhlIG5ldyBnZXROYW1lKCkgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IG15TmFtZSA9IG5hbWUudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FzaCA9IE51bWJlcihhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKHJlc3RhdXJhbnQuYWRkcmVzcykpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlY29yYXRlZFJlc3RhdXJhbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnJlc3RhdXJhbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbXlOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2gsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlY29yYXRpbmcgcmVzdGF1cmFudCAke3Jlc3RhdXJhbnQuYWRkcmVzc306YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZWNvcmF0ZWRSZXN0YXVyYW50cztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVOZXdSZXN0YXVyYW50ID0gYXN5bmMgKHVzZXIsIGZhY3RvcnksIHJlc3RhdXJhbnROYW1lLCB0b3RhbENvc3RXZWksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIFxyXG5cclxuICAgIC8vIEVuc3VyZSB0b3RhbENvc3RXZWkgaXMgY29udmVydGVkIHRvIGFuIGludGVnZXIgQmlnSW50IGJ5IHRydW5jYXRpbmcgZGVjaW1hbHNcclxuICAgIGNvbnN0IHRvdGFsQ29zdCA9IEJpZ0ludChNYXRoLmZsb29yKE51bWJlcih0b3RhbENvc3RXZWkpKSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHVzZXIgaGFzIGVub3VnaCBiYWxhbmNlXHJcbiAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmFsYW5jZSh1c2VyLmdldEFkZHJlc3MoKSk7XHJcbiAgICBpZiAoQmlnSW50KGJhbGFuY2UpIDwgdG90YWxDb3N0KSB7XHJcbiAgICAgIGFsZXJ0KFwiSW5zdWZmaWNpZW50IGZ1bmRzIHRvIGNyZWF0ZSByZXN0YXVyYW50XCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsbCB0aGUgY29udHJhY3QgZnVuY3Rpb24gd2l0aCB0aGUgY29udmVydGVkIHRvdGFsIGNvc3RcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgZmFjdG9yeS5jcmVhdGVSZXN0YXVyYW50KHJlc3RhdXJhbnROYW1lLCB0b3RhbENvc3QsIHtcclxuICAgICAgdmFsdWU6IHRvdGFsQ29zdCwgLy8gQXR0YWNoIHRoZSBmdW5kcyBpbiBXZWlcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBtaW5lZFxyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIERpc3BhdGNoIHN1Y2Nlc3MgYWN0aW9uXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6IFwiUkVTVEFVUkFOVF9DUkVBVElPTl9TVUNDRVNTXCIsIHJlc3RhdXJhbnQ6IHR4IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgcmVzdGF1cmFudDpcIiwgZXJyb3IpO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiBcIlJFU1RBVVJBTlRfQ1JFQVRJT05fRkFJTFwiLCBlcnJvciB9KTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9hZERhc2hib2FyZFJlc3RhdXJhbnRDb250cmFjdERhdGEgPSBhc3luYyAodXNlciwgUmVzdGF1cmFudCwgZGlzcGF0Y2gpID0+IHtcclxuICAgIFxyXG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gUmVzdGF1cmFudC5hZGRyZXNzXHJcbiAgICBjb25zdCBhYmkgPSBSRVNUQVVSQU5UX0FCSVxyXG4gICAgY29uc3QgY29udHJhY3QgPSBhd2FpdCBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB1c2VyKVxyXG4gICAgY29uc3QgbmFtZSA9IGF3YWl0IGNvbnRyYWN0Lm5hbWUoKVxyXG4gICAgY29uc3QgbXlDYXNoID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmFsYW5jZShjb250cmFjdEFkZHJlc3MpXHJcbiAgICBjb25zdCBjYXNoID0gTnVtYmVyKG15Q2FzaCkudG9TdHJpbmcoKVxyXG5cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0RBU0hCT0FSRF9SRVNUQVVSQU5UX0xPQURFRCcsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBuYW1lLCBjYXNoIH0pXHJcblxyXG4gICAgcmV0dXJuIGNvbnRyYWN0XHJcbiAgICBcclxufVxyXG4vLyBpbnRlcmFjdGlvbnMuanNcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVOZXdKb2IgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBuYW1lLCB3YWdlLCBkaXNwYXRjaCkgPT4ge1xyXG4gIGNvbnN0IHVzZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAvLyBDYWxsIHRoZSBjb250cmFjdCBmdW5jdGlvbiB0byBhZGQgYSBuZXcgam9iXHJcbiAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5hZGRKb2Iod2FnZSwgbmFtZSk7XHJcblxyXG4gIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBtaW5lZFxyXG4gIGF3YWl0IHR4LndhaXQoKTtcclxuXHJcbiAgLy8gUmVsb2FkIGFsbCBqb2JzXHJcbiAgYXdhaXQgbG9hZEFsbEpvYnMocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCk7XHJcbn07XHJcbmV4cG9ydCBjb25zdCBoaXJlTmV3RW1wbG95ZWUgPSBhc3luYyAodXNlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGpvYklkLCBuYW1lLCBlbXBsb3llZUFkZHJlc3MsIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gICAgLy8gQ2FsbCB0aGUgY29udHJhY3QgZnVuY3Rpb24gdG8gaGlyZSBhIG5ldyBlbXBsb3llZVxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5oaXJlRW1wbG95ZWUoam9iSWQsIG5hbWUsIGVtcGxveWVlQWRkcmVzcyk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkXHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgLy8gUmVsb2FkIGFsbCBlbXBsb3llZXNcclxuICAgIGF3YWl0IGxvYWRBbGxFbXBsb3llZXMocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGhpcmVOZXdFbXBsb3llZTonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxFbXBsb3llZXMgPSBhc3luYyAodXNlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIFxyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB1c2VyKTtcclxuXHJcbiAgICAvLyBGZXRjaCB0aGUgYXJyYXkgb2YgZW1wbG95ZWUgSURzXHJcbiAgICBjb25zdCBlbXBsb3llZUlkcyA9IGF3YWl0IGNvbnRyYWN0LmdldEVtcGxveWVlSWRzKCk7XHJcblxyXG4gICAgY29uc3QgZW1wbG95ZWVzQXJyYXkgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW1wbG95ZWVJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgZW1wbG95ZWVJZCA9IE51bWJlcihlbXBsb3llZUlkc1tpXSk7IC8vIENvbnZlcnQgQmlnTnVtYmVyIHRvIE51bWJlclxyXG4gICAgICBjb25zdCBlbXBsb3llZSA9IGF3YWl0IGNvbnRyYWN0LmVtcGxveWVlcyhlbXBsb3llZUlkKTtcclxuXHJcbiAgICAgIGVtcGxveWVlc0FycmF5LnB1c2goe1xyXG4gICAgICAgIGlkOiBlbXBsb3llZUlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgam9iSWQ6IGVtcGxveWVlLmpvYklkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgbmFtZTogZW1wbG95ZWUubmFtZSxcclxuICAgICAgICBhZGRyZXNzOiBlbXBsb3llZS5lbXBsb3llZUFkZHJlc3MsXHJcbiAgICAgICAgY2xvY2tTdGFtcDogZW1wbG95ZWUuY2xvY2tTdGFtcC50b1N0cmluZygpLFxyXG4gICAgICAgIGVtcGxveWVlUGVuc2lvbjogZW1wbG95ZWUuZW1wbG95ZWVQZW5zaW9uLnRvU3RyaW5nKCksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BhdGNoIGFjdGlvbiB0byB1cGRhdGUgZW1wbG95ZWVzIGluIFJlZHV4IHN0b3JlXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdFTVBMT1lFRVNfTE9BREVEJywgZW1wbG95ZWVzOiBlbXBsb3llZXNBcnJheSB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbG9hZEFsbEVtcGxveWVlczonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5leHBvcnQgY29uc3QgbG9hZEFsbEpvYnMgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAgIC8vIEZldGNoIHRoZSBhcnJheSBvZiBqb2IgSURzXHJcbiAgICBjb25zdCBqb2JJZHMgPSBhd2FpdCBjb250cmFjdC5nZXRKb2JJZHMoKTtcclxuXHJcbiAgICBjb25zdCBqb2JzQXJyYXkgPSBbXTtcclxuICAgIFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqb2JJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgam9iSWQgPSBOdW1iZXIoam9iSWRzW2ldKTsgLy8gQ29udmVydCBCaWdOdW1iZXIgdG8gTnVtYmVyXHJcbiAgICAgIGNvbnN0IGpvYiA9IGF3YWl0IGNvbnRyYWN0LmpvYnMoam9iSWQpO1xyXG5cclxuICAgICAgam9ic0FycmF5LnB1c2goe1xyXG4gICAgICAgIGlkOiBqb2JJZC50b1N0cmluZygpLFxyXG4gICAgICAgIGhvdXJseVdhZ2VJbldlaTogam9iLmhvdXJseVdhZ2VJbldlaS50b1N0cmluZygpLFxyXG4gICAgICAgIGpvYk5hbWU6IGpvYi5qb2JOYW1lLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIGpvYnMgaW4gUmVkdXggc3RvcmVcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0pPQlNfTE9BREVEJywgam9iczogam9ic0FycmF5IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBsb2FkQWxsSm9iczonLCBlcnJvci5tZXNzYWdlKTtcclxuICB9XHJcbn07XHJcbmV4cG9ydCBjb25zdCBzdGFydFNlcnZpY2UgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3Quc3RhcnRTZXJ2aWNlKCk7XHJcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgYmxvY2sgdGltZXN0YW1wIGZyb20gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcclxuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2socmVjZWlwdC5ibG9ja051bWJlcik7XHJcbiAgICBjb25zdCBzZXJ2aWNlU3RhcnRUaW1lID0gYmxvY2sudGltZXN0YW1wO1xyXG5cclxuICAgIC8vIERpc3BhdGNoIHRoZSBzZXJ2aWNlIHN0YXJ0IHRpbWVcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFUlZJQ0VfU1RBUlRFRCcsIHNlcnZpY2VTdGFydFRpbWUgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHN0YXJ0U2VydmljZTonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxTZXJ2aWNlcyA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIHNlcnZpY2UgSURzXHJcbiAgICBjb25zdCBzZXJ2aWNlSWRzID0gYXdhaXQgY29udHJhY3QuZ2V0U2VydmljZUlkcygpO1xyXG5cclxuICAgIGNvbnN0IHNlcnZpY2VzQXJyYXkgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VydmljZUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBzZXJ2aWNlSWQgPSBOdW1iZXIoc2VydmljZUlkc1tpXSk7XHJcbiAgICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBjb250cmFjdC5zZXJ2aWNlcyhzZXJ2aWNlSWQpO1xyXG5cclxuICAgICAgc2VydmljZXNBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogc2VydmljZUlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgc3RhcnRUaW1lOiBzZXJ2aWNlLnN0YXJ0VGltZS50b1N0cmluZygpLFxyXG4gICAgICAgIGVuZFRpbWU6IHNlcnZpY2UuZW5kVGltZS50b1N0cmluZygpLFxyXG4gICAgICAgIGNvc3Q6IHNlcnZpY2UuY29zdC50b1N0cmluZygpLFxyXG4gICAgICAgIHByb2ZpdDogc2VydmljZS5wcm9maXQudG9TdHJpbmcoKSxcclxuICAgICAgICByZXZlbnVlOiBzZXJ2aWNlLnJldmVudWUudG9TdHJpbmcoKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggYWN0aW9uIHRvIHVwZGF0ZSBzZXJ2aWNlcyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VSVklDRVNfTE9BREVEJywgc2VydmljZXM6IHNlcnZpY2VzQXJyYXkgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWRBbGxTZXJ2aWNlczonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGVuZFNlcnZpY2UgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZW5kU2VydmljZSgpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIE9wdGlvbmFsbHkgZGlzcGF0Y2ggYW4gYWN0aW9uIHRvIHVwZGF0ZSB0aGUgc2VydmljZSBzdGF0dXMgaW4gUmVkdXhcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFUlZJQ0VfU1RPUFBFRCcgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVuZFNlcnZpY2U6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVQT1MgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBuYW1lLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgc2lnbmVyKTtcclxuXHJcbiAgICAvLyBDYWxsIHRoZSBjcmVhdGVQT1MgZnVuY3Rpb24gb24gdGhlIGNvbnRyYWN0XHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmNyZWF0ZVBPUyhuYW1lKTtcclxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgLy8gRXh0cmFjdCB0aGUgUE9TQ3JlYXRlZCBldmVudCBmcm9tIHRoZSByZWNlaXB0XHJcbiAgICBjb25zdCBldmVudCA9IHJlY2VpcHQubG9nc1xyXG4gICAgICAubWFwKChsb2cpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsb2cpO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAuZmluZCgocGFyc2VkTG9nKSA9PiBwYXJzZWRMb2cgJiYgcGFyc2VkTG9nLm5hbWUgPT09ICdQT1NDcmVhdGVkJyk7XHJcblxyXG4gICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgIGNvbnN0IHBvc0lkID0gZXZlbnQuYXJncy5pZC50b1N0cmluZygpO1xyXG4gICAgICBjb25zdCBwb3NBZGRyZXNzID0gZXZlbnQuYXJncy5wb3M7XHJcblxyXG4gICAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIFJlZHV4IHN0b3JlXHJcbiAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbG9hZCBQT1MgbGlzdFxyXG4gICAgYXdhaXQgbG9hZEFsbFBPUyhwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlUE9TOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9hZEFsbFBPUyA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgUkVTVEFVUkFOVF9BQkksIHNpZ25lcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIFBPUyBJRHNcclxuICAgIGNvbnN0IHBvc0lkcyA9IGF3YWl0IGNvbnRyYWN0LmdldFBPU0lkcygpO1xyXG5cclxuICAgIGNvbnN0IHBvc0FycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc0lkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwb3NJZCA9IE51bWJlcihwb3NJZHNbaV0pO1xyXG4gICAgICBjb25zdCBwb3NBZGRyZXNzID0gYXdhaXQgY29udHJhY3QuUE9TTWFwcGluZyhwb3NJZCk7XHJcbiAgICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gYXdhaXQgbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBQT1NfQUJJLCBzaWduZXIpXHJcbiAgICAgIGNvbnN0IHBvc05hbWUgPSBhd2FpdCBwb3NDb250cmFjdC5nZXROYW1lKClcclxuICAgICAgXHJcblxyXG4gICAgICBwb3NBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogcG9zSWQudG9TdHJpbmcoKSxcclxuICAgICAgICBhZGRyZXNzOiBwb3NBZGRyZXNzLFxyXG4gICAgICAgIG5hbWU6IHBvc05hbWUudG9TdHJpbmcoKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIFBPUyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnUE9TX0xPQURFRCcsIHBvc0FycmF5IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBsb2FkQWxsUE9TOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcbiAgZXhwb3J0IGNvbnN0IGxvYWRBbGxNZW51SXRlbXMgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKClcclxuICAgIGNvbnN0IHJlc3RhdXJhbnRDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBSRVNUQVVSQU5UX0FCSSwgdXNlcik7XHJcblxyXG4gICAgLy8gR2V0IGFsbCBQT1MgYWRkcmVzc2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzdGF1cmFudFxyXG4gICAgY29uc3QgcG9zQWRkcmVzc2VzID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0LmdldEFsbFBPU0FkZHJlc3NlcygpO1xyXG4gICAgY29uc29sZS5sb2coJ2hlbGxvJylcclxuICAgIGlmIChwb3NBZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0xPQURfQUxMX01FTlVfSVRFTVNfU1VDQ0VTUycsIHBheWxvYWQ6IFtdIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmlyc3RQT1NBZGRyZXNzID0gcG9zQWRkcmVzc2VzWzBdO1xyXG5cclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChmaXJzdFBPU0FkZHJlc3MsIFBPU19BQkksIHByb3ZpZGVyKTtcclxuXHJcbiAgICBjb25zdCBtZW51SXRlbUlkcyA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldE1lbnVJdGVtSWRzKCk7XHJcbiAgICBsZXQgbWVudUl0ZW1zID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZW51SXRlbUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBpZCA9IE51bWJlcihtZW51SXRlbUlkc1tpXSk7XHJcbiAgICAgIGNvbnN0IG1lbnVJdGVtID0gYXdhaXQgcG9zQ29udHJhY3QubWVudShpZCk7XHJcblxyXG4gICAgICBtZW51SXRlbXMucHVzaCh7XHJcbiAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgIGNvc3Q6IGV0aGVycy5mb3JtYXRFdGhlcihtZW51SXRlbS5jb3N0KSxcclxuICAgICAgICBuYW1lOiBtZW51SXRlbS5uYW1lLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdMT0FEX0FMTF9NRU5VX0lURU1TX1NVQ0NFU1MnLCBwYXlsb2FkOiBtZW51SXRlbXMgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbWVudSBpdGVtczonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBhZGROZXdNZW51SXRlbSA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGNvc3QsIG5hbWUsIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgcmVzdGF1cmFudENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIFJFU1RBVVJBTlRfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgIC8vIEdldCBhbGwgUE9TIGFkZHJlc3NlcyBmcm9tIHRoZSByZXN0YXVyYW50IGNvbnRyYWN0XHJcbiAgICBjb25zdCBwb3NBZGRyZXNzZXMgPSBhd2FpdCByZXN0YXVyYW50Q29udHJhY3QuZ2V0QWxsUE9TQWRkcmVzc2VzKCk7XHJcblxyXG4gICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggUE9TIGFkZHJlc3MgYW5kIGFkZCB0aGUgbWVudSBpdGVtXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc0FkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwb3NBZGRyZXNzID0gcG9zQWRkcmVzc2VzW2ldO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGluc3RhbmNlIGZvciBlYWNoIFBPU1xyXG4gICAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKTtcclxuXHJcbiAgICAgIC8vIENhbGwgdGhlIGFkZE1lbnVJdGVtIGZ1bmN0aW9uIG9uIGVhY2ggUE9TIGNvbnRyYWN0XHJcbiAgICAgIGNvbnN0IGNvc3RJbldlaSA9IGV0aGVycy5wYXJzZVVuaXRzKGNvc3QudG9TdHJpbmcoKSwgJ2V0aGVyJyk7XHJcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9zQ29udHJhY3QuYWRkTWVudUl0ZW0oY29zdEluV2VpLCBuYW1lKTtcclxuICAgICAgYXdhaXQgdHgud2FpdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ01FTlVfSVRFTV9BRERFRCcsIHBheWxvYWQ6IHsgY29zdCwgbmFtZSB9IH0pO1xyXG5cclxuICAgIGF3YWl0IGxvYWRBbGxNZW51SXRlbXMocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBuZXcgbWVudSBpdGVtOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBJbiBpbnRlcmFjdGlvbnMuanMgKG5lYXIgbG9hZEFsbFBPUyBvciBhZnRlciBpdCk6XHJcbmV4cG9ydCBjb25zdCBsb2FkRW1wbG95ZWVSZWxldmFudFBPUyA9IGFzeW5jIChwcm92aWRlciwgcmVzdGF1cmFudEFkZHJlc3MsIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgcmVzdGF1cmFudENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChyZXN0YXVyYW50QWRkcmVzcywgUkVTVEFVUkFOVF9BQkksIHNpZ25lcik7XHJcbiAgICBjb25zdCBwb3NJZHMgPSBhd2FpdCByZXN0YXVyYW50Q29udHJhY3QuZ2V0UE9TSWRzKCk7XHJcbiAgICBcclxuICAgIGNvbnN0IHBvc0FycmF5ID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgcG9zSWQgPSBOdW1iZXIocG9zSWRzW2ldKTtcclxuICAgICAgY29uc3QgcG9zQWRkcmVzcyA9IGF3YWl0IHJlc3RhdXJhbnRDb250cmFjdC5QT1NNYXBwaW5nKHBvc0lkKTtcclxuICAgICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIFBPU19BQkksIHNpZ25lcik7XHJcbiAgICAgIGNvbnN0IHBvc05hbWUgPSBhd2FpdCBwb3NDb250cmFjdC5nZXROYW1lKCk7XHJcbiAgICAgIHBvc0FycmF5LnB1c2goe1xyXG4gICAgICAgIGlkOiBwb3NJZC50b1N0cmluZygpLFxyXG4gICAgICAgIGFkZHJlc3M6IHBvc0FkZHJlc3MsXHJcbiAgICAgICAgbmFtZTogcG9zTmFtZS50b1N0cmluZygpXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zb2xlLmxvZygnMScpXHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhwb3NBcnJheSlcclxuXHJcbiAgICAvLyBEaXNwYXRjaCBhbiBhY3Rpb24gdGhhdCBzcGVjaWZpY2FsbHkgc3RvcmVzIFBPUyBhZGRyZXNzZXMgcmVsZXZhbnQgdG8gdGhlIGN1cnJlbnQgZW1wbG95ZWUncyByZXN0YXVyYW50XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdSRUxFVkFOVF9QT1NfTE9BREVEX0ZPUl9FTVBMT1lFRScsIHBheWxvYWQ6IHBvc0FycmF5IH0pO1xyXG4gICAgcmV0dXJuIHBvc0FycmF5O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBsb2FkRW1wbG95ZWVSZWxldmFudFBPUzonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVUaWNrZXRGb3JQT1MgPSBhc3luYyAoXHJcbiAgcHJvdmlkZXIsXHJcbiAgcG9zQWRkcmVzcyxcclxuICBwb3NBYmksXHJcbiAgdGlja2V0TmFtZSxcclxuICBzZXJ2ZXJBZGRyZXNzLFxyXG4gIGRpc3BhdGNoXHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBwb3NBYmksIHNpZ25lcik7XHJcblxyXG4gICAgLy8gVGhlIFBPUyBjb250cmFjdCBleHRlbmRzIE1lbnVUaWNrZXRCYXNlLCB3aGljaCBoYXMgY3JlYXRlVGlja2V0KF9zZXJ2ZXIsIF9uYW1lKVxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBwb3NDb250cmFjdC5jcmVhdGVUaWNrZXQoc2VydmVyQWRkcmVzcywgdGlja2V0TmFtZSk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgLy8gQWZ0ZXIgY3JlYXRpb24sIHJlbG9hZCB0aWNrZXRzIHNvIHRoZSBVSSByZW1haW5zIHVwLXRvLWRhdGVcclxuICAgIGF3YWl0IGxvYWRBbGxUaWNrZXRzRm9yUE9TKHByb3ZpZGVyLCBwb3NBZGRyZXNzLCBwb3NBYmksIGRpc3BhdGNoKTtcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdDUkVBVEVfVElDS0VUX1NVQ0NFU1MnIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB0aWNrZXQ6JywgZXJyb3IpO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQ1JFQVRFX1RJQ0tFVF9GQUlMJywgZXJyb3IgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvYWRzIGFsbCB0aWNrZXRzIGZyb20gYSBnaXZlbiBQT1MgY29udHJhY3QuXHJcbiAqIEBwYXJhbSBwcm92aWRlciBFdGhlcnMgcHJvdmlkZXIvc2lnbmVyXHJcbiAqIEBwYXJhbSBwb3NBZGRyZXNzIFRoZSBQT1MgY29udHJhY3QgYWRkcmVzc1xyXG4gKiBAcGFyYW0gcG9zQWJpIFRoZSBBQkkgZm9yIHRoZSBQT1MgY29udHJhY3RcclxuICogQHBhcmFtIGRpc3BhdGNoIFJlZHV4IGRpc3BhdGNoIGZ1bmN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbG9hZEFsbFRpY2tldHNGb3JQT1MgPSBhc3luYyAocHJvdmlkZXIsIHBvc0FkZHJlc3MsIHBvc0FiaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKTtcclxuICAgIC8vIFRoZSBQT1MgY29udHJhY3QgKHZpYSBNZW51VGlja2V0QmFzZSkgaGFzIGFuIGFycmF5IFRpY2tldElkcywgc28gd2UgcmVhZCB0aGF0XHJcbiAgICBjb25zdCB0aWNrZXRJZHMgPSBhd2FpdCBwb3NDb250cmFjdC5nZXRUaWNrZXRJZHMoKTtcclxuICAgIGNvbnN0IHRpY2tldHNBcnJheSA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja2V0SWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHRpY2tldElkQk4gPSB0aWNrZXRJZHNbaV07ICAvLyBCaWdJbnRcclxuICAgICAgY29uc3QgdGlja2V0SWQgPSBOdW1iZXIodGlja2V0SWRCTik7XHJcbiAgICAgIGNvbnN0IHRpY2tldFN0cnVjdCA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldFRpY2tldCh0aWNrZXRJZCk7IFxyXG4gICAgICAvLyB0aWNrZXRTdHJ1Y3QgaGFzIHsgbmFtZSwgb3JkZXJzW10sIHNlcnZlciwgaWQsIHBhaWQgfVxyXG5cclxuICAgICAgdGlja2V0c0FycmF5LnB1c2goe1xyXG4gICAgICAgIGlkOiB0aWNrZXRTdHJ1Y3QuaWQudG9TdHJpbmcoKSxcclxuICAgICAgICBuYW1lOiB0aWNrZXRTdHJ1Y3QubmFtZSxcclxuICAgICAgICBzZXJ2ZXI6IHRpY2tldFN0cnVjdC5zZXJ2ZXIsXHJcbiAgICAgICAgcGFpZDogdGlja2V0U3RydWN0LnBhaWQsXHJcbiAgICAgICAgcG9zQWRkcmVzczogcG9zQWRkcmVzcyAvLyBTbyB3ZSBrbm93IHdoaWNoIFBPUyB0aGlzIHRpY2tldCBiZWxvbmdzIHRvXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BhdGNoIHRvIHN0b3JlIGluIFJlZHV4LiBcclxuICAgIC8vIFdlIGNhbiBzdG9yZSB0aGVtIFBPUy1ieS1QT1Mgb3IgaW4gYSBzaW5nbGUgYXJyYXkuIFxyXG4gICAgLy8gQmVsb3csIHdlIGp1c3QgcHVzaCB0aGVtIGFsbCBpbnRvIGEgc2luZ2xlIGFycmF5IGluIFJlZHV4OlxyXG4gICAgZGlzcGF0Y2goeyBcclxuICAgICAgdHlwZTogJ1RJQ0tFVFNfTE9BREVEJywgXHJcbiAgICAgIHBheWxvYWQ6IHsgcG9zQWRkcmVzcywgdGlja2V0czogdGlja2V0c0FycmF5IH0gXHJcbiAgICB9KTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgdGlja2V0cyBmb3IgUE9TOicsIGVycm9yKTtcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1RJQ0tFVFNfTE9BRF9GQUlMJywgZXJyb3IgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBzZXRBY3RpdmVUaWNrZXQgPSBhc3luYyAoZGlzcGF0Y2gsIHRpY2tldCkgPT4ge1xyXG4gIGRpc3BhdGNoKHsgdHlwZTogJ0FDVElWRV9USUNLRVRfU0VUJywgcGF5bG9hZDogdGlja2V0IH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFycyB0aGUgY3VycmVudGx5IGFjdGl2ZSB0aWNrZXQgaW4gUmVkdXguXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkaXNwYXRjaCBSZWR1eCBkaXNwYXRjaFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNsZWFyQWN0aXZlVGlja2V0ID0gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XHJcbiAgZGlzcGF0Y2goeyB0eXBlOiAnQUNUSVZFX1RJQ0tFVF9DTEVBUicgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTG9hZHMgYWxsIG1lbnUgaXRlbXMgZm9yIGEgZ2l2ZW4gUE9TIGNvbnRyYWN0IGFkZHJlc3MgYW5kIHJldHVybnMgdGhlbSBhcyBhbiBhcnJheS5cclxuICogT3B0aW9uYWxseSwgeW91IGNvdWxkIGRpc3BhdGNoIGEgUmVkdXggYWN0aW9uIHRvIHN0b3JlIHRoZW0gaWYgZGVzaXJlZC5cclxuICpcclxuICogQHBhcmFtIHsqfSBwcm92aWRlciBFdGhlcnMgcHJvdmlkZXIvc2lnbmVyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwb3NBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSBQT1NcclxuICogQHBhcmFtIHtBcnJheX0gcG9zQWJpIFRoZSBBQkkgZm9yIHRoZSBQT1MgY29udHJhY3RcclxuICogQHBhcmFtIHtPYmplY3R9IGRpc3BhdGNoIFJlZHV4IGRpc3BhdGNoXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgbWVudSBpdGVtcyBbeyBpZCwgbmFtZSwgY29zdCB9LCAuLi5dXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbG9hZE1lbnVJdGVtc0ZvclBPUyA9IGFzeW5jIChwcm92aWRlciwgcG9zQWRkcmVzcywgcG9zQWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBPcHRpb25hbDogZGlzcGF0Y2goeyB0eXBlOiAnTUVOVV9JVEVNU19MT0FEX1JFUVVFU1QnIH0pO1xyXG5cclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIFBPU19BQkksIHNpZ25lcik7XHJcbiAgICBjb25zdCBtZW51SXRlbUlkcyA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldE1lbnVJdGVtSWRzKCk7XHJcbiAgICBcclxuXHJcbiAgICBsZXQgbWVudUl0ZW1zID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lbnVJdGVtSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGlkID0gTnVtYmVyKG1lbnVJdGVtSWRzW2ldKTtcclxuICAgICAgY29uc3QgaXRlbSA9IGF3YWl0IHBvc0NvbnRyYWN0Lm1lbnUoaWQpO1xyXG4gICAgICAvLyBDb252ZXJ0IGNvc3QgZnJvbSB3ZWkgdG8gRXRoZXIgKG9yIHlvdSBjYW4gc3RvcmUgcmF3IHdlaSkuXHJcbiAgICAgIG1lbnVJdGVtcy5wdXNoKHtcclxuICAgICAgICBpZCxcclxuICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXHJcbiAgICAgICAgY29zdDogTnVtYmVyKGV0aGVycy5mb3JtYXRFdGhlcihpdGVtLmNvc3QpKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT3B0aW9uYWw6IGRpc3BhdGNoKHsgdHlwZTogJ01FTlVfSVRFTVNfRk9SX1BPU19MT0FERUQnLCBwYXlsb2FkOiBtZW51SXRlbXMgfSk7XHJcblxyXG4gICAgcmV0dXJuIG1lbnVJdGVtcztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBtZW51IGZvciBQT1M6JywgZXJyb3IpO1xyXG4gICAgLy8gT3B0aW9uYWw6IGRpc3BhdGNoKHsgdHlwZTogJ01FTlVfSVRFTVNfTE9BRF9GQUlMJywgZXJyb3IgfSk7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBhZGRUaWNrZXRPcmRlcnMgPSBhc3luYyAoXHJcbiAgcHJvdmlkZXIsXHJcbiAgcG9zQWRkcmVzcyxcclxuICBwb3NBYmksXHJcbiAgdGlja2V0SWQsXHJcbiAgaXRlbXMsIC8vIGFycmF5IG9mIHsgY29zdCwgbmFtZSB9IHRvIGJlIGFwcGVuZGVkXHJcbiAgZGlzcGF0Y2hcclxuKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIFBPU19BQkksIHNpZ25lcik7XHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IHBvc0NvbnRyYWN0LmFkZFRpY2tldE9yZGVycyh0aWNrZXRJZCwgaXRlbXMpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIE9wdGlvbmFsbHkgcmVsb2FkIHRoZSB1cGRhdGVkIHRpY2tldC4uLlxyXG4gICAgLy8gYXdhaXQgbG9hZEFsbFRpY2tldHNGb3JQT1MocHJvdmlkZXIsIHBvc0FkZHJlc3MsIHBvc0FiaSwgZGlzcGF0Y2gpO1xyXG5cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FERF9USUNLRVRfT1JERVJTX1NVQ0NFU1MnIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgb3JkZXJzOicsIGVycm9yKTtcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FERF9USUNLRVRfT1JERVJTX0ZBSUwnLCBlcnJvciB9KTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9hZEZ1bGxUaWNrZXREZXRhaWxzID0gYXN5bmMgKFxyXG4gIHByb3ZpZGVyLFxyXG4gIHBvc0FkZHJlc3MsXHJcbiAgcG9zQWJpLFxyXG4gIHRpY2tldElkLFxyXG4gIGRpc3BhdGNoXHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBQT1NfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgIC8vIEdyYWIgdGhlIGVudGlyZSB0aWNrZXQgc3RydWN0IGZyb20gdGhlIGNvbnRyYWN0XHJcbiAgICBjb25zdCB0aWNrZXRTdHJ1Y3QgPSBhd2FpdCBwb3NDb250cmFjdC5nZXRUaWNrZXQodGlja2V0SWQpO1xyXG4gICAgLy8gdGlja2V0U3RydWN0IC0+IHsgbmFtZSwgb3JkZXJzW10sIHNlcnZlciwgaWQsIHBhaWQgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgb3JkZXJzW10gZnJvbSBjb250cmFjdCAoY29zdCBpbiB3ZWkpIHRvIGEgZnJpZW5kbGllciBKUyBhcnJheVxyXG4gICAgY29uc3Qgb3JkZXJzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tldFN0cnVjdC5vcmRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgb3JkZXJJdGVtID0gdGlja2V0U3RydWN0Lm9yZGVyc1tpXTtcclxuICAgICAgb3JkZXJzLnB1c2goe1xyXG4gICAgICAgIG5hbWU6IG9yZGVySXRlbS5uYW1lLFxyXG4gICAgICAgIGNvc3Q6IE51bWJlcihldGhlcnMuZm9ybWF0RXRoZXIob3JkZXJJdGVtLmNvc3QpKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZnVsbFRpY2tldCA9IHtcclxuICAgICAgaWQ6IE51bWJlcih0aWNrZXRTdHJ1Y3QuaWQpLnRvU3RyaW5nKCksXHJcbiAgICAgIG5hbWU6IHRpY2tldFN0cnVjdC5uYW1lLFxyXG4gICAgICBzZXJ2ZXI6IHRpY2tldFN0cnVjdC5zZXJ2ZXIsXHJcbiAgICAgIHBhaWQ6IHRpY2tldFN0cnVjdC5wYWlkLFxyXG4gICAgICBwb3NBZGRyZXNzLFxyXG4gICAgICBvcmRlcnNcclxuICAgIH07XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggc28gUmVkdXgga25vd3MgYWJvdXQgdGhlIGZ1bGx5IGRldGFpbGVkIHRpY2tldFxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQUNUSVZFX1RJQ0tFVF9ERVRBSUxTX0xPQURFRCcsIHBheWxvYWQ6IGZ1bGxUaWNrZXQgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgZnVsbCB0aWNrZXQgZGV0YWlsczonLCBlcnJvcik7XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdBQ1RJVkVfVElDS0VUX0RFVEFJTFNfRkFJTCcsIGVycm9yIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBidWZmZXJJdGVtRm9yVGlja2V0ID0gKHRpY2tldElkLCBpdGVtKSA9PiB7XHJcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiAnQUREX0lURU1fVE9fUEVORElOR19CVUZGRVInLFxyXG4gICAgICBwYXlsb2FkOiB7IHRpY2tldElkLCBpdGVtIH1cclxuICAgIH0pO1xyXG4gIH07XHJcbn07XHJcblxyXG4vLyAyKSBBIGZ1bmN0aW9uIHRoYXQgKnJpbmdzKiBhbGwgYnVmZmVyZWQgaXRlbXMgZm9yIGEgZ2l2ZW4gdGlja2V0SWRcclxuLy8gICAgYnkgY2FsbGluZyBgYWRkVGlja2V0T3JkZXJzYCBpbiB0aGUgUE9TIGNvbnRyYWN0LlxyXG5cclxuZXhwb3J0IGNvbnN0IHJpbmdCdWZmZXJlZEl0ZW1zID0gYXN5bmMgKFxyXG4gIHByb3ZpZGVyLFxyXG4gIHBvc0FkZHJlc3MsXHJcbiAgcGVuZGluZ09yZGVyQnVmZmVyLFxyXG4gIHBvc0FiaSxcclxuICB0aWNrZXRJZCwgICAgICAgLy8gY291bGQgYmUgYSBudW1iZXIgb3Igc3RyaW5nXHJcbiAgZGlzcGF0Y2gsXHJcbiAgZ2V0U3RhdGVcclxuKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHN0cmluZ0lkID0gdGlja2V0SWQudG9TdHJpbmcoKVxyXG5cclxuICAgIC8vIEdldCB0aGUgZW50aXJlIHBlbmRpbmcgYnVmZmVyXHJcbiAgIFxyXG4gICAgY29uc3QgaXRlbXNUb1JpbmcgPSBwZW5kaW5nT3JkZXJCdWZmZXJbc3RyaW5nSWRdIHx8IFtdXHJcblxyXG4gICAgaWYgKGl0ZW1zVG9SaW5nLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnTm8gaXRlbXMgdG8gcmluZyBmb3IgdGhpcyB0aWNrZXQuJylcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9ybWF0IHRoZW0gZm9yIHRoZSBjb250cmFjdFxyXG4gICAgY29uc3QgcnVuZ0l0ZW1zID0gaXRlbXNUb1JpbmcubWFwKChpdGVtKSA9PiAoe1xyXG4gICAgICBjb3N0OiBldGhlcnMucGFyc2VVbml0cyhpdGVtLmNvc3QudG9TdHJpbmcoKSwgJ2V0aGVyJyksXHJcbiAgICAgIG5hbWU6IGl0ZW0ubmFtZVxyXG4gICAgfSkpXHJcblxyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKClcclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBwb3NBYmksIHNpZ25lcilcclxuXHJcbiAgICAvLyBTZW5kIHRyYW5zYWN0aW9uXHJcbiAgICBjb25zb2xlLmxvZygnZnVuJylcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9zQ29udHJhY3QuYWRkVGlja2V0T3JkZXJzKHRpY2tldElkLCBydW5nSXRlbXMpXHJcbiAgICBhd2FpdCB0eC53YWl0KClcclxuICAgIGNvbnNvbGUubG9nKCdmdW4nKVxyXG5cclxuICAgIC8vIE5vdyB0ZWxsIFJlZHV4IHdlIHN1Y2NlZWRlZFxyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiAnT1JERVJfUklOR19TVUNDRVNTJyxcclxuICAgICAgcGF5bG9hZDogeyBcclxuICAgICAgICB0aWNrZXRJZDogdGlja2V0SWQsICAvLyBwYXNzIGEgc3RyaW5nXHJcbiAgICAgICAgcnVuZ0l0ZW1zOiBpdGVtc1RvUmluZ1xyXG4gICAgICB9XHJcblxyXG4gICAgfSlcclxuICAgICAgXHJcbiAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHJhbmcgaXRlbXMgZm9yIHRpY2tldDogJHtzdHJpbmdJZH1gKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiByaW5nQnVmZmVyZWRJdGVtczonLCBlcnJvcilcclxuICB9XHJcbn1cclxuZXhwb3J0IGNvbnN0IGNsb2NrSW5FbXBsb3llZSA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGVtcGxveWVlSWQpID0+IHtcclxuICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHNpZ25lcik7XHJcbiAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5jbG9ja0luKGVtcGxveWVlSWQpO1xyXG4gIGF3YWl0IHR4LndhaXQoKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjbG9ja091dEVtcGxveWVlID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZW1wbG95ZWVJZCkgPT4ge1xyXG4gIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgc2lnbmVyKTtcclxuICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmNsb2NrT3V0KGVtcGxveWVlSWQpO1xyXG4gIGF3YWl0IHR4LndhaXQoKTtcclxufTtcclxuXHJcblxyXG4vLyBJbiBzdG9yZS9pbnRlcmFjdGlvbnMuanNcclxuXHJcbi8vIHN0b3JlL2ludGVyYWN0aW9ucy5qc1xyXG5leHBvcnQgY29uc3QgZmV0Y2hFbXBsb3llZVN0YXR1c0Zyb21TZXJ2ZXIgPVxyXG4gICh7IHNpZ25lciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGpvYk5hbWUgfSkgPT5cclxuICBhc3luYyAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyAxKSBUaGUgcHVibGljIGFkZHJlc3Mgb2YgdGhlIHVzZXJcclxuICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xyXG5cclxuICAgICAgLy8gMikgQnVpbGQgdGhlIHBheWxvYWRcclxuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgdXNlckFkZHJlc3MsXHJcbiAgICAgICAgYWJpLFxyXG4gICAgICAgIGpvYk5hbWVcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIDMpIFBPU1QgdG8geW91ciBjdXN0b20gcm91dGVcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9lbXBsb3llZVN0YXR1cycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIC8vIDQpIERpc3BhdGNoIGlmIHlvdSB3YW50IHRvIHN0b3JlIGluIFJlZHV4XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0VNUExPWUVFX1NUQVRVU19GUk9NX1NFUlZFUicsIHBheWxvYWQ6IGRhdGEgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBmZXRjaEVtcGxveWVlU3RhdHVzRnJvbVNlcnZlcjonLCBlcnJvcik7XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0VNUExPWUVFX1NUQVRVU19GUk9NX1NFUlZFUl9FUlJPUicsIGVycm9yIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiJdLCJuYW1lcyI6WyJldGhlcnMiLCJSRVNUQVVSQU5UX0FCSSIsIkRFQ0VOVFJBVEFMSVRZU0VSVklDRUZBQ1RPUllfQUJJIiwiUE9TX0FCSSIsInVzZVNlbGVjdG9yIiwiR2xvYmFsUmVzdGF1cmFudHMiLCJsb2FkUHJvdmlkZXIiLCJkaXNwYXRjaCIsImNvbm5lY3Rpb24iLCJCcm93c2VyUHJvdmlkZXIiLCJ3aW5kb3ciLCJldGhlcmV1bSIsInR5cGUiLCJsb2FkQWNjb3VudCIsInByb3ZpZGVyIiwiYWNjb3VudHMiLCJzZW5kIiwiYWNjb3VudCIsImdldEFkZHJlc3MiLCJsb2FkTmV0d29yayIsImNoYWluSWQiLCJnZXROZXR3b3JrIiwiTnVtYmVyIiwic3Vic2NyaWJlVG9FdmVudHMiLCJyZXN0YXVyYW50RmFjdG9yeSIsIlJlc3RhdXJhbnRzIiwib24iLCJyZXN0YXVyYW50IiwiaWQiLCJvd25lciIsImV2ZW50IiwiX3Jlc3RhdXJhbnQiLCJhcmdzIiwidGltZXN0YW1wIiwiam9iIiwibG9hZEZhY3RvcnkiLCJ1c2VyIiwiYWRkcmVzcyIsImRlY2VudHJhdGFsaXR5U2VydmljZUZhY3RvcnkiLCJDb250cmFjdCIsImFiaSIsImxvYWRBbGxSZXN0YXVyYW50cyIsImZhY3RvcnkiLCJyZXN0YXVyYW50QWRkcmVzc2VzIiwiZ2V0QWxsUmVzdGF1cmFudHMiLCJpIiwibGVuZ3RoIiwicmVzdGF1cmFudEFkZHJlc3MiLCJyZXN0YXVyYW50Q29udHJhY3QiLCJuYW1lIiwiYmFsYW5jZSIsImdldEJhbGFuY2UiLCJwdXNoIiwiZm9ybWF0RXRoZXIiLCJlcnJvciIsImNvbnNvbGUiLCJsb2FkTXlSZXN0YXVyYW50cyIsIm15UmVzdGF1cmFudHMiLCJmaWx0ZXIiLCJkZWNvcmF0ZU15UmVzdGF1cmFudHMiLCJkZWNvcmF0ZWRSZXN0YXVyYW50cyIsImNvbnRyYWN0IiwibXlOYW1lIiwidG9TdHJpbmciLCJjYXNoIiwiY3JlYXRlTmV3UmVzdGF1cmFudCIsInJlc3RhdXJhbnROYW1lIiwidG90YWxDb3N0V2VpIiwidG90YWxDb3N0IiwiQmlnSW50IiwiTWF0aCIsImZsb29yIiwiYWxlcnQiLCJ0eCIsImNyZWF0ZVJlc3RhdXJhbnQiLCJ2YWx1ZSIsIndhaXQiLCJsb2FkRGFzaGJvYXJkUmVzdGF1cmFudENvbnRyYWN0RGF0YSIsIlJlc3RhdXJhbnQiLCJjb250cmFjdEFkZHJlc3MiLCJteUNhc2giLCJjcmVhdGVOZXdKb2IiLCJ3YWdlIiwiZ2V0U2lnbmVyIiwiYWRkSm9iIiwibG9hZEFsbEpvYnMiLCJoaXJlTmV3RW1wbG95ZWUiLCJqb2JJZCIsImVtcGxveWVlQWRkcmVzcyIsImhpcmVFbXBsb3llZSIsImxvYWRBbGxFbXBsb3llZXMiLCJlbXBsb3llZUlkcyIsImdldEVtcGxveWVlSWRzIiwiZW1wbG95ZWVzQXJyYXkiLCJlbXBsb3llZUlkIiwiZW1wbG95ZWUiLCJlbXBsb3llZXMiLCJjbG9ja1N0YW1wIiwiZW1wbG95ZWVQZW5zaW9uIiwiam9iSWRzIiwiZ2V0Sm9iSWRzIiwiam9ic0FycmF5Iiwiam9icyIsImhvdXJseVdhZ2VJbldlaSIsImpvYk5hbWUiLCJtZXNzYWdlIiwic3RhcnRTZXJ2aWNlIiwicmVjZWlwdCIsImJsb2NrIiwiZ2V0QmxvY2siLCJibG9ja051bWJlciIsInNlcnZpY2VTdGFydFRpbWUiLCJsb2FkQWxsU2VydmljZXMiLCJzZXJ2aWNlSWRzIiwiZ2V0U2VydmljZUlkcyIsInNlcnZpY2VzQXJyYXkiLCJzZXJ2aWNlSWQiLCJzZXJ2aWNlIiwic2VydmljZXMiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiY29zdCIsInByb2ZpdCIsInJldmVudWUiLCJlbmRTZXJ2aWNlIiwiY3JlYXRlUE9TIiwic2lnbmVyIiwibG9ncyIsIm1hcCIsImxvZyIsImludGVyZmFjZSIsInBhcnNlTG9nIiwiZmluZCIsInBhcnNlZExvZyIsInBvc0lkIiwicG9zQWRkcmVzcyIsInBvcyIsImxvYWRBbGxQT1MiLCJwb3NJZHMiLCJnZXRQT1NJZHMiLCJwb3NBcnJheSIsIlBPU01hcHBpbmciLCJwb3NDb250cmFjdCIsInBvc05hbWUiLCJnZXROYW1lIiwibG9hZEFsbE1lbnVJdGVtcyIsInBvc0FkZHJlc3NlcyIsImdldEFsbFBPU0FkZHJlc3NlcyIsInBheWxvYWQiLCJmaXJzdFBPU0FkZHJlc3MiLCJtZW51SXRlbUlkcyIsImdldE1lbnVJdGVtSWRzIiwibWVudUl0ZW1zIiwibWVudUl0ZW0iLCJtZW51IiwiYWRkTmV3TWVudUl0ZW0iLCJjb3N0SW5XZWkiLCJwYXJzZVVuaXRzIiwiYWRkTWVudUl0ZW0iLCJsb2FkRW1wbG95ZWVSZWxldmFudFBPUyIsImNyZWF0ZVRpY2tldEZvclBPUyIsInBvc0FiaSIsInRpY2tldE5hbWUiLCJzZXJ2ZXJBZGRyZXNzIiwiY3JlYXRlVGlja2V0IiwibG9hZEFsbFRpY2tldHNGb3JQT1MiLCJ0aWNrZXRJZHMiLCJnZXRUaWNrZXRJZHMiLCJ0aWNrZXRzQXJyYXkiLCJ0aWNrZXRJZEJOIiwidGlja2V0SWQiLCJ0aWNrZXRTdHJ1Y3QiLCJnZXRUaWNrZXQiLCJzZXJ2ZXIiLCJwYWlkIiwidGlja2V0cyIsInNldEFjdGl2ZVRpY2tldCIsInRpY2tldCIsImNsZWFyQWN0aXZlVGlja2V0IiwibG9hZE1lbnVJdGVtc0ZvclBPUyIsIml0ZW0iLCJhZGRUaWNrZXRPcmRlcnMiLCJpdGVtcyIsImxvYWRGdWxsVGlja2V0RGV0YWlscyIsIm9yZGVycyIsIm9yZGVySXRlbSIsImZ1bGxUaWNrZXQiLCJidWZmZXJJdGVtRm9yVGlja2V0IiwicmluZ0J1ZmZlcmVkSXRlbXMiLCJwZW5kaW5nT3JkZXJCdWZmZXIiLCJnZXRTdGF0ZSIsInN0cmluZ0lkIiwiaXRlbXNUb1JpbmciLCJydW5nSXRlbXMiLCJjbG9ja0luRW1wbG95ZWUiLCJjbG9ja0luIiwiY2xvY2tPdXRFbXBsb3llZSIsImNsb2NrT3V0IiwiZmV0Y2hFbXBsb3llZVN0YXR1c0Zyb21TZXJ2ZXIiLCJ1c2VyQWRkcmVzcyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImRhdGEiLCJqc29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/store/interactions.js\n"));

/***/ })

});