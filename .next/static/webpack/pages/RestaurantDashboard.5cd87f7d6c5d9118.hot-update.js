"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/RestaurantDashboard",{

/***/ "./src/store/interactions.js":
/*!***********************************!*\
  !*** ./src/store/interactions.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNewMenuItem: function() { return /* binding */ addNewMenuItem; },\n/* harmony export */   addTicketOrders: function() { return /* binding */ addTicketOrders; },\n/* harmony export */   bufferItemForTicket: function() { return /* binding */ bufferItemForTicket; },\n/* harmony export */   clearActiveTicket: function() { return /* binding */ clearActiveTicket; },\n/* harmony export */   clockInEmployee: function() { return /* binding */ clockInEmployee; },\n/* harmony export */   clockOutEmployee: function() { return /* binding */ clockOutEmployee; },\n/* harmony export */   createNewJob: function() { return /* binding */ createNewJob; },\n/* harmony export */   createNewRestaurant: function() { return /* binding */ createNewRestaurant; },\n/* harmony export */   createPOS: function() { return /* binding */ createPOS; },\n/* harmony export */   createTicketForPOS: function() { return /* binding */ createTicketForPOS; },\n/* harmony export */   decorateMyRestaurants: function() { return /* binding */ decorateMyRestaurants; },\n/* harmony export */   endService: function() { return /* binding */ endService; },\n/* harmony export */   fetchEmployeeStatusFromServer: function() { return /* binding */ fetchEmployeeStatusFromServer; },\n/* harmony export */   hireNewEmployee: function() { return /* binding */ hireNewEmployee; },\n/* harmony export */   loadAccount: function() { return /* binding */ loadAccount; },\n/* harmony export */   loadAllEmployees: function() { return /* binding */ loadAllEmployees; },\n/* harmony export */   loadAllJobs: function() { return /* binding */ loadAllJobs; },\n/* harmony export */   loadAllMenuItems: function() { return /* binding */ loadAllMenuItems; },\n/* harmony export */   loadAllPOS: function() { return /* binding */ loadAllPOS; },\n/* harmony export */   loadAllRestaurants: function() { return /* binding */ loadAllRestaurants; },\n/* harmony export */   loadAllServices: function() { return /* binding */ loadAllServices; },\n/* harmony export */   loadAllTicketsForPOS: function() { return /* binding */ loadAllTicketsForPOS; },\n/* harmony export */   loadDashboardRestaurantContractData: function() { return /* binding */ loadDashboardRestaurantContractData; },\n/* harmony export */   loadEmployeeRelevantPOS: function() { return /* binding */ loadEmployeeRelevantPOS; },\n/* harmony export */   loadFactory: function() { return /* binding */ loadFactory; },\n/* harmony export */   loadFullTicketDetails: function() { return /* binding */ loadFullTicketDetails; },\n/* harmony export */   loadMenuItemsForPOS: function() { return /* binding */ loadMenuItemsForPOS; },\n/* harmony export */   loadMyRestaurants: function() { return /* binding */ loadMyRestaurants; },\n/* harmony export */   loadNetwork: function() { return /* binding */ loadNetwork; },\n/* harmony export */   loadProvider: function() { return /* binding */ loadProvider; },\n/* harmony export */   ringBufferedItems: function() { return /* binding */ ringBufferedItems; },\n/* harmony export */   setActiveTicket: function() { return /* binding */ setActiveTicket; },\n/* harmony export */   startService: function() { return /* binding */ startService; },\n/* harmony export */   subscribeToEvents: function() { return /* binding */ subscribeToEvents; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abis/Restaurant.json */ \"./src/abis/Restaurant.json\");\n/* harmony import */ var _abis_decentratalityServiceFactory_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../abis/decentratalityServiceFactory.json */ \"./src/abis/decentratalityServiceFactory.json\");\n/* harmony import */ var _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abis/POS.json */ \"./src/abis/POS.json\");\n// src/store/interactions.js\n\n\n\n\n\nlet GlobalRestaurants = [];\nconst loadProvider = async (dispatch)=>{\n    const connection = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.BrowserProvider(window.ethereum);\n    dispatch({\n        type: \"PROVIDER_LOADED\",\n        connection\n    });\n    return connection;\n};\nconst loadAccount = async (provider1, dispatch)=>{\n    const accounts = await provider1.send(\"eth_requestAccounts\", []);\n    const account = ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.getAddress(accounts[0]);\n    dispatch({\n        type: \"ACCOUNT_LOADED\",\n        account\n    });\n    return account;\n};\nconst loadNetwork = async (provider1, dispatch)=>{\n    let { chainId } = await provider1.getNetwork();\n    chainId = Number(chainId);\n    dispatch({\n        type: \"NETWORK_LOADED\",\n        chainId\n    });\n    return chainId;\n};\nconst subscribeToEvents = async function(restaurantFactory, dispatch) {\n    for(var _len = arguments.length, Restaurants = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        Restaurants[_key - 2] = arguments[_key];\n    }\n    restaurantFactory.on(\"RestaurantCreated\", (restaurant1, id, owner, event)=>{\n        const _restaurant = event.args;\n        dispatch({\n            type: \"NEW_RESTAURANT_CREATION_SUCCESS\",\n            _restaurant,\n            event\n        });\n    });\n    for(restaurant in Restaurants){\n        restaurant.on(\"JobAdded\", (id, timestamp, job, event)=>{});\n    }\n};\nconst loadFactory = async (user, address, dispatch)=>{\n    const decentratalityServiceFactory = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(address, _abis_decentratalityServiceFactory_json__WEBPACK_IMPORTED_MODULE_1__.abi, user);\n    dispatch({\n        type: \"DECENTRATALITY_SERVICE_FACTORY_LOADED\",\n        decentratalityServiceFactory\n    });\n    return decentratalityServiceFactory;\n};\nconst loadAllRestaurants = async (user, factory, dispatch)=>{\n    try {\n        const Restaurants = [];\n        // Call the `getAllRestaurants` function from the factory contract\n        const restaurantAddresses = await factory.getAllRestaurants();\n        // Iterate through the returned restaurant addresses\n        for(let i = 0; i < restaurantAddresses.length; i++){\n            const restaurantAddress = restaurantAddresses[i];\n            // Create a new contract instance for the restaurant\n            const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurantAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n            // Fetch restaurant details\n            const name = await restaurantContract.name();\n            const owner = await restaurantContract.owner();\n            const balance = await provider.getBalance(restaurantAddress);\n            // Format the restaurant data\n            Restaurants.push({\n                id: i + 1,\n                address: restaurantAddress,\n                name,\n                owner,\n                balance: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(balance))\n            });\n        }\n        // Update global state or Redux store\n        dispatch({\n            type: \"ALL_RESTAURANTS_LOADED\",\n            Restaurants\n        });\n        return Restaurants;\n    } catch (error) {\n        console.error(\"Error loading all restaurants:\", error);\n        return [];\n    }\n};\nconst loadMyRestaurants = async (provider1, user, Restaurants, dispatch)=>{\n    const myRestaurants = Restaurants.filter((restaurant1)=>restaurant1.owner === user); // Assuming `owner` is the correct key\n    if (myRestaurants.length === 0) return;\n    dispatch({\n        type: \"MY_RESTAURANTS_LOADED\",\n        myRestaurants\n    });\n    return myRestaurants;\n};\nconst decorateMyRestaurants = async (user, myRestaurants)=>{\n    const decoratedRestaurants = [];\n    if (myRestaurants) {\n        for (const restaurant1 of myRestaurants){\n            try {\n                const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurant1.address, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n                const name = await contract.name; // Use the new getName() function\n                const myName = name.toString();\n                const cash = Number(await provider.getBalance(restaurant1.address));\n                decoratedRestaurants.push({\n                    ...restaurant1,\n                    myName,\n                    cash\n                });\n            } catch (error) {\n                console.error(\"Error decorating restaurant \".concat(restaurant1.address, \":\"), error);\n            }\n        }\n    }\n    return decoratedRestaurants;\n};\nconst createNewRestaurant = async (user, factory, restaurantName, totalCostWei, dispatch)=>{\n    try {\n        // Ensure totalCostWei is converted to an integer BigInt by truncating decimals\n        const totalCost = BigInt(Math.floor(Number(totalCostWei)));\n        // Check if the user has enough balance\n        const balance = await provider.getBalance(user.getAddress());\n        if (BigInt(balance) < totalCost) {\n            alert(\"Insufficient funds to create restaurant\");\n            return;\n        }\n        // Call the contract function with the converted total cost\n        const tx = await factory.createRestaurant(restaurantName, totalCost, {\n            value: totalCost\n        });\n        // Wait for the transaction to be mined\n        await tx.wait();\n        // Dispatch success action\n        dispatch({\n            type: \"RESTAURANT_CREATION_SUCCESS\",\n            restaurant: tx\n        });\n    } catch (error) {\n        console.error(\"Error creating restaurant:\", error);\n        dispatch({\n            type: \"RESTAURANT_CREATION_FAIL\",\n            error\n        });\n    }\n};\nconst loadDashboardRestaurantContractData = async (user, Restaurant, dispatch)=>{\n    const contractAddress = Restaurant.address;\n    const abi = _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__;\n    const contract = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n    const name = await contract.name();\n    const myCash = await provider.getBalance(contractAddress);\n    const cash = Number(myCash).toString();\n    dispatch({\n        type: \"DASHBOARD_RESTAURANT_LOADED\",\n        contractAddress,\n        abi,\n        name,\n        cash\n    });\n    return contract;\n};\n// interactions.js\nconst createNewJob = async (provider1, contractAddress, abi, name, wage, dispatch)=>{\n    const user = await provider1.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n    // Call the contract function to add a new job\n    const tx = await contract.addJob(wage, name);\n    // Wait for the transaction to be mined\n    await tx.wait();\n    // Reload all jobs\n    await loadAllJobs(provider1, contractAddress, abi, dispatch);\n};\nconst hireNewEmployee = async (user, contractAddress, abi, jobId, name, employeeAddress, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Call the contract function to hire a new employee\n        const tx = await contract.hireEmployee(jobId, name, employeeAddress);\n        // Wait for the transaction to be mined\n        await tx.wait();\n        // Reload all employees\n        await loadAllEmployees(provider, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error in hireNewEmployee:\", error);\n    }\n};\nconst loadAllEmployees = async (user, contractAddress, abi, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of employee IDs\n        const employeeIds = await contract.getEmployeeIds();\n        const employeesArray = [];\n        for(let i = 0; i < employeeIds.length; i++){\n            const employeeId = Number(employeeIds[i]); // Convert BigNumber to Number\n            const employee = await contract.employees(employeeId);\n            employeesArray.push({\n                id: employeeId.toString(),\n                jobId: employee.jobId.toString(),\n                name: employee.name,\n                address: employee.employeeAddress,\n                clockStamp: employee.clockStamp.toString(),\n                employeePension: employee.employeePension.toString()\n            });\n        }\n        // Dispatch action to update employees in Redux store\n        dispatch({\n            type: \"EMPLOYEES_LOADED\",\n            employees: employeesArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllEmployees:\", error);\n    }\n};\nconst loadAllJobs = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of job IDs\n        const jobIds = await contract.getJobIds();\n        const jobsArray = [];\n        for(let i = 0; i < jobIds.length; i++){\n            const jobId = Number(jobIds[i]); // Convert BigNumber to Number\n            const job = await contract.jobs(jobId);\n            jobsArray.push({\n                id: jobId.toString(),\n                hourlyWageInWei: job.hourlyWageInWei.toString(),\n                jobName: job.jobName\n            });\n        }\n        // Dispatch action to update jobs in Redux store\n        dispatch({\n            type: \"JOBS_LOADED\",\n            jobs: jobsArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllJobs:\", error.message);\n    }\n};\nconst startService = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        const tx = await contract.startService();\n        const receipt = await tx.wait();\n        // Get the block timestamp from the transaction receipt\n        const block = await provider1.getBlock(receipt.blockNumber);\n        const serviceStartTime = block.timestamp;\n        // Dispatch the service start time\n        dispatch({\n            type: \"SERVICE_STARTED\",\n            serviceStartTime\n        });\n    } catch (error) {\n        console.error(\"Error in startService:\", error);\n    }\n};\nconst loadAllServices = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of service IDs\n        const serviceIds = await contract.getServiceIds();\n        const servicesArray = [];\n        for(let i = 0; i < serviceIds.length; i++){\n            const serviceId = Number(serviceIds[i]);\n            const service = await contract.services(serviceId);\n            servicesArray.push({\n                id: serviceId.toString(),\n                startTime: service.startTime.toString(),\n                endTime: service.endTime.toString(),\n                cost: service.cost.toString(),\n                profit: service.profit.toString(),\n                revenue: service.revenue.toString()\n            });\n        }\n        // Dispatch action to update services in Redux store\n        dispatch({\n            type: \"SERVICES_LOADED\",\n            services: servicesArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllServices:\", error);\n    }\n};\nconst endService = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        const tx = await contract.endService();\n        await tx.wait();\n        // Optionally dispatch an action to update the service status in Redux\n        dispatch({\n            type: \"SERVICE_STOPPED\"\n        });\n    } catch (error) {\n        console.error(\"Error in endService:\", error);\n    }\n};\nconst createPOS = async (provider1, contractAddress, abi, name, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n        // Call the createPOS function on the contract\n        const tx = await contract.createPOS(name);\n        const receipt = await tx.wait();\n        // Extract the POSCreated event from the receipt\n        const event = receipt.logs.map((log)=>{\n            try {\n                return contract.interface.parseLog(log);\n            } catch (e) {\n                return null;\n            }\n        }).find((parsedLog)=>parsedLog && parsedLog.name === \"POSCreated\");\n        if (event) {\n            const posId = event.args.id.toString();\n            const posAddress = event.args.pos;\n        // Dispatch action to update Redux store\n        }\n        // Reload POS list\n        await loadAllPOS(provider1, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error in createPOS:\", error);\n    }\n};\nconst loadAllPOS = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        // Fetch the array of POS IDs\n        const posIds = await contract.getPOSIds();\n        const posArray = [];\n        for(let i = 0; i < posIds.length; i++){\n            const posId = Number(posIds[i]);\n            const posAddress = await contract.POSMapping(posId);\n            const posContract = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            const posName = await posContract.getName();\n            posArray.push({\n                id: posId.toString(),\n                address: posAddress,\n                name: posName.toString()\n            });\n        }\n        // Dispatch action to update POS in Redux store\n        dispatch({\n            type: \"POS_LOADED\",\n            posArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllPOS:\", error);\n    }\n};\nconst loadAllMenuItems = async (provider1, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider1.getSigner();\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n        // Get all POS addresses associated with the restaurant\n        const posAddresses = await restaurantContract.getAllPOSAddresses();\n        console.log(\"hello\");\n        if (posAddresses.length === 0) {\n            dispatch({\n                type: \"LOAD_ALL_MENU_ITEMS_SUCCESS\",\n                payload: []\n            });\n            return;\n        }\n        const firstPOSAddress = posAddresses[0];\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(firstPOSAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, provider1);\n        const menuItemIds = await posContract.getMenuItemIds();\n        let menuItems = [];\n        for(let i = 0; i < menuItemIds.length; i++){\n            const id = Number(menuItemIds[i]);\n            const menuItem = await posContract.menu(id);\n            menuItems.push({\n                id: id,\n                cost: ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(menuItem.cost),\n                name: menuItem.name\n            });\n        }\n        dispatch({\n            type: \"LOAD_ALL_MENU_ITEMS_SUCCESS\",\n            payload: menuItems\n        });\n    } catch (error) {\n        console.error(\"Error loading menu items:\", error);\n    }\n};\nconst addNewMenuItem = async (provider1, contractAddress, abi, cost, name, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        // Get all POS addresses from the restaurant contract\n        const posAddresses = await restaurantContract.getAllPOSAddresses();\n        // Loop through each POS address and add the menu item\n        for(let i = 0; i < posAddresses.length; i++){\n            const posAddress = posAddresses[i];\n            // Create a new contract instance for each POS\n            const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            // Call the addMenuItem function on each POS contract\n            const costInWei = ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.parseUnits(cost.toString(), \"ether\");\n            const tx = await posContract.addMenuItem(costInWei, name);\n            await tx.wait();\n        }\n        dispatch({\n            type: \"MENU_ITEM_ADDED\",\n            payload: {\n                cost,\n                name\n            }\n        });\n        await loadAllMenuItems(provider1, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error adding new menu item:\", error);\n    }\n};\n// In interactions.js (near loadAllPOS or after it):\nconst loadEmployeeRelevantPOS = async (provider1, restaurantAddress, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurantAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        const posIds = await restaurantContract.getPOSIds();\n        const posArray = [];\n        for(let i = 0; i < posIds.length; i++){\n            const posId = Number(posIds[i]);\n            const posAddress = await restaurantContract.POSMapping(posId);\n            const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            const posName = await posContract.getName();\n            posArray.push({\n                id: posId.toString(),\n                address: posAddress,\n                name: posName.toString()\n            });\n            console.log(\"1\");\n        }\n        console.log(posArray);\n        // Dispatch an action that specifically stores POS addresses relevant to the current employee's restaurant\n        dispatch({\n            type: \"RELEVANT_POS_LOADED_FOR_EMPLOYEE\",\n            payload: posArray\n        });\n        return posArray;\n    } catch (error) {\n        console.error(\"Error in loadEmployeeRelevantPOS:\", error);\n    }\n};\nconst createTicketForPOS = async (provider1, posAddress, posAbi, ticketName, serverAddress, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, posAbi, signer);\n        // The POS contract extends MenuTicketBase, which has createTicket(_server, _name)\n        const tx = await posContract.createTicket(serverAddress, ticketName);\n        await tx.wait();\n        // After creation, reload tickets so the UI remains up-to-date\n        await loadAllTicketsForPOS(provider1, posAddress, posAbi, dispatch);\n        dispatch({\n            type: \"CREATE_TICKET_SUCCESS\"\n        });\n    } catch (error) {\n        console.error(\"Error creating ticket:\", error);\n        dispatch({\n            type: \"CREATE_TICKET_FAIL\",\n            error\n        });\n    }\n};\n/**\r\n * Loads all tickets from a given POS contract.\r\n * @param provider Ethers provider/signer\r\n * @param posAddress The POS contract address\r\n * @param posAbi The ABI for the POS contract\r\n * @param dispatch Redux dispatch function\r\n */ const loadAllTicketsForPOS = async (provider1, posAddress, posAbi, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        // The POS contract (via MenuTicketBase) has an array TicketIds, so we read that\n        const ticketIds = await posContract.getTicketIds();\n        const ticketsArray = [];\n        for(let i = 0; i < ticketIds.length; i++){\n            const ticketIdBN = ticketIds[i]; // BigInt\n            const ticketId = Number(ticketIdBN);\n            const ticketStruct = await posContract.getTicket(ticketId);\n            // ticketStruct has { name, orders[], server, id, paid }\n            ticketsArray.push({\n                id: ticketStruct.id.toString(),\n                name: ticketStruct.name,\n                server: ticketStruct.server,\n                paid: ticketStruct.paid,\n                posAddress: posAddress // So we know which POS this ticket belongs to\n            });\n        }\n        // Dispatch to store in Redux. \n        // We can store them POS-by-POS or in a single array. \n        // Below, we just push them all into a single array in Redux:\n        dispatch({\n            type: \"TICKETS_LOADED\",\n            payload: {\n                posAddress,\n                tickets: ticketsArray\n            }\n        });\n    } catch (error) {\n        console.error(\"Error loading tickets for POS:\", error);\n        dispatch({\n            type: \"TICKETS_LOAD_FAIL\",\n            error\n        });\n    }\n};\nconst setActiveTicket = async (dispatch, ticket)=>{\n    dispatch({\n        type: \"ACTIVE_TICKET_SET\",\n        payload: ticket\n    });\n};\n/**\r\n * Clears the currently active ticket in Redux.\r\n * @param {Object} dispatch Redux dispatch\r\n */ const clearActiveTicket = async (dispatch)=>{\n    dispatch({\n        type: \"ACTIVE_TICKET_CLEAR\"\n    });\n};\n/**\r\n * Loads all menu items for a given POS contract address and returns them as an array.\r\n * Optionally, you could dispatch a Redux action to store them if desired.\r\n *\r\n * @param {*} provider Ethers provider/signer\r\n * @param {String} posAddress The address of the POS\r\n * @param {Array} posAbi The ABI for the POS contract\r\n * @param {Object} dispatch Redux dispatch\r\n * @returns {Array} An array of menu items [{ id, name, cost }, ...]\r\n */ const loadMenuItemsForPOS = async (provider1, posAddress, posAbi, dispatch)=>{\n    try {\n        // Optional: dispatch({ type: 'MENU_ITEMS_LOAD_REQUEST' });\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        const menuItemIds = await posContract.getMenuItemIds();\n        let menuItems = [];\n        for(let i = 0; i < menuItemIds.length; i++){\n            const id = Number(menuItemIds[i]);\n            const item = await posContract.menu(id);\n            // Convert cost from wei to Ether (or you can store raw wei).\n            menuItems.push({\n                id,\n                name: item.name,\n                cost: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(item.cost))\n            });\n        }\n        // Optional: dispatch({ type: 'MENU_ITEMS_FOR_POS_LOADED', payload: menuItems });\n        return menuItems;\n    } catch (error) {\n        console.error(\"Error loading menu for POS:\", error);\n        // Optional: dispatch({ type: 'MENU_ITEMS_LOAD_FAIL', error });\n        return [];\n    }\n};\nconst addTicketOrders = async (provider1, posAddress, posAbi, ticketId, items, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        const tx = await posContract.addTicketOrders(ticketId, items);\n        await tx.wait();\n        // Optionally reload the updated ticket...\n        // await loadAllTicketsForPOS(provider, posAddress, posAbi, dispatch);\n        dispatch({\n            type: \"ADD_TICKET_ORDERS_SUCCESS\"\n        });\n    } catch (error) {\n        console.error(\"Error adding orders:\", error);\n        dispatch({\n            type: \"ADD_TICKET_ORDERS_FAIL\",\n            error\n        });\n    }\n};\nconst loadFullTicketDetails = async (provider1, posAddress, posAbi, ticketId, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        // Grab the entire ticket struct from the contract\n        const ticketStruct = await posContract.getTicket(ticketId);\n        // ticketStruct -> { name, orders[], server, id, paid }\n        // Convert orders[] from contract (cost in wei) to a friendlier JS array\n        const orders = [];\n        for(let i = 0; i < ticketStruct.orders.length; i++){\n            const orderItem = ticketStruct.orders[i];\n            orders.push({\n                name: orderItem.name,\n                cost: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(orderItem.cost))\n            });\n        }\n        const fullTicket = {\n            id: Number(ticketStruct.id).toString(),\n            name: ticketStruct.name,\n            server: ticketStruct.server,\n            paid: ticketStruct.paid,\n            posAddress,\n            orders\n        };\n        // Dispatch so Redux knows about the fully detailed ticket\n        dispatch({\n            type: \"ACTIVE_TICKET_DETAILS_LOADED\",\n            payload: fullTicket\n        });\n    } catch (error) {\n        console.error(\"Error loading full ticket details:\", error);\n        dispatch({\n            type: \"ACTIVE_TICKET_DETAILS_FAIL\",\n            error\n        });\n    }\n};\nconst bufferItemForTicket = (ticketId, item)=>{\n    return (dispatch)=>{\n        dispatch({\n            type: \"ADD_ITEM_TO_PENDING_BUFFER\",\n            payload: {\n                ticketId,\n                item\n            }\n        });\n    };\n};\n// 2) A function that *rings* all buffered items for a given ticketId\n//    by calling `addTicketOrders` in the POS contract.\nconst ringBufferedItems = async (provider1, posAddress, pendingOrderBuffer, posAbi, ticketId, dispatch, getState)=>{\n    try {\n        const stringId = ticketId.toString();\n        // Get the entire pending buffer\n        const itemsToRing = pendingOrderBuffer[stringId] || [];\n        if (itemsToRing.length === 0) {\n            console.log(\"No items to ring for this ticket.\");\n            return;\n        }\n        // Format them for the contract\n        const rungItems = itemsToRing.map((item)=>({\n                cost: ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.parseUnits(item.cost.toString(), \"ether\"),\n                name: item.name\n            }));\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, posAbi, signer);\n        // Send transaction\n        console.log(\"fun\");\n        const tx = await posContract.addTicketOrders(ticketId, rungItems);\n        await tx.wait();\n        console.log(\"fun\");\n        // Now tell Redux we succeeded\n        dispatch({\n            type: \"ORDER_RING_SUCCESS\",\n            payload: {\n                ticketId: ticketId,\n                rungItems: itemsToRing\n            }\n        });\n        console.log(\"Successfully rang items for ticket: \".concat(stringId));\n    } catch (error) {\n        console.error(\"Error in ringBufferedItems:\", error);\n    }\n};\nconst clockInEmployee = async (provider1, contractAddress, abi, employeeId)=>{\n    const signer = await provider1.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n    const tx = await contract.clockIn(employeeId);\n    await tx.wait();\n};\nconst clockOutEmployee = async (provider1, contractAddress, abi, employeeId)=>{\n    const signer = await provider1.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n    const tx = await contract.clockOut(employeeId);\n    await tx.wait();\n};\n// In store/interactions.js\n// store/interactions.js\nconst fetchEmployeeStatusFromServer = (param)=>{\n    let { signer, contractAddress, abi, jobName } = param;\n    return async (dispatch, getState)=>{\n        try {\n            // 1) The public address of the user\n            const userAddress = await signer.getAddress();\n            // 2) Build the payload\n            const payload = {\n                contractAddress,\n                userAddress,\n                abi,\n                jobName\n            };\n            // 3) POST to your custom route\n            const response = await fetch(\"/api/employeeStatus\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(payload)\n            });\n            if (!response.ok) {\n                throw new Error(\"Server error: \".concat(response.statusText));\n            }\n            const data = await response.json();\n            // 4) Dispatch if you want to store in Redux\n            dispatch({\n                type: \"EMPLOYEE_STATUS_FROM_SERVER\",\n                payload: data\n            });\n        } catch (error) {\n            console.error(\"Error in fetchEmployeeStatusFromServer:\", error);\n            dispatch({\n                type: \"EMPLOYEE_STATUS_FROM_SERVER_ERROR\",\n                error\n            });\n        }\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cUMsT0FBcEJSLFNBQVNTLFVBQVU7WUFDdEQ7WUFFQSxNQUFNQyxPQUFPLE1BQU1WLFNBQVNXLElBQUk7WUFFaEMsNENBQTRDO1lBQzVDNU0sU0FBUztnQkFBRUssTUFBTTtnQkFBK0J3SSxTQUFTOEQ7WUFBSztRQUNoRSxFQUFFLE9BQU81SixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywyQ0FBMkNBO1lBQ3pEL0MsU0FBUztnQkFBRUssTUFBTTtnQkFBcUMwQztZQUFNO1FBQzlEO0lBQ0Y7RUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3RvcmUvaW50ZXJhY3Rpb25zLmpzPzAwYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3N0b3JlL2ludGVyYWN0aW9ucy5qc1xyXG5cclxuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJ1xyXG5pbXBvcnQgUkVTVEFVUkFOVF9BQkkgZnJvbSBcIi4uL2FiaXMvUmVzdGF1cmFudC5qc29uXCJcclxuaW1wb3J0IERFQ0VOVFJBVEFMSVRZU0VSVklDRUZBQ1RPUllfQUJJIGZyb20gXCIuLi9hYmlzL2RlY2VudHJhdGFsaXR5U2VydmljZUZhY3RvcnkuanNvblwiXHJcbmltcG9ydCBQT1NfQUJJIGZyb20gXCIuLi9hYmlzL1BPUy5qc29uXCI7XHJcbmltcG9ydCB7IHVzZVNlbGVjdG9yIH0gZnJvbSAncmVhY3QtcmVkdXgnXHJcblxyXG5sZXQgR2xvYmFsUmVzdGF1cmFudHMgPSBbXVxyXG5leHBvcnQgY29uc3QgbG9hZFByb3ZpZGVyID0gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XHJcblx0Y29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IG5ldyBldGhlcnMuQnJvd3NlclByb3ZpZGVyKHdpbmRvdy5ldGhlcmV1bSk7XHJcbiAgICBcclxuICAgIFxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnUFJPVklERVJfTE9BREVEJywgY29ubmVjdGlvbiB9KVxyXG5cclxuICAgIHJldHVybiBjb25uZWN0aW9uXHJcbn1cclxuZXhwb3J0IGNvbnN0IGxvYWRBY2NvdW50ID0gYXN5bmMgKHByb3ZpZGVyLCBkaXNwYXRjaCkgPT4ge1xyXG5cdGNvbnN0IGFjY291bnRzID0gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9yZXF1ZXN0QWNjb3VudHNcIiwgW10pO1xyXG5cdGNvbnN0IGFjY291bnQgPSBldGhlcnMuZ2V0QWRkcmVzcyhhY2NvdW50c1swXSk7IFxyXG5cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FDQ09VTlRfTE9BREVEJywgYWNjb3VudH0pXHJcblxyXG4gICAgcmV0dXJuIGFjY291bnRcclxufVxyXG5leHBvcnQgY29uc3QgbG9hZE5ldHdvcmsgPSBhc3luYyAocHJvdmlkZXIsIGRpc3BhdGNoKSA9PiB7XHJcbiAgICBsZXQgeyBjaGFpbklkIH0gPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKClcclxuICAgIGNoYWluSWQgPSBOdW1iZXIoY2hhaW5JZClcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ05FVFdPUktfTE9BREVEJywgY2hhaW5JZCB9KVxyXG5cclxuICAgIHJldHVybiBjaGFpbklkXHJcbn1cclxuZXhwb3J0IGNvbnN0IHN1YnNjcmliZVRvRXZlbnRzID0gYXN5bmMgKHJlc3RhdXJhbnRGYWN0b3J5LCBkaXNwYXRjaCwgLi4uUmVzdGF1cmFudHMpID0+IHtcclxuICAgICAgICByZXN0YXVyYW50RmFjdG9yeS5vbignUmVzdGF1cmFudENyZWF0ZWQnLCAocmVzdGF1cmFudCwgaWQsIG93bmVyLCBldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IF9yZXN0YXVyYW50ID0gZXZlbnQuYXJnc1xyXG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ05FV19SRVNUQVVSQU5UX0NSRUFUSU9OX1NVQ0NFU1MnLCBfcmVzdGF1cmFudCwgZXZlbnQgfSlcclxuICAgIH0pXHJcbiAgICAgICAgZm9yKHJlc3RhdXJhbnQgaW4gUmVzdGF1cmFudHMpIHtcclxuICAgICAgICAgICAgcmVzdGF1cmFudC5vbignSm9iQWRkZWQnLCAoaWQsIHRpbWVzdGFtcCwgam9iLCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgXHJcbn1cclxuZXhwb3J0IGNvbnN0IGxvYWRGYWN0b3J5ID0gYXN5bmMgKHVzZXIsIGFkZHJlc3MsIGRpc3BhdGNoKSA9PiB7XHJcbiAgICBcclxuICAgIGNvbnN0IGRlY2VudHJhdGFsaXR5U2VydmljZUZhY3RvcnkgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGFkZHJlc3MsIERFQ0VOVFJBVEFMSVRZU0VSVklDRUZBQ1RPUllfQUJJLmFiaSwgdXNlcik7XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdERUNFTlRSQVRBTElUWV9TRVJWSUNFX0ZBQ1RPUllfTE9BREVEJywgZGVjZW50cmF0YWxpdHlTZXJ2aWNlRmFjdG9yeSB9KVxyXG4gICAgcmV0dXJuIGRlY2VudHJhdGFsaXR5U2VydmljZUZhY3RvcnlcclxufVxyXG5leHBvcnQgY29uc3QgbG9hZEFsbFJlc3RhdXJhbnRzID0gYXN5bmMgKHVzZXIsIGZhY3RvcnksIGRpc3BhdGNoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IFJlc3RhdXJhbnRzID0gW107XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIC8vIENhbGwgdGhlIGBnZXRBbGxSZXN0YXVyYW50c2AgZnVuY3Rpb24gZnJvbSB0aGUgZmFjdG9yeSBjb250cmFjdFxyXG4gICAgICAgIGNvbnN0IHJlc3RhdXJhbnRBZGRyZXNzZXMgPSBhd2FpdCBmYWN0b3J5LmdldEFsbFJlc3RhdXJhbnRzKCk7XHJcblxyXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcmV0dXJuZWQgcmVzdGF1cmFudCBhZGRyZXNzZXNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3RhdXJhbnRBZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdGF1cmFudEFkZHJlc3MgPSByZXN0YXVyYW50QWRkcmVzc2VzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGluc3RhbmNlIGZvciB0aGUgcmVzdGF1cmFudFxyXG4gICAgICAgICAgICBjb25zdCByZXN0YXVyYW50Q29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KFxyXG4gICAgICAgICAgICAgICAgcmVzdGF1cmFudEFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICBSRVNUQVVSQU5UX0FCSSxcclxuICAgICAgICAgICAgICAgIHVzZXJcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZldGNoIHJlc3RhdXJhbnQgZGV0YWlsc1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0Lm5hbWUoKTtcclxuICAgICAgICAgICAgY29uc3Qgb3duZXIgPSBhd2FpdCByZXN0YXVyYW50Q29udHJhY3Qub3duZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UocmVzdGF1cmFudEFkZHJlc3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gRm9ybWF0IHRoZSByZXN0YXVyYW50IGRhdGFcclxuICAgICAgICAgICAgUmVzdGF1cmFudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpZDogaSArIDEsXHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXN0YXVyYW50QWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICBvd25lcixcclxuICAgICAgICAgICAgICAgIGJhbGFuY2U6IE51bWJlcihldGhlcnMuZm9ybWF0RXRoZXIoYmFsYW5jZSkpLCAvLyBDb252ZXJ0IGJhbGFuY2UgdG8gRXRoZXIgZm9yIGVhc2llciByZWFkYWJpbGl0eVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUgb3IgUmVkdXggc3RvcmVcclxuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6IFwiQUxMX1JFU1RBVVJBTlRTX0xPQURFRFwiLCBSZXN0YXVyYW50cyB9KTtcclxuICAgICAgICByZXR1cm4gUmVzdGF1cmFudHM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGFsbCByZXN0YXVyYW50czpcIiwgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRNeVJlc3RhdXJhbnRzID0gYXN5bmMgKHByb3ZpZGVyLCB1c2VyLCBSZXN0YXVyYW50cywgZGlzcGF0Y2gpID0+IHtcclxuICAgIGNvbnN0IG15UmVzdGF1cmFudHMgPSBSZXN0YXVyYW50cy5maWx0ZXIoKHJlc3RhdXJhbnQpID0+IHJlc3RhdXJhbnQub3duZXIgPT09IHVzZXIpOyAvLyBBc3N1bWluZyBgb3duZXJgIGlzIHRoZSBjb3JyZWN0IGtleVxyXG4gICAgaWYgKG15UmVzdGF1cmFudHMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnTVlfUkVTVEFVUkFOVFNfTE9BREVEJywgbXlSZXN0YXVyYW50cyB9KTtcclxuICAgIHJldHVybiBteVJlc3RhdXJhbnRzO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlY29yYXRlTXlSZXN0YXVyYW50cyA9IGFzeW5jICh1c2VyLCBteVJlc3RhdXJhbnRzKSA9PiB7XHJcbiAgICBcclxuICAgIGNvbnN0IGRlY29yYXRlZFJlc3RhdXJhbnRzID0gW107XHJcblxyXG4gICAgaWYgKG15UmVzdGF1cmFudHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlc3RhdXJhbnQgb2YgbXlSZXN0YXVyYW50cykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHJlc3RhdXJhbnQuYWRkcmVzcywgUkVTVEFVUkFOVF9BQkksIHVzZXIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGF3YWl0IGNvbnRyYWN0Lm5hbWU7IC8vIFVzZSB0aGUgbmV3IGdldE5hbWUoKSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbXlOYW1lID0gbmFtZS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXNoID0gTnVtYmVyKGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UocmVzdGF1cmFudC5hZGRyZXNzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVjb3JhdGVkUmVzdGF1cmFudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzdGF1cmFudCxcclxuICAgICAgICAgICAgICAgICAgICBteU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzaCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVjb3JhdGluZyByZXN0YXVyYW50ICR7cmVzdGF1cmFudC5hZGRyZXNzfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRlY29yYXRlZFJlc3RhdXJhbnRzO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZU5ld1Jlc3RhdXJhbnQgPSBhc3luYyAodXNlciwgZmFjdG9yeSwgcmVzdGF1cmFudE5hbWUsIHRvdGFsQ29zdFdlaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgXHJcblxyXG4gICAgLy8gRW5zdXJlIHRvdGFsQ29zdFdlaSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBCaWdJbnQgYnkgdHJ1bmNhdGluZyBkZWNpbWFsc1xyXG4gICAgY29uc3QgdG90YWxDb3N0ID0gQmlnSW50KE1hdGguZmxvb3IoTnVtYmVyKHRvdGFsQ29zdFdlaSkpKTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGUgdXNlciBoYXMgZW5vdWdoIGJhbGFuY2VcclxuICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKHVzZXIuZ2V0QWRkcmVzcygpKTtcclxuICAgIGlmIChCaWdJbnQoYmFsYW5jZSkgPCB0b3RhbENvc3QpIHtcclxuICAgICAgYWxlcnQoXCJJbnN1ZmZpY2llbnQgZnVuZHMgdG8gY3JlYXRlIHJlc3RhdXJhbnRcIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxsIHRoZSBjb250cmFjdCBmdW5jdGlvbiB3aXRoIHRoZSBjb252ZXJ0ZWQgdG90YWwgY29zdFxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBmYWN0b3J5LmNyZWF0ZVJlc3RhdXJhbnQocmVzdGF1cmFudE5hbWUsIHRvdGFsQ29zdCwge1xyXG4gICAgICB2YWx1ZTogdG90YWxDb3N0LCAvLyBBdHRhY2ggdGhlIGZ1bmRzIGluIFdlaVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkXHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggc3VjY2VzcyBhY3Rpb25cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogXCJSRVNUQVVSQU5UX0NSRUFUSU9OX1NVQ0NFU1NcIiwgcmVzdGF1cmFudDogdHggfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhdGluZyByZXN0YXVyYW50OlwiLCBlcnJvcik7XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6IFwiUkVTVEFVUkFOVF9DUkVBVElPTl9GQUlMXCIsIGVycm9yIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkRGFzaGJvYXJkUmVzdGF1cmFudENvbnRyYWN0RGF0YSA9IGFzeW5jICh1c2VyLCBSZXN0YXVyYW50LCBkaXNwYXRjaCkgPT4ge1xyXG4gICAgXHJcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBSZXN0YXVyYW50LmFkZHJlc3NcclxuICAgIGNvbnN0IGFiaSA9IFJFU1RBVVJBTlRfQUJJXHJcbiAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpXHJcbiAgICBjb25zdCBuYW1lID0gYXdhaXQgY29udHJhY3QubmFtZSgpXHJcbiAgICBjb25zdCBteUNhc2ggPSBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKGNvbnRyYWN0QWRkcmVzcylcclxuICAgIGNvbnN0IGNhc2ggPSBOdW1iZXIobXlDYXNoKS50b1N0cmluZygpXHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnREFTSEJPQVJEX1JFU1RBVVJBTlRfTE9BREVEJywgY29udHJhY3RBZGRyZXNzLCBhYmksIG5hbWUsIGNhc2ggfSlcclxuXHJcbiAgICByZXR1cm4gY29udHJhY3RcclxuICAgIFxyXG59XHJcbi8vIGludGVyYWN0aW9ucy5qc1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZU5ld0pvYiA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIG5hbWUsIHdhZ2UsIGRpc3BhdGNoKSA9PiB7XHJcbiAgY29uc3QgdXNlciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gIC8vIENhbGwgdGhlIGNvbnRyYWN0IGZ1bmN0aW9uIHRvIGFkZCBhIG5ldyBqb2JcclxuICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmFkZEpvYih3YWdlLCBuYW1lKTtcclxuXHJcbiAgLy8gV2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkXHJcbiAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAvLyBSZWxvYWQgYWxsIGpvYnNcclxuICBhd2FpdCBsb2FkQWxsSm9icyhwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKTtcclxufTtcclxuZXhwb3J0IGNvbnN0IGhpcmVOZXdFbXBsb3llZSA9IGFzeW5jICh1c2VyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgam9iSWQsIG5hbWUsIGVtcGxveWVlQWRkcmVzcywgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgXHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAgIC8vIENhbGwgdGhlIGNvbnRyYWN0IGZ1bmN0aW9uIHRvIGhpcmUgYSBuZXcgZW1wbG95ZWVcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuaGlyZUVtcGxveWVlKGpvYklkLCBuYW1lLCBlbXBsb3llZUFkZHJlc3MpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBtaW5lZFxyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIFJlbG9hZCBhbGwgZW1wbG95ZWVzXHJcbiAgICBhd2FpdCBsb2FkQWxsRW1wbG95ZWVzKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBoaXJlTmV3RW1wbG95ZWU6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkQWxsRW1wbG95ZWVzID0gYXN5bmMgKHVzZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIGVtcGxveWVlIElEc1xyXG4gICAgY29uc3QgZW1wbG95ZWVJZHMgPSBhd2FpdCBjb250cmFjdC5nZXRFbXBsb3llZUlkcygpO1xyXG5cclxuICAgIGNvbnN0IGVtcGxveWVlc0FycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVtcGxveWVlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVtcGxveWVlSWQgPSBOdW1iZXIoZW1wbG95ZWVJZHNbaV0pOyAvLyBDb252ZXJ0IEJpZ051bWJlciB0byBOdW1iZXJcclxuICAgICAgY29uc3QgZW1wbG95ZWUgPSBhd2FpdCBjb250cmFjdC5lbXBsb3llZXMoZW1wbG95ZWVJZCk7XHJcblxyXG4gICAgICBlbXBsb3llZXNBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogZW1wbG95ZWVJZC50b1N0cmluZygpLFxyXG4gICAgICAgIGpvYklkOiBlbXBsb3llZS5qb2JJZC50b1N0cmluZygpLFxyXG4gICAgICAgIG5hbWU6IGVtcGxveWVlLm5hbWUsXHJcbiAgICAgICAgYWRkcmVzczogZW1wbG95ZWUuZW1wbG95ZWVBZGRyZXNzLFxyXG4gICAgICAgIGNsb2NrU3RhbXA6IGVtcGxveWVlLmNsb2NrU3RhbXAudG9TdHJpbmcoKSxcclxuICAgICAgICBlbXBsb3llZVBlbnNpb246IGVtcGxveWVlLmVtcGxveWVlUGVuc2lvbi50b1N0cmluZygpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIGVtcGxveWVlcyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnRU1QTE9ZRUVTX0xPQURFRCcsIGVtcGxveWVlczogZW1wbG95ZWVzQXJyYXkgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWRBbGxFbXBsb3llZXM6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxKb2JzID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB1c2VyKTtcclxuXHJcbiAgICAvLyBGZXRjaCB0aGUgYXJyYXkgb2Ygam9iIElEc1xyXG4gICAgY29uc3Qgam9iSWRzID0gYXdhaXQgY29udHJhY3QuZ2V0Sm9iSWRzKCk7XHJcblxyXG4gICAgY29uc3Qgam9ic0FycmF5ID0gW107XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgam9iSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGpvYklkID0gTnVtYmVyKGpvYklkc1tpXSk7IC8vIENvbnZlcnQgQmlnTnVtYmVyIHRvIE51bWJlclxyXG4gICAgICBjb25zdCBqb2IgPSBhd2FpdCBjb250cmFjdC5qb2JzKGpvYklkKTtcclxuXHJcbiAgICAgIGpvYnNBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogam9iSWQudG9TdHJpbmcoKSxcclxuICAgICAgICBob3VybHlXYWdlSW5XZWk6IGpvYi5ob3VybHlXYWdlSW5XZWkudG9TdHJpbmcoKSxcclxuICAgICAgICBqb2JOYW1lOiBqb2Iuam9iTmFtZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggYWN0aW9uIHRvIHVwZGF0ZSBqb2JzIGluIFJlZHV4IHN0b3JlXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdKT0JTX0xPQURFRCcsIGpvYnM6IGpvYnNBcnJheSB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbG9hZEFsbEpvYnM6JywgZXJyb3IubWVzc2FnZSk7XHJcbiAgfVxyXG59O1xyXG5leHBvcnQgY29uc3Qgc3RhcnRTZXJ2aWNlID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB1c2VyKTtcclxuXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnN0YXJ0U2VydmljZSgpO1xyXG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGJsb2NrIHRpbWVzdGFtcCBmcm9tIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0XHJcbiAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrKHJlY2VpcHQuYmxvY2tOdW1iZXIpO1xyXG4gICAgY29uc3Qgc2VydmljZVN0YXJ0VGltZSA9IGJsb2NrLnRpbWVzdGFtcDtcclxuXHJcbiAgICAvLyBEaXNwYXRjaCB0aGUgc2VydmljZSBzdGFydCB0aW1lXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVJWSUNFX1NUQVJURUQnLCBzZXJ2aWNlU3RhcnRUaW1lIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzdGFydFNlcnZpY2U6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkQWxsU2VydmljZXMgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAgIC8vIEZldGNoIHRoZSBhcnJheSBvZiBzZXJ2aWNlIElEc1xyXG4gICAgY29uc3Qgc2VydmljZUlkcyA9IGF3YWl0IGNvbnRyYWN0LmdldFNlcnZpY2VJZHMoKTtcclxuXHJcbiAgICBjb25zdCBzZXJ2aWNlc0FycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcnZpY2VJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgc2VydmljZUlkID0gTnVtYmVyKHNlcnZpY2VJZHNbaV0pO1xyXG4gICAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgY29udHJhY3Quc2VydmljZXMoc2VydmljZUlkKTtcclxuXHJcbiAgICAgIHNlcnZpY2VzQXJyYXkucHVzaCh7XHJcbiAgICAgICAgaWQ6IHNlcnZpY2VJZC50b1N0cmluZygpLFxyXG4gICAgICAgIHN0YXJ0VGltZTogc2VydmljZS5zdGFydFRpbWUudG9TdHJpbmcoKSxcclxuICAgICAgICBlbmRUaW1lOiBzZXJ2aWNlLmVuZFRpbWUudG9TdHJpbmcoKSxcclxuICAgICAgICBjb3N0OiBzZXJ2aWNlLmNvc3QudG9TdHJpbmcoKSxcclxuICAgICAgICBwcm9maXQ6IHNlcnZpY2UucHJvZml0LnRvU3RyaW5nKCksXHJcbiAgICAgICAgcmV2ZW51ZTogc2VydmljZS5yZXZlbnVlLnRvU3RyaW5nKCksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BhdGNoIGFjdGlvbiB0byB1cGRhdGUgc2VydmljZXMgaW4gUmVkdXggc3RvcmVcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFUlZJQ0VTX0xPQURFRCcsIHNlcnZpY2VzOiBzZXJ2aWNlc0FycmF5IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBsb2FkQWxsU2VydmljZXM6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBlbmRTZXJ2aWNlID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB1c2VyKTtcclxuXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVuZFNlcnZpY2UoKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuXHJcbiAgICAvLyBPcHRpb25hbGx5IGRpc3BhdGNoIGFuIGFjdGlvbiB0byB1cGRhdGUgdGhlIHNlcnZpY2Ugc3RhdHVzIGluIFJlZHV4XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVJWSUNFX1NUT1BQRUQnIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlbmRTZXJ2aWNlOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlUE9TID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgbmFtZSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHNpZ25lcik7XHJcblxyXG4gICAgLy8gQ2FsbCB0aGUgY3JlYXRlUE9TIGZ1bmN0aW9uIG9uIHRoZSBjb250cmFjdFxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5jcmVhdGVQT1MobmFtZSk7XHJcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgdGhlIFBPU0NyZWF0ZWQgZXZlbnQgZnJvbSB0aGUgcmVjZWlwdFxyXG4gICAgY29uc3QgZXZlbnQgPSByZWNlaXB0LmxvZ3NcclxuICAgICAgLm1hcCgobG9nKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2cobG9nKTtcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLmZpbmQoKHBhcnNlZExvZykgPT4gcGFyc2VkTG9nICYmIHBhcnNlZExvZy5uYW1lID09PSAnUE9TQ3JlYXRlZCcpO1xyXG5cclxuICAgIGlmIChldmVudCkge1xyXG4gICAgICBjb25zdCBwb3NJZCA9IGV2ZW50LmFyZ3MuaWQudG9TdHJpbmcoKTtcclxuICAgICAgY29uc3QgcG9zQWRkcmVzcyA9IGV2ZW50LmFyZ3MucG9zO1xyXG5cclxuICAgICAgLy8gRGlzcGF0Y2ggYWN0aW9uIHRvIHVwZGF0ZSBSZWR1eCBzdG9yZVxyXG4gICAgICBcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWxvYWQgUE9TIGxpc3RcclxuICAgIGF3YWl0IGxvYWRBbGxQT1MocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNyZWF0ZVBPUzonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxQT1MgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIFJFU1RBVVJBTlRfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgIC8vIEZldGNoIHRoZSBhcnJheSBvZiBQT1MgSURzXHJcbiAgICBjb25zdCBwb3NJZHMgPSBhd2FpdCBjb250cmFjdC5nZXRQT1NJZHMoKTtcclxuXHJcbiAgICBjb25zdCBwb3NBcnJheSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgcG9zSWQgPSBOdW1iZXIocG9zSWRzW2ldKTtcclxuICAgICAgY29uc3QgcG9zQWRkcmVzcyA9IGF3YWl0IGNvbnRyYWN0LlBPU01hcHBpbmcocG9zSWQpO1xyXG4gICAgICBjb25zdCBwb3NDb250cmFjdCA9IGF3YWl0IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKVxyXG4gICAgICBjb25zdCBwb3NOYW1lID0gYXdhaXQgcG9zQ29udHJhY3QuZ2V0TmFtZSgpXHJcbiAgICAgIFxyXG5cclxuICAgICAgcG9zQXJyYXkucHVzaCh7XHJcbiAgICAgICAgaWQ6IHBvc0lkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgYWRkcmVzczogcG9zQWRkcmVzcyxcclxuICAgICAgICBuYW1lOiBwb3NOYW1lLnRvU3RyaW5nKClcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggYWN0aW9uIHRvIHVwZGF0ZSBQT1MgaW4gUmVkdXggc3RvcmVcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1BPU19MT0FERUQnLCBwb3NBcnJheSB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbG9hZEFsbFBPUzonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG4gIGV4cG9ydCBjb25zdCBsb2FkQWxsTWVudUl0ZW1zID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpXHJcbiAgICBjb25zdCByZXN0YXVyYW50Q29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgUkVTVEFVUkFOVF9BQkksIHVzZXIpO1xyXG5cclxuICAgIC8vIEdldCBhbGwgUE9TIGFkZHJlc3NlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3RhdXJhbnRcclxuICAgIGNvbnN0IHBvc0FkZHJlc3NlcyA9IGF3YWl0IHJlc3RhdXJhbnRDb250cmFjdC5nZXRBbGxQT1NBZGRyZXNzZXMoKTtcclxuICAgIGNvbnNvbGUubG9nKCdoZWxsbycpXHJcbiAgICBpZiAocG9zQWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBkaXNwYXRjaCh7IHR5cGU6ICdMT0FEX0FMTF9NRU5VX0lURU1TX1NVQ0NFU1MnLCBwYXlsb2FkOiBbXSB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZpcnN0UE9TQWRkcmVzcyA9IHBvc0FkZHJlc3Nlc1swXTtcclxuXHJcbiAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoZmlyc3RQT1NBZGRyZXNzLCBQT1NfQUJJLCBwcm92aWRlcik7XHJcblxyXG4gICAgY29uc3QgbWVudUl0ZW1JZHMgPSBhd2FpdCBwb3NDb250cmFjdC5nZXRNZW51SXRlbUlkcygpO1xyXG4gICAgbGV0IG1lbnVJdGVtcyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVudUl0ZW1JZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgaWQgPSBOdW1iZXIobWVudUl0ZW1JZHNbaV0pO1xyXG4gICAgICBjb25zdCBtZW51SXRlbSA9IGF3YWl0IHBvc0NvbnRyYWN0Lm1lbnUoaWQpO1xyXG5cclxuICAgICAgbWVudUl0ZW1zLnB1c2goe1xyXG4gICAgICAgIGlkOiBpZCxcclxuICAgICAgICBjb3N0OiBldGhlcnMuZm9ybWF0RXRoZXIobWVudUl0ZW0uY29zdCksXHJcbiAgICAgICAgbmFtZTogbWVudUl0ZW0ubmFtZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnTE9BRF9BTExfTUVOVV9JVEVNU19TVUNDRVNTJywgcGF5bG9hZDogbWVudUl0ZW1zIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIG1lbnUgaXRlbXM6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5leHBvcnQgY29uc3QgYWRkTmV3TWVudUl0ZW0gPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBjb3N0LCBuYW1lLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IHJlc3RhdXJhbnRDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBSRVNUQVVSQU5UX0FCSSwgc2lnbmVyKTtcclxuXHJcbiAgICAvLyBHZXQgYWxsIFBPUyBhZGRyZXNzZXMgZnJvbSB0aGUgcmVzdGF1cmFudCBjb250cmFjdFxyXG4gICAgY29uc3QgcG9zQWRkcmVzc2VzID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0LmdldEFsbFBPU0FkZHJlc3NlcygpO1xyXG5cclxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIFBPUyBhZGRyZXNzIGFuZCBhZGQgdGhlIG1lbnUgaXRlbVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NBZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgcG9zQWRkcmVzcyA9IHBvc0FkZHJlc3Nlc1tpXTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnN0YW5jZSBmb3IgZWFjaCBQT1NcclxuICAgICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIFBPU19BQkksIHNpZ25lcik7XHJcblxyXG4gICAgICAvLyBDYWxsIHRoZSBhZGRNZW51SXRlbSBmdW5jdGlvbiBvbiBlYWNoIFBPUyBjb250cmFjdFxyXG4gICAgICBjb25zdCBjb3N0SW5XZWkgPSBldGhlcnMucGFyc2VVbml0cyhjb3N0LnRvU3RyaW5nKCksICdldGhlcicpO1xyXG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHBvc0NvbnRyYWN0LmFkZE1lbnVJdGVtKGNvc3RJbldlaSwgbmFtZSk7XHJcbiAgICAgIGF3YWl0IHR4LndhaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdNRU5VX0lURU1fQURERUQnLCBwYXlsb2FkOiB7IGNvc3QsIG5hbWUgfSB9KTtcclxuXHJcbiAgICBhd2FpdCBsb2FkQWxsTWVudUl0ZW1zKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgbmV3IG1lbnUgaXRlbTonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gSW4gaW50ZXJhY3Rpb25zLmpzIChuZWFyIGxvYWRBbGxQT1Mgb3IgYWZ0ZXIgaXQpOlxyXG5leHBvcnQgY29uc3QgbG9hZEVtcGxveWVlUmVsZXZhbnRQT1MgPSBhc3luYyAocHJvdmlkZXIsIHJlc3RhdXJhbnRBZGRyZXNzLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IHJlc3RhdXJhbnRDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocmVzdGF1cmFudEFkZHJlc3MsIFJFU1RBVVJBTlRfQUJJLCBzaWduZXIpO1xyXG4gICAgY29uc3QgcG9zSWRzID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0LmdldFBPU0lkcygpO1xyXG4gICAgXHJcbiAgICBjb25zdCBwb3NBcnJheSA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHBvc0lkID0gTnVtYmVyKHBvc0lkc1tpXSk7XHJcbiAgICAgIGNvbnN0IHBvc0FkZHJlc3MgPSBhd2FpdCByZXN0YXVyYW50Q29udHJhY3QuUE9TTWFwcGluZyhwb3NJZCk7XHJcbiAgICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBQT1NfQUJJLCBzaWduZXIpO1xyXG4gICAgICBjb25zdCBwb3NOYW1lID0gYXdhaXQgcG9zQ29udHJhY3QuZ2V0TmFtZSgpO1xyXG4gICAgICBwb3NBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogcG9zSWQudG9TdHJpbmcoKSxcclxuICAgICAgICBhZGRyZXNzOiBwb3NBZGRyZXNzLFxyXG4gICAgICAgIG5hbWU6IHBvc05hbWUudG9TdHJpbmcoKVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc29sZS5sb2coJzEnKVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2cocG9zQXJyYXkpXHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggYW4gYWN0aW9uIHRoYXQgc3BlY2lmaWNhbGx5IHN0b3JlcyBQT1MgYWRkcmVzc2VzIHJlbGV2YW50IHRvIHRoZSBjdXJyZW50IGVtcGxveWVlJ3MgcmVzdGF1cmFudFxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnUkVMRVZBTlRfUE9TX0xPQURFRF9GT1JfRU1QTE9ZRUUnLCBwYXlsb2FkOiBwb3NBcnJheSB9KTtcclxuICAgIHJldHVybiBwb3NBcnJheTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbG9hZEVtcGxveWVlUmVsZXZhbnRQT1M6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlVGlja2V0Rm9yUE9TID0gYXN5bmMgKFxyXG4gIHByb3ZpZGVyLFxyXG4gIHBvc0FkZHJlc3MsXHJcbiAgcG9zQWJpLFxyXG4gIHRpY2tldE5hbWUsXHJcbiAgc2VydmVyQWRkcmVzcyxcclxuICBkaXNwYXRjaFxyXG4pID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgcG9zQWJpLCBzaWduZXIpO1xyXG5cclxuICAgIC8vIFRoZSBQT1MgY29udHJhY3QgZXh0ZW5kcyBNZW51VGlja2V0QmFzZSwgd2hpY2ggaGFzIGNyZWF0ZVRpY2tldChfc2VydmVyLCBfbmFtZSlcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9zQ29udHJhY3QuY3JlYXRlVGlja2V0KHNlcnZlckFkZHJlc3MsIHRpY2tldE5hbWUpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIEFmdGVyIGNyZWF0aW9uLCByZWxvYWQgdGlja2V0cyBzbyB0aGUgVUkgcmVtYWlucyB1cC10by1kYXRlXHJcbiAgICBhd2FpdCBsb2FkQWxsVGlja2V0c0ZvclBPUyhwcm92aWRlciwgcG9zQWRkcmVzcywgcG9zQWJpLCBkaXNwYXRjaCk7XHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQ1JFQVRFX1RJQ0tFVF9TVUNDRVNTJyB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGlja2V0OicsIGVycm9yKTtcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0NSRUFURV9USUNLRVRfRkFJTCcsIGVycm9yIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhbGwgdGlja2V0cyBmcm9tIGEgZ2l2ZW4gUE9TIGNvbnRyYWN0LlxyXG4gKiBAcGFyYW0gcHJvdmlkZXIgRXRoZXJzIHByb3ZpZGVyL3NpZ25lclxyXG4gKiBAcGFyYW0gcG9zQWRkcmVzcyBUaGUgUE9TIGNvbnRyYWN0IGFkZHJlc3NcclxuICogQHBhcmFtIHBvc0FiaSBUaGUgQUJJIGZvciB0aGUgUE9TIGNvbnRyYWN0XHJcbiAqIEBwYXJhbSBkaXNwYXRjaCBSZWR1eCBkaXNwYXRjaCBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxUaWNrZXRzRm9yUE9TID0gYXN5bmMgKHByb3ZpZGVyLCBwb3NBZGRyZXNzLCBwb3NBYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIFBPU19BQkksIHNpZ25lcik7XHJcbiAgICAvLyBUaGUgUE9TIGNvbnRyYWN0ICh2aWEgTWVudVRpY2tldEJhc2UpIGhhcyBhbiBhcnJheSBUaWNrZXRJZHMsIHNvIHdlIHJlYWQgdGhhdFxyXG4gICAgY29uc3QgdGlja2V0SWRzID0gYXdhaXQgcG9zQ29udHJhY3QuZ2V0VGlja2V0SWRzKCk7XHJcbiAgICBjb25zdCB0aWNrZXRzQXJyYXkgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tldElkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCB0aWNrZXRJZEJOID0gdGlja2V0SWRzW2ldOyAgLy8gQmlnSW50XHJcbiAgICAgIGNvbnN0IHRpY2tldElkID0gTnVtYmVyKHRpY2tldElkQk4pO1xyXG4gICAgICBjb25zdCB0aWNrZXRTdHJ1Y3QgPSBhd2FpdCBwb3NDb250cmFjdC5nZXRUaWNrZXQodGlja2V0SWQpOyBcclxuICAgICAgLy8gdGlja2V0U3RydWN0IGhhcyB7IG5hbWUsIG9yZGVyc1tdLCBzZXJ2ZXIsIGlkLCBwYWlkIH1cclxuXHJcbiAgICAgIHRpY2tldHNBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogdGlja2V0U3RydWN0LmlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgbmFtZTogdGlja2V0U3RydWN0Lm5hbWUsXHJcbiAgICAgICAgc2VydmVyOiB0aWNrZXRTdHJ1Y3Quc2VydmVyLFxyXG4gICAgICAgIHBhaWQ6IHRpY2tldFN0cnVjdC5wYWlkLFxyXG4gICAgICAgIHBvc0FkZHJlc3M6IHBvc0FkZHJlc3MgLy8gU28gd2Uga25vdyB3aGljaCBQT1MgdGhpcyB0aWNrZXQgYmVsb25ncyB0b1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCB0byBzdG9yZSBpbiBSZWR1eC4gXHJcbiAgICAvLyBXZSBjYW4gc3RvcmUgdGhlbSBQT1MtYnktUE9TIG9yIGluIGEgc2luZ2xlIGFycmF5LiBcclxuICAgIC8vIEJlbG93LCB3ZSBqdXN0IHB1c2ggdGhlbSBhbGwgaW50byBhIHNpbmdsZSBhcnJheSBpbiBSZWR1eDpcclxuICAgIGRpc3BhdGNoKHsgXHJcbiAgICAgIHR5cGU6ICdUSUNLRVRTX0xPQURFRCcsIFxyXG4gICAgICBwYXlsb2FkOiB7IHBvc0FkZHJlc3MsIHRpY2tldHM6IHRpY2tldHNBcnJheSB9IFxyXG4gICAgfSk7XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHRpY2tldHMgZm9yIFBPUzonLCBlcnJvcik7XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdUSUNLRVRTX0xPQURfRkFJTCcsIGVycm9yIH0pO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5leHBvcnQgY29uc3Qgc2V0QWN0aXZlVGlja2V0ID0gYXN5bmMgKGRpc3BhdGNoLCB0aWNrZXQpID0+IHtcclxuICBkaXNwYXRjaCh7IHR5cGU6ICdBQ1RJVkVfVElDS0VUX1NFVCcsIHBheWxvYWQ6IHRpY2tldCB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGVhcnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGlja2V0IGluIFJlZHV4LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGlzcGF0Y2ggUmVkdXggZGlzcGF0Y2hcclxuICovXHJcbmV4cG9ydCBjb25zdCBjbGVhckFjdGl2ZVRpY2tldCA9IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gIGRpc3BhdGNoKHsgdHlwZTogJ0FDVElWRV9USUNLRVRfQ0xFQVInIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvYWRzIGFsbCBtZW51IGl0ZW1zIGZvciBhIGdpdmVuIFBPUyBjb250cmFjdCBhZGRyZXNzIGFuZCByZXR1cm5zIHRoZW0gYXMgYW4gYXJyYXkuXHJcbiAqIE9wdGlvbmFsbHksIHlvdSBjb3VsZCBkaXNwYXRjaCBhIFJlZHV4IGFjdGlvbiB0byBzdG9yZSB0aGVtIGlmIGRlc2lyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcHJvdmlkZXIgRXRoZXJzIHByb3ZpZGVyL3NpZ25lclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zQWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGUgUE9TXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBvc0FiaSBUaGUgQUJJIGZvciB0aGUgUE9TIGNvbnRyYWN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkaXNwYXRjaCBSZWR1eCBkaXNwYXRjaFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIG1lbnUgaXRlbXMgW3sgaWQsIG5hbWUsIGNvc3QgfSwgLi4uXVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxvYWRNZW51SXRlbXNGb3JQT1MgPSBhc3luYyAocHJvdmlkZXIsIHBvc0FkZHJlc3MsIHBvc0FiaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gT3B0aW9uYWw6IGRpc3BhdGNoKHsgdHlwZTogJ01FTlVfSVRFTVNfTE9BRF9SRVFVRVNUJyB9KTtcclxuXHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBQT1NfQUJJLCBzaWduZXIpO1xyXG4gICAgY29uc3QgbWVudUl0ZW1JZHMgPSBhd2FpdCBwb3NDb250cmFjdC5nZXRNZW51SXRlbUlkcygpO1xyXG4gICAgXHJcblxyXG4gICAgbGV0IG1lbnVJdGVtcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZW51SXRlbUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBpZCA9IE51bWJlcihtZW51SXRlbUlkc1tpXSk7XHJcbiAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBwb3NDb250cmFjdC5tZW51KGlkKTtcclxuICAgICAgLy8gQ29udmVydCBjb3N0IGZyb20gd2VpIHRvIEV0aGVyIChvciB5b3UgY2FuIHN0b3JlIHJhdyB3ZWkpLlxyXG4gICAgICBtZW51SXRlbXMucHVzaCh7XHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxyXG4gICAgICAgIGNvc3Q6IE51bWJlcihldGhlcnMuZm9ybWF0RXRoZXIoaXRlbS5jb3N0KSksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9wdGlvbmFsOiBkaXNwYXRjaCh7IHR5cGU6ICdNRU5VX0lURU1TX0ZPUl9QT1NfTE9BREVEJywgcGF5bG9hZDogbWVudUl0ZW1zIH0pO1xyXG5cclxuICAgIHJldHVybiBtZW51SXRlbXM7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbWVudSBmb3IgUE9TOicsIGVycm9yKTtcclxuICAgIC8vIE9wdGlvbmFsOiBkaXNwYXRjaCh7IHR5cGU6ICdNRU5VX0lURU1TX0xPQURfRkFJTCcsIGVycm9yIH0pO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5leHBvcnQgY29uc3QgYWRkVGlja2V0T3JkZXJzID0gYXN5bmMgKFxyXG4gIHByb3ZpZGVyLFxyXG4gIHBvc0FkZHJlc3MsXHJcbiAgcG9zQWJpLFxyXG4gIHRpY2tldElkLFxyXG4gIGl0ZW1zLCAvLyBhcnJheSBvZiB7IGNvc3QsIG5hbWUgfSB0byBiZSBhcHBlbmRlZFxyXG4gIGRpc3BhdGNoXHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBQT1NfQUJJLCBzaWduZXIpO1xyXG4gICAgY29uc3QgdHggPSBhd2FpdCBwb3NDb250cmFjdC5hZGRUaWNrZXRPcmRlcnModGlja2V0SWQsIGl0ZW1zKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuXHJcbiAgICAvLyBPcHRpb25hbGx5IHJlbG9hZCB0aGUgdXBkYXRlZCB0aWNrZXQuLi5cclxuICAgIC8vIGF3YWl0IGxvYWRBbGxUaWNrZXRzRm9yUE9TKHByb3ZpZGVyLCBwb3NBZGRyZXNzLCBwb3NBYmksIGRpc3BhdGNoKTtcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdBRERfVElDS0VUX09SREVSU19TVUNDRVNTJyB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIG9yZGVyczonLCBlcnJvcik7XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdBRERfVElDS0VUX09SREVSU19GQUlMJywgZXJyb3IgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRGdWxsVGlja2V0RGV0YWlscyA9IGFzeW5jIChcclxuICBwcm92aWRlcixcclxuICBwb3NBZGRyZXNzLFxyXG4gIHBvc0FiaSxcclxuICB0aWNrZXRJZCxcclxuICBkaXNwYXRjaFxyXG4pID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKTtcclxuXHJcbiAgICAvLyBHcmFiIHRoZSBlbnRpcmUgdGlja2V0IHN0cnVjdCBmcm9tIHRoZSBjb250cmFjdFxyXG4gICAgY29uc3QgdGlja2V0U3RydWN0ID0gYXdhaXQgcG9zQ29udHJhY3QuZ2V0VGlja2V0KHRpY2tldElkKTtcclxuICAgIC8vIHRpY2tldFN0cnVjdCAtPiB7IG5hbWUsIG9yZGVyc1tdLCBzZXJ2ZXIsIGlkLCBwYWlkIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IG9yZGVyc1tdIGZyb20gY29udHJhY3QgKGNvc3QgaW4gd2VpKSB0byBhIGZyaWVuZGxpZXIgSlMgYXJyYXlcclxuICAgIGNvbnN0IG9yZGVycyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrZXRTdHJ1Y3Qub3JkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IG9yZGVySXRlbSA9IHRpY2tldFN0cnVjdC5vcmRlcnNbaV07XHJcbiAgICAgIG9yZGVycy5wdXNoKHtcclxuICAgICAgICBuYW1lOiBvcmRlckl0ZW0ubmFtZSxcclxuICAgICAgICBjb3N0OiBOdW1iZXIoZXRoZXJzLmZvcm1hdEV0aGVyKG9yZGVySXRlbS5jb3N0KSksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZ1bGxUaWNrZXQgPSB7XHJcbiAgICAgIGlkOiBOdW1iZXIodGlja2V0U3RydWN0LmlkKS50b1N0cmluZygpLFxyXG4gICAgICBuYW1lOiB0aWNrZXRTdHJ1Y3QubmFtZSxcclxuICAgICAgc2VydmVyOiB0aWNrZXRTdHJ1Y3Quc2VydmVyLFxyXG4gICAgICBwYWlkOiB0aWNrZXRTdHJ1Y3QucGFpZCxcclxuICAgICAgcG9zQWRkcmVzcyxcclxuICAgICAgb3JkZXJzXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIERpc3BhdGNoIHNvIFJlZHV4IGtub3dzIGFib3V0IHRoZSBmdWxseSBkZXRhaWxlZCB0aWNrZXRcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FDVElWRV9USUNLRVRfREVUQUlMU19MT0FERUQnLCBwYXlsb2FkOiBmdWxsVGlja2V0IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGZ1bGwgdGlja2V0IGRldGFpbHM6JywgZXJyb3IpO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQUNUSVZFX1RJQ0tFVF9ERVRBSUxTX0ZBSUwnLCBlcnJvciB9KTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYnVmZmVySXRlbUZvclRpY2tldCA9ICh0aWNrZXRJZCwgaXRlbSkgPT4ge1xyXG4gIHJldHVybiAoZGlzcGF0Y2gpID0+IHtcclxuICAgIGRpc3BhdGNoKHtcclxuICAgICAgdHlwZTogJ0FERF9JVEVNX1RPX1BFTkRJTkdfQlVGRkVSJyxcclxuICAgICAgcGF5bG9hZDogeyB0aWNrZXRJZCwgaXRlbSB9XHJcbiAgICB9KTtcclxuICB9O1xyXG59O1xyXG5cclxuLy8gMikgQSBmdW5jdGlvbiB0aGF0ICpyaW5ncyogYWxsIGJ1ZmZlcmVkIGl0ZW1zIGZvciBhIGdpdmVuIHRpY2tldElkXHJcbi8vICAgIGJ5IGNhbGxpbmcgYGFkZFRpY2tldE9yZGVyc2AgaW4gdGhlIFBPUyBjb250cmFjdC5cclxuXHJcbmV4cG9ydCBjb25zdCByaW5nQnVmZmVyZWRJdGVtcyA9IGFzeW5jIChcclxuICBwcm92aWRlcixcclxuICBwb3NBZGRyZXNzLFxyXG4gIHBlbmRpbmdPcmRlckJ1ZmZlcixcclxuICBwb3NBYmksXHJcbiAgdGlja2V0SWQsICAgICAgIC8vIGNvdWxkIGJlIGEgbnVtYmVyIG9yIHN0cmluZ1xyXG4gIGRpc3BhdGNoLFxyXG4gIGdldFN0YXRlXHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzdHJpbmdJZCA9IHRpY2tldElkLnRvU3RyaW5nKClcclxuXHJcbiAgICAvLyBHZXQgdGhlIGVudGlyZSBwZW5kaW5nIGJ1ZmZlclxyXG4gICBcclxuICAgIGNvbnN0IGl0ZW1zVG9SaW5nID0gcGVuZGluZ09yZGVyQnVmZmVyW3N0cmluZ0lkXSB8fCBbXVxyXG5cclxuICAgIGlmIChpdGVtc1RvUmluZy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS5sb2coJ05vIGl0ZW1zIHRvIHJpbmcgZm9yIHRoaXMgdGlja2V0LicpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZvcm1hdCB0aGVtIGZvciB0aGUgY29udHJhY3RcclxuICAgIGNvbnN0IHJ1bmdJdGVtcyA9IGl0ZW1zVG9SaW5nLm1hcCgoaXRlbSkgPT4gKHtcclxuICAgICAgY29zdDogZXRoZXJzLnBhcnNlVW5pdHMoaXRlbS5jb3N0LnRvU3RyaW5nKCksICdldGhlcicpLFxyXG4gICAgICBuYW1lOiBpdGVtLm5hbWVcclxuICAgIH0pKVxyXG5cclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpXHJcbiAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgcG9zQWJpLCBzaWduZXIpXHJcblxyXG4gICAgLy8gU2VuZCB0cmFuc2FjdGlvblxyXG4gICAgY29uc29sZS5sb2coJ2Z1bicpXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IHBvc0NvbnRyYWN0LmFkZFRpY2tldE9yZGVycyh0aWNrZXRJZCwgcnVuZ0l0ZW1zKVxyXG4gICAgYXdhaXQgdHgud2FpdCgpXHJcbiAgICBjb25zb2xlLmxvZygnZnVuJylcclxuXHJcbiAgICAvLyBOb3cgdGVsbCBSZWR1eCB3ZSBzdWNjZWVkZWRcclxuICAgIGRpc3BhdGNoKHtcclxuICAgICAgdHlwZTogJ09SREVSX1JJTkdfU1VDQ0VTUycsXHJcbiAgICAgIHBheWxvYWQ6IHsgXHJcbiAgICAgICAgdGlja2V0SWQ6IHRpY2tldElkLCAgLy8gcGFzcyBhIHN0cmluZ1xyXG4gICAgICAgIHJ1bmdJdGVtczogaXRlbXNUb1JpbmdcclxuICAgICAgfVxyXG5cclxuICAgIH0pXHJcbiAgICAgIFxyXG4gICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByYW5nIGl0ZW1zIGZvciB0aWNrZXQ6ICR7c3RyaW5nSWR9YClcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcmluZ0J1ZmZlcmVkSXRlbXM6JywgZXJyb3IpXHJcbiAgfVxyXG59XHJcbmV4cG9ydCBjb25zdCBjbG9ja0luRW1wbG95ZWUgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBlbXBsb3llZUlkKSA9PiB7XHJcbiAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCBzaWduZXIpO1xyXG4gIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuY2xvY2tJbihlbXBsb3llZUlkKTtcclxuICBhd2FpdCB0eC53YWl0KCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY2xvY2tPdXRFbXBsb3llZSA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGVtcGxveWVlSWQpID0+IHtcclxuICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHNpZ25lcik7XHJcbiAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5jbG9ja091dChlbXBsb3llZUlkKTtcclxuICBhd2FpdCB0eC53YWl0KCk7XHJcbn07XHJcblxyXG5cclxuLy8gSW4gc3RvcmUvaW50ZXJhY3Rpb25zLmpzXHJcblxyXG4vLyBzdG9yZS9pbnRlcmFjdGlvbnMuanNcclxuZXhwb3J0IGNvbnN0IGZldGNoRW1wbG95ZWVTdGF0dXNGcm9tU2VydmVyID1cclxuICAoeyBzaWduZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBqb2JOYW1lIH0pID0+XHJcbiAgYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gMSkgVGhlIHB1YmxpYyBhZGRyZXNzIG9mIHRoZSB1c2VyXHJcbiAgICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gYXdhaXQgc2lnbmVyLmdldEFkZHJlc3MoKTtcclxuXHJcbiAgICAgIC8vIDIpIEJ1aWxkIHRoZSBwYXlsb2FkXHJcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgIHVzZXJBZGRyZXNzLFxyXG4gICAgICAgIGFiaSxcclxuICAgICAgICBqb2JOYW1lXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyAzKSBQT1NUIHRvIHlvdXIgY3VzdG9tIHJvdXRlXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvZW1wbG95ZWVTdGF0dXMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICAvLyA0KSBEaXNwYXRjaCBpZiB5b3Ugd2FudCB0byBzdG9yZSBpbiBSZWR1eFxyXG4gICAgICBkaXNwYXRjaCh7IHR5cGU6ICdFTVBMT1lFRV9TVEFUVVNfRlJPTV9TRVJWRVInLCBwYXlsb2FkOiBkYXRhIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZmV0Y2hFbXBsb3llZVN0YXR1c0Zyb21TZXJ2ZXI6JywgZXJyb3IpO1xyXG4gICAgICBkaXNwYXRjaCh7IHR5cGU6ICdFTVBMT1lFRV9TVEFUVVNfRlJPTV9TRVJWRVJfRVJST1InLCBlcnJvciB9KTtcclxuICAgIH1cclxuICB9O1xyXG4iXSwibmFtZXMiOlsiZXRoZXJzIiwiUkVTVEFVUkFOVF9BQkkiLCJERUNFTlRSQVRBTElUWVNFUlZJQ0VGQUNUT1JZX0FCSSIsIlBPU19BQkkiLCJ1c2VTZWxlY3RvciIsIkdsb2JhbFJlc3RhdXJhbnRzIiwibG9hZFByb3ZpZGVyIiwiZGlzcGF0Y2giLCJjb25uZWN0aW9uIiwiQnJvd3NlclByb3ZpZGVyIiwid2luZG93IiwiZXRoZXJldW0iLCJ0eXBlIiwibG9hZEFjY291bnQiLCJwcm92aWRlciIsImFjY291bnRzIiwic2VuZCIsImFjY291bnQiLCJnZXRBZGRyZXNzIiwibG9hZE5ldHdvcmsiLCJjaGFpbklkIiwiZ2V0TmV0d29yayIsIk51bWJlciIsInN1YnNjcmliZVRvRXZlbnRzIiwicmVzdGF1cmFudEZhY3RvcnkiLCJSZXN0YXVyYW50cyIsIm9uIiwicmVzdGF1cmFudCIsImlkIiwib3duZXIiLCJldmVudCIsIl9yZXN0YXVyYW50IiwiYXJncyIsInRpbWVzdGFtcCIsImpvYiIsImxvYWRGYWN0b3J5IiwidXNlciIsImFkZHJlc3MiLCJkZWNlbnRyYXRhbGl0eVNlcnZpY2VGYWN0b3J5IiwiQ29udHJhY3QiLCJhYmkiLCJsb2FkQWxsUmVzdGF1cmFudHMiLCJmYWN0b3J5IiwicmVzdGF1cmFudEFkZHJlc3NlcyIsImdldEFsbFJlc3RhdXJhbnRzIiwiaSIsImxlbmd0aCIsInJlc3RhdXJhbnRBZGRyZXNzIiwicmVzdGF1cmFudENvbnRyYWN0IiwibmFtZSIsImJhbGFuY2UiLCJnZXRCYWxhbmNlIiwicHVzaCIsImZvcm1hdEV0aGVyIiwiZXJyb3IiLCJjb25zb2xlIiwibG9hZE15UmVzdGF1cmFudHMiLCJteVJlc3RhdXJhbnRzIiwiZmlsdGVyIiwiZGVjb3JhdGVNeVJlc3RhdXJhbnRzIiwiZGVjb3JhdGVkUmVzdGF1cmFudHMiLCJjb250cmFjdCIsIm15TmFtZSIsInRvU3RyaW5nIiwiY2FzaCIsImNyZWF0ZU5ld1Jlc3RhdXJhbnQiLCJyZXN0YXVyYW50TmFtZSIsInRvdGFsQ29zdFdlaSIsInRvdGFsQ29zdCIsIkJpZ0ludCIsIk1hdGgiLCJmbG9vciIsImFsZXJ0IiwidHgiLCJjcmVhdGVSZXN0YXVyYW50IiwidmFsdWUiLCJ3YWl0IiwibG9hZERhc2hib2FyZFJlc3RhdXJhbnRDb250cmFjdERhdGEiLCJSZXN0YXVyYW50IiwiY29udHJhY3RBZGRyZXNzIiwibXlDYXNoIiwiY3JlYXRlTmV3Sm9iIiwid2FnZSIsImdldFNpZ25lciIsImFkZEpvYiIsImxvYWRBbGxKb2JzIiwiaGlyZU5ld0VtcGxveWVlIiwiam9iSWQiLCJlbXBsb3llZUFkZHJlc3MiLCJoaXJlRW1wbG95ZWUiLCJsb2FkQWxsRW1wbG95ZWVzIiwiZW1wbG95ZWVJZHMiLCJnZXRFbXBsb3llZUlkcyIsImVtcGxveWVlc0FycmF5IiwiZW1wbG95ZWVJZCIsImVtcGxveWVlIiwiZW1wbG95ZWVzIiwiY2xvY2tTdGFtcCIsImVtcGxveWVlUGVuc2lvbiIsImpvYklkcyIsImdldEpvYklkcyIsImpvYnNBcnJheSIsImpvYnMiLCJob3VybHlXYWdlSW5XZWkiLCJqb2JOYW1lIiwibWVzc2FnZSIsInN0YXJ0U2VydmljZSIsInJlY2VpcHQiLCJibG9jayIsImdldEJsb2NrIiwiYmxvY2tOdW1iZXIiLCJzZXJ2aWNlU3RhcnRUaW1lIiwibG9hZEFsbFNlcnZpY2VzIiwic2VydmljZUlkcyIsImdldFNlcnZpY2VJZHMiLCJzZXJ2aWNlc0FycmF5Iiwic2VydmljZUlkIiwic2VydmljZSIsInNlcnZpY2VzIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImNvc3QiLCJwcm9maXQiLCJyZXZlbnVlIiwiZW5kU2VydmljZSIsImNyZWF0ZVBPUyIsInNpZ25lciIsImxvZ3MiLCJtYXAiLCJsb2ciLCJpbnRlcmZhY2UiLCJwYXJzZUxvZyIsImZpbmQiLCJwYXJzZWRMb2ciLCJwb3NJZCIsInBvc0FkZHJlc3MiLCJwb3MiLCJsb2FkQWxsUE9TIiwicG9zSWRzIiwiZ2V0UE9TSWRzIiwicG9zQXJyYXkiLCJQT1NNYXBwaW5nIiwicG9zQ29udHJhY3QiLCJwb3NOYW1lIiwiZ2V0TmFtZSIsImxvYWRBbGxNZW51SXRlbXMiLCJwb3NBZGRyZXNzZXMiLCJnZXRBbGxQT1NBZGRyZXNzZXMiLCJwYXlsb2FkIiwiZmlyc3RQT1NBZGRyZXNzIiwibWVudUl0ZW1JZHMiLCJnZXRNZW51SXRlbUlkcyIsIm1lbnVJdGVtcyIsIm1lbnVJdGVtIiwibWVudSIsImFkZE5ld01lbnVJdGVtIiwiY29zdEluV2VpIiwicGFyc2VVbml0cyIsImFkZE1lbnVJdGVtIiwibG9hZEVtcGxveWVlUmVsZXZhbnRQT1MiLCJjcmVhdGVUaWNrZXRGb3JQT1MiLCJwb3NBYmkiLCJ0aWNrZXROYW1lIiwic2VydmVyQWRkcmVzcyIsImNyZWF0ZVRpY2tldCIsImxvYWRBbGxUaWNrZXRzRm9yUE9TIiwidGlja2V0SWRzIiwiZ2V0VGlja2V0SWRzIiwidGlja2V0c0FycmF5IiwidGlja2V0SWRCTiIsInRpY2tldElkIiwidGlja2V0U3RydWN0IiwiZ2V0VGlja2V0Iiwic2VydmVyIiwicGFpZCIsInRpY2tldHMiLCJzZXRBY3RpdmVUaWNrZXQiLCJ0aWNrZXQiLCJjbGVhckFjdGl2ZVRpY2tldCIsImxvYWRNZW51SXRlbXNGb3JQT1MiLCJpdGVtIiwiYWRkVGlja2V0T3JkZXJzIiwiaXRlbXMiLCJsb2FkRnVsbFRpY2tldERldGFpbHMiLCJvcmRlcnMiLCJvcmRlckl0ZW0iLCJmdWxsVGlja2V0IiwiYnVmZmVySXRlbUZvclRpY2tldCIsInJpbmdCdWZmZXJlZEl0ZW1zIiwicGVuZGluZ09yZGVyQnVmZmVyIiwiZ2V0U3RhdGUiLCJzdHJpbmdJZCIsIml0ZW1zVG9SaW5nIiwicnVuZ0l0ZW1zIiwiY2xvY2tJbkVtcGxveWVlIiwiY2xvY2tJbiIsImNsb2NrT3V0RW1wbG95ZWUiLCJjbG9ja091dCIsImZldGNoRW1wbG95ZWVTdGF0dXNGcm9tU2VydmVyIiwidXNlckFkZHJlc3MiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJFcnJvciIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/store/interactions.js\n"));

/***/ })

});