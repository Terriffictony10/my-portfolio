"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/RestaurantDashboard",{

/***/ "./src/store/interactions.js":
/*!***********************************!*\
  !*** ./src/store/interactions.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNewMenuItem: function() { return /* binding */ addNewMenuItem; },\n/* harmony export */   addTicketOrders: function() { return /* binding */ addTicketOrders; },\n/* harmony export */   bufferItemForTicket: function() { return /* binding */ bufferItemForTicket; },\n/* harmony export */   clearActiveTicket: function() { return /* binding */ clearActiveTicket; },\n/* harmony export */   createNewJob: function() { return /* binding */ createNewJob; },\n/* harmony export */   createNewRestaurant: function() { return /* binding */ createNewRestaurant; },\n/* harmony export */   createPOS: function() { return /* binding */ createPOS; },\n/* harmony export */   createTicketForPOS: function() { return /* binding */ createTicketForPOS; },\n/* harmony export */   decorateMyRestaurants: function() { return /* binding */ decorateMyRestaurants; },\n/* harmony export */   endService: function() { return /* binding */ endService; },\n/* harmony export */   hireNewEmployee: function() { return /* binding */ hireNewEmployee; },\n/* harmony export */   loadAccount: function() { return /* binding */ loadAccount; },\n/* harmony export */   loadAllEmployees: function() { return /* binding */ loadAllEmployees; },\n/* harmony export */   loadAllJobs: function() { return /* binding */ loadAllJobs; },\n/* harmony export */   loadAllMenuItems: function() { return /* binding */ loadAllMenuItems; },\n/* harmony export */   loadAllPOS: function() { return /* binding */ loadAllPOS; },\n/* harmony export */   loadAllRestaurants: function() { return /* binding */ loadAllRestaurants; },\n/* harmony export */   loadAllServices: function() { return /* binding */ loadAllServices; },\n/* harmony export */   loadAllTicketsForPOS: function() { return /* binding */ loadAllTicketsForPOS; },\n/* harmony export */   loadDashboardRestaurantContractData: function() { return /* binding */ loadDashboardRestaurantContractData; },\n/* harmony export */   loadEmployeeRelevantPOS: function() { return /* binding */ loadEmployeeRelevantPOS; },\n/* harmony export */   loadFactory: function() { return /* binding */ loadFactory; },\n/* harmony export */   loadFullTicketDetails: function() { return /* binding */ loadFullTicketDetails; },\n/* harmony export */   loadMenuItemsForPOS: function() { return /* binding */ loadMenuItemsForPOS; },\n/* harmony export */   loadMyRestaurants: function() { return /* binding */ loadMyRestaurants; },\n/* harmony export */   loadNetwork: function() { return /* binding */ loadNetwork; },\n/* harmony export */   loadProvider: function() { return /* binding */ loadProvider; },\n/* harmony export */   ringBufferedItems: function() { return /* binding */ ringBufferedItems; },\n/* harmony export */   setActiveTicket: function() { return /* binding */ setActiveTicket; },\n/* harmony export */   startService: function() { return /* binding */ startService; },\n/* harmony export */   subscribeToEvents: function() { return /* binding */ subscribeToEvents; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abis/Restaurant.json */ \"./src/abis/Restaurant.json\");\n/* harmony import */ var _abis_decentratalityServiceFactory_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../abis/decentratalityServiceFactory.json */ \"./src/abis/decentratalityServiceFactory.json\");\n/* harmony import */ var _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abis/POS.json */ \"./src/abis/POS.json\");\n// src/store/interactions.js\n\n\n\n\n\nlet GlobalRestaurants = [];\nconst loadProvider = async (dispatch)=>{\n    const connection = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.BrowserProvider(window.ethereum);\n    dispatch({\n        type: \"PROVIDER_LOADED\",\n        connection\n    });\n    return connection;\n};\nconst loadAccount = async (provider, dispatch)=>{\n    const accounts = await provider.send(\"eth_requestAccounts\", []);\n    const account = ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.getAddress(accounts[0]);\n    dispatch({\n        type: \"ACCOUNT_LOADED\",\n        account\n    });\n    return account;\n};\nconst loadNetwork = async (provider, dispatch)=>{\n    let { chainId } = await provider.getNetwork();\n    chainId = Number(chainId);\n    dispatch({\n        type: \"NETWORK_LOADED\",\n        chainId\n    });\n    return chainId;\n};\nconst subscribeToEvents = async function(restaurantFactory, dispatch) {\n    for(var _len = arguments.length, Restaurants = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        Restaurants[_key - 2] = arguments[_key];\n    }\n    restaurantFactory.on(\"RestaurantCreated\", (restaurant1, id, owner, event)=>{\n        const _restaurant = event.args;\n        dispatch({\n            type: \"NEW_RESTAURANT_CREATION_SUCCESS\",\n            _restaurant,\n            event\n        });\n    });\n    for(restaurant in Restaurants){\n        restaurant.on(\"JobAdded\", (id, timestamp, job, event)=>{});\n    }\n};\nconst loadFactory = async (provider, address, dispatch)=>{\n    const user = await provider.getSigner();\n    const decentratalityServiceFactory = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(address, _abis_decentratalityServiceFactory_json__WEBPACK_IMPORTED_MODULE_1__.abi, user);\n    dispatch({\n        type: \"DECENTRATALITY_SERVICE_FACTORY_LOADED\",\n        decentratalityServiceFactory\n    });\n    return decentratalityServiceFactory;\n};\nconst loadAllRestaurants = async (provider, factory, dispatch)=>{\n    let Restaurants = [];\n    let GlobalRestaurants = []; // Ensure this is properly initialized in your application context\n    const blockStep = 10000; // Define a safe block range\n    const block = await provider.getBlockNumber();\n    // Paginate the query to avoid exceeding block range limits\n    const restaurantStream = [];\n    for(let fromBlock = 0; fromBlock <= block; fromBlock += blockStep){\n        const toBlock = Math.min(fromBlock + blockStep - 1, block);\n        const events = await factory.queryFilter(\"RestaurantCreated\", fromBlock, toBlock);\n        restaurantStream.push(...events);\n    }\n    const RestaurantsRaw = restaurantStream.map((event)=>event.args);\n    // Transform raw restaurant data\n    for(let i = 0; i < RestaurantsRaw.length; i++){\n        const restaurant1 = RestaurantsRaw[i];\n        const formattedRestaurant = Object.keys(restaurant1).reduce((acc, key)=>{\n            if (!isNaN(Number(key))) return acc; // Skip numeric keys\n            acc[key] = typeof restaurant1[key] === \"bigint\" ? Number(restaurant1[key]) : restaurant1[key];\n            return acc;\n        }, {});\n        Restaurants.push(formattedRestaurant);\n    }\n    GlobalRestaurants = Restaurants; // Update global state or context\n    dispatch({\n        type: \"ALL_RESTAURANTS_LOADED\",\n        Restaurants\n    });\n    return Restaurants;\n};\nconst loadMyRestaurants = async (provider, user, Restaurants, dispatch)=>{\n    const myRestaurants = Restaurants.filter((restaurant1)=>restaurant1.owner === user); // Assuming `owner` is the correct key\n    if (myRestaurants.length === 0) return;\n    dispatch({\n        type: \"MY_RESTAURANTS_LOADED\",\n        myRestaurants\n    });\n    return myRestaurants;\n};\nconst decorateMyRestaurants = async (provider, myRestaurants)=>{\n    const user = provider.getSigner();\n    const decoratedRestaurants = [];\n    if (myRestaurants) {\n        for (const restaurant1 of myRestaurants){\n            try {\n                const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurant1.address, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n                const name = await contract.name();\n                const cash = Number(await provider.getBalance(contract.address));\n                decoratedRestaurants.push({\n                    ...restaurant1,\n                    name,\n                    cash\n                });\n            } catch (error) {\n                console.error(\"Error decorating restaurant \".concat(restaurant1.address, \":\"), error);\n            }\n        }\n    }\n    return decoratedRestaurants;\n};\nconst createNewRestaurant = async (provider, factory, restaurantName, totalCostWei, dispatch)=>{\n    const user = await provider.getSigner();\n    console.log(user);\n    try {\n        // Ensure the user has enough balance to pay the total cost\n        const balance = await provider.getBalance(user);\n        if (balance < totalCostWei) {\n            alert(\"Insufficient funds to create restaurant\");\n            return;\n        }\n        const tx = await factory.createRestaurant(restaurantName, totalCostWei, {\n            value: totalCostWei\n        });\n        await tx.wait(); // Wait for the transaction to be mined\n        dispatch({\n            type: \"RESTAURANT_CREATION_SUCCESS\",\n            restaurant: tx\n        });\n    } catch (error) {\n        console.error(\"Error creating restaurant:\", error);\n        dispatch({\n            type: \"RESTAURANT_CREATION_FAIL\"\n        });\n    }\n};\nconst loadDashboardRestaurantContractData = async (provider, Restaurant, dispatch)=>{\n    const user = await provider.getSigner();\n    const contractAddress = Restaurant[0];\n    const abi = _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__;\n    const contract = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n    const name = await contract.name();\n    const myCash = await provider.getBalance(contractAddress);\n    const cash = Number(myCash).toString();\n    dispatch({\n        type: \"DASHBOARD_RESTAURANT_LOADED\",\n        contractAddress,\n        abi,\n        name,\n        cash\n    });\n    return contract;\n};\n// interactions.js\nconst createNewJob = async (provider, contractAddress, abi, name, wage, dispatch)=>{\n    const user = await provider.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n    // Call the contract function to add a new job\n    const tx = await contract.addJob(wage, name);\n    // Wait for the transaction to be mined\n    await tx.wait();\n    // Reload all jobs\n    await loadAllJobs(provider, contractAddress, abi, dispatch);\n};\nconst hireNewEmployee = async (provider, contractAddress, abi, jobId, name, employeeAddress, dispatch)=>{\n    try {\n        const user = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Call the contract function to hire a new employee\n        const tx = await contract.hireEmployee(jobId, name, employeeAddress);\n        // Wait for the transaction to be mined\n        await tx.wait();\n        // Reload all employees\n        await loadAllEmployees(provider, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error in hireNewEmployee:\", error);\n    }\n};\nconst loadAllEmployees = async (provider, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of employee IDs\n        const employeeIds = await contract.getEmployeeIds();\n        const employeesArray = [];\n        for(let i = 0; i < employeeIds.length; i++){\n            const employeeId = Number(employeeIds[i]); // Convert BigNumber to Number\n            const employee = await contract.employees(employeeId);\n            employeesArray.push({\n                id: employeeId.toString(),\n                jobId: employee.jobId.toString(),\n                name: employee.name,\n                address: employee.employeeAddress,\n                clockStamp: employee.clockStamp.toString(),\n                employeePension: employee.employeePension.toString()\n            });\n        }\n        // Dispatch action to update employees in Redux store\n        dispatch({\n            type: \"EMPLOYEES_LOADED\",\n            employees: employeesArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllEmployees:\", error);\n    }\n};\nconst loadAllJobs = async (provider, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of job IDs\n        const jobIds = await contract.getJobIds();\n        const jobsArray = [];\n        console.log(\"hello\");\n        for(let i = 0; i < jobIds.length; i++){\n            const jobId = Number(jobIds[i]); // Convert BigNumber to Number\n            const job = await contract.jobs(jobId);\n            jobsArray.push({\n                id: jobId.toString(),\n                hourlyWageInWei: job.hourlyWageInWei.toString(),\n                jobName: job.jobName\n            });\n        }\n        // Dispatch action to update jobs in Redux store\n        dispatch({\n            type: \"JOBS_LOADED\",\n            jobs: jobsArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllJobs:\", error.message);\n    }\n};\nconst startService = async (provider, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        const tx = await contract.startService();\n        const receipt = await tx.wait();\n        // Get the block timestamp from the transaction receipt\n        const block = await provider.getBlock(receipt.blockNumber);\n        const serviceStartTime = block.timestamp;\n        // Dispatch the service start time\n        dispatch({\n            type: \"SERVICE_STARTED\",\n            serviceStartTime\n        });\n    } catch (error) {\n        console.error(\"Error in startService:\", error);\n    }\n};\nconst loadAllServices = async (provider, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of service IDs\n        const serviceIds = await contract.getServiceIds();\n        const servicesArray = [];\n        for(let i = 0; i < serviceIds.length; i++){\n            const serviceId = Number(serviceIds[i]);\n            const service = await contract.services(serviceId);\n            servicesArray.push({\n                id: serviceId.toString(),\n                startTime: service.startTime.toString(),\n                endTime: service.endTime.toString(),\n                cost: service.cost.toString(),\n                profit: service.profit.toString(),\n                revenue: service.revenue.toString()\n            });\n        }\n        // Dispatch action to update services in Redux store\n        dispatch({\n            type: \"SERVICES_LOADED\",\n            services: servicesArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllServices:\", error);\n    }\n};\nconst endService = async (provider, contractAddress, abi, dispatch)=>{\n    try {\n        const user = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        const tx = await contract.endService();\n        await tx.wait();\n        // Optionally dispatch an action to update the service status in Redux\n        dispatch({\n            type: \"SERVICE_STOPPED\"\n        });\n    } catch (error) {\n        console.error(\"Error in endService:\", error);\n    }\n};\nconst createPOS = async (provider, contractAddress, abi, name, dispatch)=>{\n    try {\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n        // Call the createPOS function on the contract\n        const tx = await contract.createPOS(name);\n        const receipt = await tx.wait();\n        // Extract the POSCreated event from the receipt\n        const event = receipt.logs.map((log)=>{\n            try {\n                return contract.interface.parseLog(log);\n            } catch (e) {\n                return null;\n            }\n        }).find((parsedLog)=>parsedLog && parsedLog.name === \"POSCreated\");\n        if (event) {\n            const posId = event.args.id.toString();\n            const posAddress = event.args.pos;\n        // Dispatch action to update Redux store\n        }\n        // Reload POS list\n        await loadAllPOS(provider, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error in createPOS:\", error);\n    }\n};\nconst loadAllPOS = async (provider, contractAddress, abi, dispatch)=>{\n    try {\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        // Fetch the array of POS IDs\n        const posIds = await contract.getPOSIds();\n        const posArray = [];\n        for(let i = 0; i < posIds.length; i++){\n            const posId = Number(posIds[i]);\n            const posAddress = await contract.POSMapping(posId);\n            const posContract = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            const posName = await posContract.getName();\n            posArray.push({\n                id: posId.toString(),\n                address: posAddress,\n                name: posName.toString()\n            });\n        }\n        // Dispatch action to update POS in Redux store\n        dispatch({\n            type: \"POS_LOADED\",\n            posArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllPOS:\", error);\n    }\n};\nconst loadAllMenuItems = async (provider, contractAddress, abi, dispatch)=>{\n    try {\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, provider);\n        // Get all POS addresses associated with the restaurant\n        const posAddresses = await restaurantContract.getAllPOSAddresses();\n        if (posAddresses.length === 0) {\n            dispatch({\n                type: \"LOAD_ALL_MENU_ITEMS_SUCCESS\",\n                payload: []\n            });\n            return;\n        }\n        const firstPOSAddress = posAddresses[0];\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(firstPOSAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, provider);\n        const menuItemIds = await posContract.getMenuItemIds();\n        let menuItems = [];\n        for(let i = 0; i < menuItemIds.length; i++){\n            const id = Number(menuItemIds[i]);\n            const menuItem = await posContract.menu(id);\n            menuItems.push({\n                id: id,\n                cost: ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(menuItem.cost),\n                name: menuItem.name\n            });\n        }\n        dispatch({\n            type: \"LOAD_ALL_MENU_ITEMS_SUCCESS\",\n            payload: menuItems\n        });\n    } catch (error) {\n        console.error(\"Error loading menu items:\", error);\n    }\n};\nconst addNewMenuItem = async (provider, contractAddress, abi, cost, name, dispatch)=>{\n    try {\n        const signer = await provider.getSigner();\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, provider);\n        // Get all POS addresses from the restaurant contract\n        const posAddresses = await restaurantContract.getAllPOSAddresses();\n        // Loop through each POS address and add the menu item\n        for(let i = 0; i < posAddresses.length; i++){\n            const posAddress = posAddresses[i];\n            // Create a new contract instance for each POS\n            const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            // Call the addMenuItem function on each POS contract\n            const costInWei = ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.parseUnits(cost.toString(), \"ether\");\n            const tx = await posContract.addMenuItem(costInWei, name);\n            await tx.wait();\n        }\n        dispatch({\n            type: \"MENU_ITEM_ADDED\",\n            payload: {\n                cost,\n                name\n            }\n        });\n        await loadAllMenuItems(provider, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error adding new menu item:\", error);\n    }\n};\n// In interactions.js (near loadAllPOS or after it):\nconst loadEmployeeRelevantPOS = async (provider, restaurantAddress, dispatch)=>{\n    try {\n        const signer = await provider.getSigner();\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurantAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        const posIds = await restaurantContract.getPOSIds();\n        const posArray = [];\n        for(let i = 0; i < posIds.length; i++){\n            const posId = Number(posIds[i]);\n            const posAddress = await restaurantContract.POSMapping(posId);\n            const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            const posName = await posContract.getName();\n            posArray.push({\n                id: posId.toString(),\n                address: posAddress,\n                name: posName.toString()\n            });\n            console.log(\"1\");\n        }\n        console.log(posArray);\n        // Dispatch an action that specifically stores POS addresses relevant to the current employee's restaurant\n        dispatch({\n            type: \"RELEVANT_POS_LOADED_FOR_EMPLOYEE\",\n            payload: posArray\n        });\n        return posArray;\n    } catch (error) {\n        console.error(\"Error in loadEmployeeRelevantPOS:\", error);\n    }\n};\nconst createTicketForPOS = async (provider, posAddress, posAbi, ticketName, serverAddress, dispatch)=>{\n    try {\n        const signer = await provider.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, posAbi, signer);\n        // The POS contract extends MenuTicketBase, which has createTicket(_server, _name)\n        const tx = await posContract.createTicket(serverAddress, ticketName);\n        await tx.wait();\n        // After creation, reload tickets so the UI remains up-to-date\n        await loadAllTicketsForPOS(provider, posAddress, posAbi, dispatch);\n        dispatch({\n            type: \"CREATE_TICKET_SUCCESS\"\n        });\n    } catch (error) {\n        console.error(\"Error creating ticket:\", error);\n        dispatch({\n            type: \"CREATE_TICKET_FAIL\",\n            error\n        });\n    }\n};\n/**\r\n * Loads all tickets from a given POS contract.\r\n * @param provider Ethers provider/signer\r\n * @param posAddress The POS contract address\r\n * @param posAbi The ABI for the POS contract\r\n * @param dispatch Redux dispatch function\r\n */ const loadAllTicketsForPOS = async (provider, posAddress, posAbi, dispatch)=>{\n    try {\n        const signer = await provider.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        // The POS contract (via MenuTicketBase) has an array TicketIds, so we read that\n        const ticketIds = await posContract.getTicketIds();\n        const ticketsArray = [];\n        for(let i = 0; i < ticketIds.length; i++){\n            const ticketIdBN = ticketIds[i]; // BigInt\n            const ticketId = Number(ticketIdBN);\n            const ticketStruct = await posContract.getTicket(ticketId);\n            // ticketStruct has { name, orders[], server, id, paid }\n            ticketsArray.push({\n                id: ticketStruct.id.toString(),\n                name: ticketStruct.name,\n                server: ticketStruct.server,\n                paid: ticketStruct.paid,\n                posAddress: posAddress // So we know which POS this ticket belongs to\n            });\n        }\n        // Dispatch to store in Redux. \n        // We can store them POS-by-POS or in a single array. \n        // Below, we just push them all into a single array in Redux:\n        dispatch({\n            type: \"TICKETS_LOADED\",\n            payload: {\n                posAddress,\n                tickets: ticketsArray\n            }\n        });\n    } catch (error) {\n        console.error(\"Error loading tickets for POS:\", error);\n        dispatch({\n            type: \"TICKETS_LOAD_FAIL\",\n            error\n        });\n    }\n};\nconst setActiveTicket = async (dispatch, ticket)=>{\n    dispatch({\n        type: \"ACTIVE_TICKET_SET\",\n        payload: ticket\n    });\n};\n/**\r\n * Clears the currently active ticket in Redux.\r\n * @param {Object} dispatch Redux dispatch\r\n */ const clearActiveTicket = async (dispatch)=>{\n    dispatch({\n        type: \"ACTIVE_TICKET_CLEAR\"\n    });\n};\n/**\r\n * Loads all menu items for a given POS contract address and returns them as an array.\r\n * Optionally, you could dispatch a Redux action to store them if desired.\r\n *\r\n * @param {*} provider Ethers provider/signer\r\n * @param {String} posAddress The address of the POS\r\n * @param {Array} posAbi The ABI for the POS contract\r\n * @param {Object} dispatch Redux dispatch\r\n * @returns {Array} An array of menu items [{ id, name, cost }, ...]\r\n */ const loadMenuItemsForPOS = async (provider, posAddress, posAbi, dispatch)=>{\n    try {\n        // Optional: dispatch({ type: 'MENU_ITEMS_LOAD_REQUEST' });\n        const signer = await provider.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        const menuItemIds = await posContract.getMenuItemIds();\n        let menuItems = [];\n        for(let i = 0; i < menuItemIds.length; i++){\n            const id = Number(menuItemIds[i]);\n            const item = await posContract.menu(id);\n            // Convert cost from wei to Ether (or you can store raw wei).\n            menuItems.push({\n                id,\n                name: item.name,\n                cost: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(item.cost))\n            });\n        }\n        // Optional: dispatch({ type: 'MENU_ITEMS_FOR_POS_LOADED', payload: menuItems });\n        return menuItems;\n    } catch (error) {\n        console.error(\"Error loading menu for POS:\", error);\n        // Optional: dispatch({ type: 'MENU_ITEMS_LOAD_FAIL', error });\n        return [];\n    }\n};\nconst addTicketOrders = async (provider, posAddress, posAbi, ticketId, items, dispatch)=>{\n    try {\n        const signer = await provider.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        const tx = await posContract.addTicketOrders(ticketId, items);\n        await tx.wait();\n        // Optionally reload the updated ticket...\n        // await loadAllTicketsForPOS(provider, posAddress, posAbi, dispatch);\n        dispatch({\n            type: \"ADD_TICKET_ORDERS_SUCCESS\"\n        });\n    } catch (error) {\n        console.error(\"Error adding orders:\", error);\n        dispatch({\n            type: \"ADD_TICKET_ORDERS_FAIL\",\n            error\n        });\n    }\n};\nconst loadFullTicketDetails = async (provider, posAddress, posAbi, ticketId, dispatch)=>{\n    try {\n        const signer = await provider.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        // Grab the entire ticket struct from the contract\n        const ticketStruct = await posContract.getTicket(ticketId);\n        // ticketStruct -> { name, orders[], server, id, paid }\n        // Convert orders[] from contract (cost in wei) to a friendlier JS array\n        const orders = [];\n        for(let i = 0; i < ticketStruct.orders.length; i++){\n            const orderItem = ticketStruct.orders[i];\n            orders.push({\n                name: orderItem.name,\n                cost: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(orderItem.cost))\n            });\n        }\n        const fullTicket = {\n            id: Number(ticketStruct.id).toString(),\n            name: ticketStruct.name,\n            server: ticketStruct.server,\n            paid: ticketStruct.paid,\n            posAddress,\n            orders\n        };\n        // Dispatch so Redux knows about the fully detailed ticket\n        dispatch({\n            type: \"ACTIVE_TICKET_DETAILS_LOADED\",\n            payload: fullTicket\n        });\n    } catch (error) {\n        console.error(\"Error loading full ticket details:\", error);\n        dispatch({\n            type: \"ACTIVE_TICKET_DETAILS_FAIL\",\n            error\n        });\n    }\n};\nconst bufferItemForTicket = (ticketId, item)=>{\n    return (dispatch)=>{\n        dispatch({\n            type: \"ADD_ITEM_TO_PENDING_BUFFER\",\n            payload: {\n                ticketId,\n                item\n            }\n        });\n    };\n};\n// 2) A function that *rings* all buffered items for a given ticketId\n//    by calling `addTicketOrders` in the POS contract.\nconst ringBufferedItems = async (provider, posAddress, pendingOrderBuffer, posAbi, ticketId, dispatch, getState)=>{\n    try {\n        const stringId = ticketId.toString();\n        // Get the entire pending buffer\n        const itemsToRing = pendingOrderBuffer[stringId] || [];\n        if (itemsToRing.length === 0) {\n            console.log(\"No items to ring for this ticket.\");\n            return;\n        }\n        // Format them for the contract\n        const rungItems = itemsToRing.map((item)=>({\n                cost: ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.parseUnits(item.cost.toString(), \"ether\"),\n                name: item.name\n            }));\n        const signer = await provider.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, posAbi, signer);\n        // Send transaction\n        console.log(\"fun\");\n        const tx = await posContract.addTicketOrders(ticketId, rungItems);\n        await tx.wait();\n        console.log(\"fun\");\n        // Now tell Redux we succeeded\n        dispatch({\n            type: \"ORDER_RING_SUCCESS\",\n            payload: {\n                ticketId: ticketId,\n                rungItems: itemsToRing\n            }\n        });\n        console.log(\"Successfully rang items for ticket: \".concat(stringId));\n    } catch (error) {\n        console.error(\"Error in ringBufferedItems:\", error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCxNQUFNeEgsR0FBR0csSUFBSTtRQUNiVixRQUFRSSxHQUFHLENBQUM7UUFFWiw4QkFBOEI7UUFDOUJ6RSxTQUFTO1lBQ1BLLE1BQU07WUFDTmdKLFNBQVM7Z0JBQ1B3QixVQUFVQTtnQkFDVnVCLFdBQVdEO1lBQ2I7UUFFRjtRQUVBOUgsUUFBUUksR0FBRyxDQUFDLHVDQUFnRCxPQUFUeUg7SUFDckQsRUFBRSxPQUFPOUgsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtJQUMvQztBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0b3JlL2ludGVyYWN0aW9ucy5qcz8wMGE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9zdG9yZS9pbnRlcmFjdGlvbnMuanNcclxuXHJcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycydcclxuaW1wb3J0IFJFU1RBVVJBTlRfQUJJIGZyb20gXCIuLi9hYmlzL1Jlc3RhdXJhbnQuanNvblwiXHJcbmltcG9ydCBERUNFTlRSQVRBTElUWVNFUlZJQ0VGQUNUT1JZX0FCSSBmcm9tIFwiLi4vYWJpcy9kZWNlbnRyYXRhbGl0eVNlcnZpY2VGYWN0b3J5Lmpzb25cIlxyXG5pbXBvcnQgUE9TX0FCSSBmcm9tIFwiLi4vYWJpcy9QT1MuanNvblwiO1xyXG5pbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gJ3JlYWN0LXJlZHV4J1xyXG5cclxubGV0IEdsb2JhbFJlc3RhdXJhbnRzID0gW11cclxuZXhwb3J0IGNvbnN0IGxvYWRQcm92aWRlciA9IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG5cdGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgZXRoZXJzLkJyb3dzZXJQcm92aWRlcih3aW5kb3cuZXRoZXJldW0pO1xyXG4gICAgXHJcbiAgICBcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1BST1ZJREVSX0xPQURFRCcsIGNvbm5lY3Rpb24gfSlcclxuXHJcbiAgICByZXR1cm4gY29ubmVjdGlvblxyXG59XHJcbmV4cG9ydCBjb25zdCBsb2FkQWNjb3VudCA9IGFzeW5jIChwcm92aWRlciwgZGlzcGF0Y2gpID0+IHtcclxuXHRjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfcmVxdWVzdEFjY291bnRzXCIsIFtdKTtcclxuXHRjb25zdCBhY2NvdW50ID0gZXRoZXJzLmdldEFkZHJlc3MoYWNjb3VudHNbMF0pOyBcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdBQ0NPVU5UX0xPQURFRCcsIGFjY291bnR9KVxyXG5cclxuICAgIHJldHVybiBhY2NvdW50XHJcbn1cclxuZXhwb3J0IGNvbnN0IGxvYWROZXR3b3JrID0gYXN5bmMgKHByb3ZpZGVyLCBkaXNwYXRjaCkgPT4ge1xyXG4gICAgbGV0IHsgY2hhaW5JZCB9ID0gYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpXHJcbiAgICBjaGFpbklkID0gTnVtYmVyKGNoYWluSWQpXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdORVRXT1JLX0xPQURFRCcsIGNoYWluSWQgfSlcclxuXHJcbiAgICByZXR1cm4gY2hhaW5JZFxyXG59XHJcbmV4cG9ydCBjb25zdCBzdWJzY3JpYmVUb0V2ZW50cyA9IGFzeW5jIChyZXN0YXVyYW50RmFjdG9yeSwgZGlzcGF0Y2gsIC4uLlJlc3RhdXJhbnRzKSA9PiB7XHJcbiAgICAgICAgcmVzdGF1cmFudEZhY3Rvcnkub24oJ1Jlc3RhdXJhbnRDcmVhdGVkJywgKHJlc3RhdXJhbnQsIGlkLCBvd25lciwgZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCBfcmVzdGF1cmFudCA9IGV2ZW50LmFyZ3NcclxuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdORVdfUkVTVEFVUkFOVF9DUkVBVElPTl9TVUNDRVNTJywgX3Jlc3RhdXJhbnQsIGV2ZW50IH0pXHJcbiAgICB9KVxyXG4gICAgICAgIGZvcihyZXN0YXVyYW50IGluIFJlc3RhdXJhbnRzKSB7XHJcbiAgICAgICAgICAgIHJlc3RhdXJhbnQub24oJ0pvYkFkZGVkJywgKGlkLCB0aW1lc3RhbXAsIGpvYiwgZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIFxyXG59XHJcbmV4cG9ydCBjb25zdCBsb2FkRmFjdG9yeSA9IGFzeW5jIChwcm92aWRlciwgYWRkcmVzcywgZGlzcGF0Y2gpID0+IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKVxyXG4gICAgY29uc3QgZGVjZW50cmF0YWxpdHlTZXJ2aWNlRmFjdG9yeSA9IG5ldyBldGhlcnMuQ29udHJhY3QoYWRkcmVzcywgREVDRU5UUkFUQUxJVFlTRVJWSUNFRkFDVE9SWV9BQkkuYWJpLCB1c2VyKTtcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0RFQ0VOVFJBVEFMSVRZX1NFUlZJQ0VfRkFDVE9SWV9MT0FERUQnLCBkZWNlbnRyYXRhbGl0eVNlcnZpY2VGYWN0b3J5IH0pXHJcbiAgICByZXR1cm4gZGVjZW50cmF0YWxpdHlTZXJ2aWNlRmFjdG9yeVxyXG59XHJcbmV4cG9ydCBjb25zdCBsb2FkQWxsUmVzdGF1cmFudHMgPSBhc3luYyAocHJvdmlkZXIsIGZhY3RvcnksIGRpc3BhdGNoKSA9PiB7XHJcbiAgICBsZXQgUmVzdGF1cmFudHMgPSBbXTtcclxuICAgIGxldCBHbG9iYWxSZXN0YXVyYW50cyA9IFtdOyAvLyBFbnN1cmUgdGhpcyBpcyBwcm9wZXJseSBpbml0aWFsaXplZCBpbiB5b3VyIGFwcGxpY2F0aW9uIGNvbnRleHRcclxuICAgIGNvbnN0IGJsb2NrU3RlcCA9IDEwMDAwOyAvLyBEZWZpbmUgYSBzYWZlIGJsb2NrIHJhbmdlXHJcbiAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XHJcblxyXG4gICAgLy8gUGFnaW5hdGUgdGhlIHF1ZXJ5IHRvIGF2b2lkIGV4Y2VlZGluZyBibG9jayByYW5nZSBsaW1pdHNcclxuICAgIGNvbnN0IHJlc3RhdXJhbnRTdHJlYW0gPSBbXTtcclxuICAgIGZvciAobGV0IGZyb21CbG9jayA9IDA7IGZyb21CbG9jayA8PSBibG9jazsgZnJvbUJsb2NrICs9IGJsb2NrU3RlcCkge1xyXG4gICAgICAgIGNvbnN0IHRvQmxvY2sgPSBNYXRoLm1pbihmcm9tQmxvY2sgKyBibG9ja1N0ZXAgLSAxLCBibG9jayk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gYXdhaXQgZmFjdG9yeS5xdWVyeUZpbHRlcignUmVzdGF1cmFudENyZWF0ZWQnLCBmcm9tQmxvY2ssIHRvQmxvY2spO1xyXG4gICAgICAgIHJlc3RhdXJhbnRTdHJlYW0ucHVzaCguLi5ldmVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFJlc3RhdXJhbnRzUmF3ID0gcmVzdGF1cmFudFN0cmVhbS5tYXAoKGV2ZW50KSA9PiBldmVudC5hcmdzKTtcclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gcmF3IHJlc3RhdXJhbnQgZGF0YVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBSZXN0YXVyYW50c1Jhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHJlc3RhdXJhbnQgPSBSZXN0YXVyYW50c1Jhd1tpXTtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRSZXN0YXVyYW50ID0gT2JqZWN0LmtleXMocmVzdGF1cmFudCkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcihrZXkpKSkgcmV0dXJuIGFjYzsgLy8gU2tpcCBudW1lcmljIGtleXNcclxuICAgICAgICAgICAgYWNjW2tleV0gPSB0eXBlb2YgcmVzdGF1cmFudFtrZXldID09PSAnYmlnaW50JyA/IE51bWJlcihyZXN0YXVyYW50W2tleV0pIDogcmVzdGF1cmFudFtrZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgIH0sIHt9KTtcclxuICAgICAgICBSZXN0YXVyYW50cy5wdXNoKGZvcm1hdHRlZFJlc3RhdXJhbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIEdsb2JhbFJlc3RhdXJhbnRzID0gUmVzdGF1cmFudHM7IC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUgb3IgY29udGV4dFxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQUxMX1JFU1RBVVJBTlRTX0xPQURFRCcsIFJlc3RhdXJhbnRzIH0pO1xyXG4gICAgcmV0dXJuIFJlc3RhdXJhbnRzO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRNeVJlc3RhdXJhbnRzID0gYXN5bmMgKHByb3ZpZGVyLCB1c2VyLCBSZXN0YXVyYW50cywgZGlzcGF0Y2gpID0+IHtcclxuICAgIGNvbnN0IG15UmVzdGF1cmFudHMgPSBSZXN0YXVyYW50cy5maWx0ZXIoKHJlc3RhdXJhbnQpID0+IHJlc3RhdXJhbnQub3duZXIgPT09IHVzZXIpOyAvLyBBc3N1bWluZyBgb3duZXJgIGlzIHRoZSBjb3JyZWN0IGtleVxyXG4gICAgaWYgKG15UmVzdGF1cmFudHMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnTVlfUkVTVEFVUkFOVFNfTE9BREVEJywgbXlSZXN0YXVyYW50cyB9KTtcclxuICAgIHJldHVybiBteVJlc3RhdXJhbnRzO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlY29yYXRlTXlSZXN0YXVyYW50cyA9IGFzeW5jIChwcm92aWRlciwgbXlSZXN0YXVyYW50cykgPT4ge1xyXG4gICAgY29uc3QgdXNlciA9IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgZGVjb3JhdGVkUmVzdGF1cmFudHMgPSBbXTtcclxuICAgIGlmKG15UmVzdGF1cmFudHMpe1xyXG4gICAgZm9yIChjb25zdCByZXN0YXVyYW50IG9mIG15UmVzdGF1cmFudHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocmVzdGF1cmFudC5hZGRyZXNzLCBSRVNUQVVSQU5UX0FCSSwgdXNlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCBjb250cmFjdC5uYW1lKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhc2ggPSBOdW1iZXIoYXdhaXQgcHJvdmlkZXIuZ2V0QmFsYW5jZShjb250cmFjdC5hZGRyZXNzKSk7XHJcblxyXG4gICAgICAgICAgICBkZWNvcmF0ZWRSZXN0YXVyYW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIC4uLnJlc3RhdXJhbnQsXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgY2FzaCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVjb3JhdGluZyByZXN0YXVyYW50ICR7cmVzdGF1cmFudC5hZGRyZXNzfTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgICByZXR1cm4gZGVjb3JhdGVkUmVzdGF1cmFudHM7XHJcbn07XHJcbmV4cG9ydCBjb25zdCBjcmVhdGVOZXdSZXN0YXVyYW50ID0gYXN5bmMgKHByb3ZpZGVyLCBmYWN0b3J5LCByZXN0YXVyYW50TmFtZSwgdG90YWxDb3N0V2VpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIGNvbnN0IHVzZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICBjb25zb2xlLmxvZyh1c2VyKVxyXG4gIHRyeSB7XHJcbiAgICAvLyBFbnN1cmUgdGhlIHVzZXIgaGFzIGVub3VnaCBiYWxhbmNlIHRvIHBheSB0aGUgdG90YWwgY29zdFxyXG4gICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UodXNlcik7XHJcbiAgICBpZiAoYmFsYW5jZSA8IHRvdGFsQ29zdFdlaSkge1xyXG4gICAgICBhbGVydChcIkluc3VmZmljaWVudCBmdW5kcyB0byBjcmVhdGUgcmVzdGF1cmFudFwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgZmFjdG9yeS5jcmVhdGVSZXN0YXVyYW50KHJlc3RhdXJhbnROYW1lLCB0b3RhbENvc3RXZWksIHsgdmFsdWU6IHRvdGFsQ29zdFdlaSB9KTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTsgLy8gV2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdSRVNUQVVSQU5UX0NSRUFUSU9OX1NVQ0NFU1MnLCByZXN0YXVyYW50OiB0eCB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIHJlc3RhdXJhbnQ6XCIsIGVycm9yKTtcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogXCJSRVNUQVVSQU5UX0NSRUFUSU9OX0ZBSUxcIiB9KTtcclxuICB9XHJcbn07XHJcbmV4cG9ydCBjb25zdCBsb2FkRGFzaGJvYXJkUmVzdGF1cmFudENvbnRyYWN0RGF0YSA9IGFzeW5jIChwcm92aWRlciwgUmVzdGF1cmFudCwgZGlzcGF0Y2gpID0+IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKVxyXG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gUmVzdGF1cmFudFswXVxyXG4gICAgY29uc3QgYWJpID0gUkVTVEFVUkFOVF9BQklcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcilcclxuICAgIGNvbnN0IG5hbWUgPSBhd2FpdCBjb250cmFjdC5uYW1lKClcclxuICAgIGNvbnN0IG15Q2FzaCA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UoY29udHJhY3RBZGRyZXNzKVxyXG4gICAgY29uc3QgY2FzaCA9IE51bWJlcihteUNhc2gpLnRvU3RyaW5nKClcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdEQVNIQk9BUkRfUkVTVEFVUkFOVF9MT0FERUQnLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgbmFtZSwgY2FzaCB9KVxyXG5cclxuICAgIHJldHVybiBjb250cmFjdFxyXG4gICAgXHJcbn1cclxuLy8gaW50ZXJhY3Rpb25zLmpzXHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlTmV3Sm9iID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgbmFtZSwgd2FnZSwgZGlzcGF0Y2gpID0+IHtcclxuICBjb25zdCB1c2VyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB1c2VyKTtcclxuXHJcbiAgLy8gQ2FsbCB0aGUgY29udHJhY3QgZnVuY3Rpb24gdG8gYWRkIGEgbmV3IGpvYlxyXG4gIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuYWRkSm9iKHdhZ2UsIG5hbWUpO1xyXG5cclxuICAvLyBXYWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWRcclxuICBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gIC8vIFJlbG9hZCBhbGwgam9ic1xyXG4gIGF3YWl0IGxvYWRBbGxKb2JzKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpO1xyXG59O1xyXG5leHBvcnQgY29uc3QgaGlyZU5ld0VtcGxveWVlID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgam9iSWQsIG5hbWUsIGVtcGxveWVlQWRkcmVzcywgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB1c2VyKTtcclxuXHJcbiAgICAvLyBDYWxsIHRoZSBjb250cmFjdCBmdW5jdGlvbiB0byBoaXJlIGEgbmV3IGVtcGxveWVlXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmhpcmVFbXBsb3llZShqb2JJZCwgbmFtZSwgZW1wbG95ZWVBZGRyZXNzKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWRcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuXHJcbiAgICAvLyBSZWxvYWQgYWxsIGVtcGxveWVlc1xyXG4gICAgYXdhaXQgbG9hZEFsbEVtcGxveWVlcyhwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gaGlyZU5ld0VtcGxveWVlOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9hZEFsbEVtcGxveWVlcyA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIGVtcGxveWVlIElEc1xyXG4gICAgY29uc3QgZW1wbG95ZWVJZHMgPSBhd2FpdCBjb250cmFjdC5nZXRFbXBsb3llZUlkcygpO1xyXG5cclxuICAgIGNvbnN0IGVtcGxveWVlc0FycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVtcGxveWVlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVtcGxveWVlSWQgPSBOdW1iZXIoZW1wbG95ZWVJZHNbaV0pOyAvLyBDb252ZXJ0IEJpZ051bWJlciB0byBOdW1iZXJcclxuICAgICAgY29uc3QgZW1wbG95ZWUgPSBhd2FpdCBjb250cmFjdC5lbXBsb3llZXMoZW1wbG95ZWVJZCk7XHJcblxyXG4gICAgICBlbXBsb3llZXNBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogZW1wbG95ZWVJZC50b1N0cmluZygpLFxyXG4gICAgICAgIGpvYklkOiBlbXBsb3llZS5qb2JJZC50b1N0cmluZygpLFxyXG4gICAgICAgIG5hbWU6IGVtcGxveWVlLm5hbWUsXHJcbiAgICAgICAgYWRkcmVzczogZW1wbG95ZWUuZW1wbG95ZWVBZGRyZXNzLFxyXG4gICAgICAgIGNsb2NrU3RhbXA6IGVtcGxveWVlLmNsb2NrU3RhbXAudG9TdHJpbmcoKSxcclxuICAgICAgICBlbXBsb3llZVBlbnNpb246IGVtcGxveWVlLmVtcGxveWVlUGVuc2lvbi50b1N0cmluZygpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIGVtcGxveWVlcyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnRU1QTE9ZRUVTX0xPQURFRCcsIGVtcGxveWVlczogZW1wbG95ZWVzQXJyYXkgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWRBbGxFbXBsb3llZXM6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxKb2JzID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB1c2VyKTtcclxuXHJcbiAgICAvLyBGZXRjaCB0aGUgYXJyYXkgb2Ygam9iIElEc1xyXG4gICAgY29uc3Qgam9iSWRzID0gYXdhaXQgY29udHJhY3QuZ2V0Sm9iSWRzKCk7XHJcblxyXG4gICAgY29uc3Qgam9ic0FycmF5ID0gW107XHJcbiAgICBjb25zb2xlLmxvZygnaGVsbG8nKVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqb2JJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgam9iSWQgPSBOdW1iZXIoam9iSWRzW2ldKTsgLy8gQ29udmVydCBCaWdOdW1iZXIgdG8gTnVtYmVyXHJcbiAgICAgIGNvbnN0IGpvYiA9IGF3YWl0IGNvbnRyYWN0LmpvYnMoam9iSWQpO1xyXG5cclxuICAgICAgam9ic0FycmF5LnB1c2goe1xyXG4gICAgICAgIGlkOiBqb2JJZC50b1N0cmluZygpLFxyXG4gICAgICAgIGhvdXJseVdhZ2VJbldlaTogam9iLmhvdXJseVdhZ2VJbldlaS50b1N0cmluZygpLFxyXG4gICAgICAgIGpvYk5hbWU6IGpvYi5qb2JOYW1lLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIGpvYnMgaW4gUmVkdXggc3RvcmVcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0pPQlNfTE9BREVEJywgam9iczogam9ic0FycmF5IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBsb2FkQWxsSm9iczonLCBlcnJvci5tZXNzYWdlKTtcclxuICB9XHJcbn07XHJcbmV4cG9ydCBjb25zdCBzdGFydFNlcnZpY2UgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3Quc3RhcnRTZXJ2aWNlKCk7XHJcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgYmxvY2sgdGltZXN0YW1wIGZyb20gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcclxuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2socmVjZWlwdC5ibG9ja051bWJlcik7XHJcbiAgICBjb25zdCBzZXJ2aWNlU3RhcnRUaW1lID0gYmxvY2sudGltZXN0YW1wO1xyXG5cclxuICAgIC8vIERpc3BhdGNoIHRoZSBzZXJ2aWNlIHN0YXJ0IHRpbWVcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFUlZJQ0VfU1RBUlRFRCcsIHNlcnZpY2VTdGFydFRpbWUgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHN0YXJ0U2VydmljZTonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxTZXJ2aWNlcyA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIHNlcnZpY2UgSURzXHJcbiAgICBjb25zdCBzZXJ2aWNlSWRzID0gYXdhaXQgY29udHJhY3QuZ2V0U2VydmljZUlkcygpO1xyXG5cclxuICAgIGNvbnN0IHNlcnZpY2VzQXJyYXkgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VydmljZUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBzZXJ2aWNlSWQgPSBOdW1iZXIoc2VydmljZUlkc1tpXSk7XHJcbiAgICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBjb250cmFjdC5zZXJ2aWNlcyhzZXJ2aWNlSWQpO1xyXG5cclxuICAgICAgc2VydmljZXNBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogc2VydmljZUlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgc3RhcnRUaW1lOiBzZXJ2aWNlLnN0YXJ0VGltZS50b1N0cmluZygpLFxyXG4gICAgICAgIGVuZFRpbWU6IHNlcnZpY2UuZW5kVGltZS50b1N0cmluZygpLFxyXG4gICAgICAgIGNvc3Q6IHNlcnZpY2UuY29zdC50b1N0cmluZygpLFxyXG4gICAgICAgIHByb2ZpdDogc2VydmljZS5wcm9maXQudG9TdHJpbmcoKSxcclxuICAgICAgICByZXZlbnVlOiBzZXJ2aWNlLnJldmVudWUudG9TdHJpbmcoKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggYWN0aW9uIHRvIHVwZGF0ZSBzZXJ2aWNlcyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VSVklDRVNfTE9BREVEJywgc2VydmljZXM6IHNlcnZpY2VzQXJyYXkgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWRBbGxTZXJ2aWNlczonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGVuZFNlcnZpY2UgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZW5kU2VydmljZSgpO1xyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIE9wdGlvbmFsbHkgZGlzcGF0Y2ggYW4gYWN0aW9uIHRvIHVwZGF0ZSB0aGUgc2VydmljZSBzdGF0dXMgaW4gUmVkdXhcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFUlZJQ0VfU1RPUFBFRCcgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVuZFNlcnZpY2U6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVQT1MgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBuYW1lLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgc2lnbmVyKTtcclxuXHJcbiAgICAvLyBDYWxsIHRoZSBjcmVhdGVQT1MgZnVuY3Rpb24gb24gdGhlIGNvbnRyYWN0XHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmNyZWF0ZVBPUyhuYW1lKTtcclxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgLy8gRXh0cmFjdCB0aGUgUE9TQ3JlYXRlZCBldmVudCBmcm9tIHRoZSByZWNlaXB0XHJcbiAgICBjb25zdCBldmVudCA9IHJlY2VpcHQubG9nc1xyXG4gICAgICAubWFwKChsb2cpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsb2cpO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAuZmluZCgocGFyc2VkTG9nKSA9PiBwYXJzZWRMb2cgJiYgcGFyc2VkTG9nLm5hbWUgPT09ICdQT1NDcmVhdGVkJyk7XHJcblxyXG4gICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgIGNvbnN0IHBvc0lkID0gZXZlbnQuYXJncy5pZC50b1N0cmluZygpO1xyXG4gICAgICBjb25zdCBwb3NBZGRyZXNzID0gZXZlbnQuYXJncy5wb3M7XHJcblxyXG4gICAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIFJlZHV4IHN0b3JlXHJcbiAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbG9hZCBQT1MgbGlzdFxyXG4gICAgYXdhaXQgbG9hZEFsbFBPUyhwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlUE9TOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9hZEFsbFBPUyA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgUkVTVEFVUkFOVF9BQkksIHNpZ25lcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIFBPUyBJRHNcclxuICAgIGNvbnN0IHBvc0lkcyA9IGF3YWl0IGNvbnRyYWN0LmdldFBPU0lkcygpO1xyXG5cclxuICAgIGNvbnN0IHBvc0FycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc0lkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwb3NJZCA9IE51bWJlcihwb3NJZHNbaV0pO1xyXG4gICAgICBjb25zdCBwb3NBZGRyZXNzID0gYXdhaXQgY29udHJhY3QuUE9TTWFwcGluZyhwb3NJZCk7XHJcbiAgICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gYXdhaXQgbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBQT1NfQUJJLCBzaWduZXIpXHJcbiAgICAgIGNvbnN0IHBvc05hbWUgPSBhd2FpdCBwb3NDb250cmFjdC5nZXROYW1lKClcclxuICAgICAgXHJcblxyXG4gICAgICBwb3NBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogcG9zSWQudG9TdHJpbmcoKSxcclxuICAgICAgICBhZGRyZXNzOiBwb3NBZGRyZXNzLFxyXG4gICAgICAgIG5hbWU6IHBvc05hbWUudG9TdHJpbmcoKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIFBPUyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnUE9TX0xPQURFRCcsIHBvc0FycmF5IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBsb2FkQWxsUE9TOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcbiAgZXhwb3J0IGNvbnN0IGxvYWRBbGxNZW51SXRlbXMgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXN0YXVyYW50Q29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCBwcm92aWRlcik7XHJcblxyXG4gICAgLy8gR2V0IGFsbCBQT1MgYWRkcmVzc2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzdGF1cmFudFxyXG4gICAgY29uc3QgcG9zQWRkcmVzc2VzID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0LmdldEFsbFBPU0FkZHJlc3NlcygpO1xyXG5cclxuICAgIGlmIChwb3NBZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0xPQURfQUxMX01FTlVfSVRFTVNfU1VDQ0VTUycsIHBheWxvYWQ6IFtdIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmlyc3RQT1NBZGRyZXNzID0gcG9zQWRkcmVzc2VzWzBdO1xyXG5cclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChmaXJzdFBPU0FkZHJlc3MsIFBPU19BQkksIHByb3ZpZGVyKTtcclxuXHJcbiAgICBjb25zdCBtZW51SXRlbUlkcyA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldE1lbnVJdGVtSWRzKCk7XHJcbiAgICBsZXQgbWVudUl0ZW1zID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZW51SXRlbUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBpZCA9IE51bWJlcihtZW51SXRlbUlkc1tpXSk7XHJcbiAgICAgIGNvbnN0IG1lbnVJdGVtID0gYXdhaXQgcG9zQ29udHJhY3QubWVudShpZCk7XHJcblxyXG4gICAgICBtZW51SXRlbXMucHVzaCh7XHJcbiAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgIGNvc3Q6IGV0aGVycy5mb3JtYXRFdGhlcihtZW51SXRlbS5jb3N0KSxcclxuICAgICAgICBuYW1lOiBtZW51SXRlbS5uYW1lLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdMT0FEX0FMTF9NRU5VX0lURU1TX1NVQ0NFU1MnLCBwYXlsb2FkOiBtZW51SXRlbXMgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbWVudSBpdGVtczonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBhZGROZXdNZW51SXRlbSA9IGFzeW5jIChwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGNvc3QsIG5hbWUsIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgcmVzdGF1cmFudENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIFJFU1RBVVJBTlRfQUJJLCBwcm92aWRlcik7XHJcblxyXG4gICAgLy8gR2V0IGFsbCBQT1MgYWRkcmVzc2VzIGZyb20gdGhlIHJlc3RhdXJhbnQgY29udHJhY3RcclxuICAgIGNvbnN0IHBvc0FkZHJlc3NlcyA9IGF3YWl0IHJlc3RhdXJhbnRDb250cmFjdC5nZXRBbGxQT1NBZGRyZXNzZXMoKTtcclxuXHJcbiAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBQT1MgYWRkcmVzcyBhbmQgYWRkIHRoZSBtZW51IGl0ZW1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zQWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHBvc0FkZHJlc3MgPSBwb3NBZGRyZXNzZXNbaV07XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgY29udHJhY3QgaW5zdGFuY2UgZm9yIGVhY2ggUE9TXHJcbiAgICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBQT1NfQUJJLCBzaWduZXIpO1xyXG5cclxuICAgICAgLy8gQ2FsbCB0aGUgYWRkTWVudUl0ZW0gZnVuY3Rpb24gb24gZWFjaCBQT1MgY29udHJhY3RcclxuICAgICAgY29uc3QgY29zdEluV2VpID0gZXRoZXJzLnBhcnNlVW5pdHMoY29zdC50b1N0cmluZygpLCAnZXRoZXInKTtcclxuICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3NDb250cmFjdC5hZGRNZW51SXRlbShjb3N0SW5XZWksIG5hbWUpO1xyXG4gICAgICBhd2FpdCB0eC53YWl0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnTUVOVV9JVEVNX0FEREVEJywgcGF5bG9hZDogeyBjb3N0LCBuYW1lIH0gfSk7XHJcblxyXG4gICAgYXdhaXQgbG9hZEFsbE1lbnVJdGVtcyhwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIG5ldyBtZW51IGl0ZW06JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEluIGludGVyYWN0aW9ucy5qcyAobmVhciBsb2FkQWxsUE9TIG9yIGFmdGVyIGl0KTpcclxuZXhwb3J0IGNvbnN0IGxvYWRFbXBsb3llZVJlbGV2YW50UE9TID0gYXN5bmMgKHByb3ZpZGVyLCByZXN0YXVyYW50QWRkcmVzcywgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCByZXN0YXVyYW50Q29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHJlc3RhdXJhbnRBZGRyZXNzLCBSRVNUQVVSQU5UX0FCSSwgc2lnbmVyKTtcclxuICAgIGNvbnN0IHBvc0lkcyA9IGF3YWl0IHJlc3RhdXJhbnRDb250cmFjdC5nZXRQT1NJZHMoKTtcclxuICAgIFxyXG4gICAgY29uc3QgcG9zQXJyYXkgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc0lkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwb3NJZCA9IE51bWJlcihwb3NJZHNbaV0pO1xyXG4gICAgICBjb25zdCBwb3NBZGRyZXNzID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0LlBPU01hcHBpbmcocG9zSWQpO1xyXG4gICAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKTtcclxuICAgICAgY29uc3QgcG9zTmFtZSA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldE5hbWUoKTtcclxuICAgICAgcG9zQXJyYXkucHVzaCh7XHJcbiAgICAgICAgaWQ6IHBvc0lkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgYWRkcmVzczogcG9zQWRkcmVzcyxcclxuICAgICAgICBuYW1lOiBwb3NOYW1lLnRvU3RyaW5nKClcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcxJylcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKHBvc0FycmF5KVxyXG5cclxuICAgIC8vIERpc3BhdGNoIGFuIGFjdGlvbiB0aGF0IHNwZWNpZmljYWxseSBzdG9yZXMgUE9TIGFkZHJlc3NlcyByZWxldmFudCB0byB0aGUgY3VycmVudCBlbXBsb3llZSdzIHJlc3RhdXJhbnRcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1JFTEVWQU5UX1BPU19MT0FERURfRk9SX0VNUExPWUVFJywgcGF5bG9hZDogcG9zQXJyYXkgfSk7XHJcbiAgICByZXR1cm4gcG9zQXJyYXk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWRFbXBsb3llZVJlbGV2YW50UE9TOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRpY2tldEZvclBPUyA9IGFzeW5jIChcclxuICBwcm92aWRlcixcclxuICBwb3NBZGRyZXNzLFxyXG4gIHBvc0FiaSxcclxuICB0aWNrZXROYW1lLFxyXG4gIHNlcnZlckFkZHJlc3MsXHJcbiAgZGlzcGF0Y2hcclxuKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIHBvc0FiaSwgc2lnbmVyKTtcclxuXHJcbiAgICAvLyBUaGUgUE9TIGNvbnRyYWN0IGV4dGVuZHMgTWVudVRpY2tldEJhc2UsIHdoaWNoIGhhcyBjcmVhdGVUaWNrZXQoX3NlcnZlciwgX25hbWUpXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IHBvc0NvbnRyYWN0LmNyZWF0ZVRpY2tldChzZXJ2ZXJBZGRyZXNzLCB0aWNrZXROYW1lKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuXHJcbiAgICAvLyBBZnRlciBjcmVhdGlvbiwgcmVsb2FkIHRpY2tldHMgc28gdGhlIFVJIHJlbWFpbnMgdXAtdG8tZGF0ZVxyXG4gICAgYXdhaXQgbG9hZEFsbFRpY2tldHNGb3JQT1MocHJvdmlkZXIsIHBvc0FkZHJlc3MsIHBvc0FiaSwgZGlzcGF0Y2gpO1xyXG5cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0NSRUFURV9USUNLRVRfU1VDQ0VTUycgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHRpY2tldDonLCBlcnJvcik7XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdDUkVBVEVfVElDS0VUX0ZBSUwnLCBlcnJvciB9KTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogTG9hZHMgYWxsIHRpY2tldHMgZnJvbSBhIGdpdmVuIFBPUyBjb250cmFjdC5cclxuICogQHBhcmFtIHByb3ZpZGVyIEV0aGVycyBwcm92aWRlci9zaWduZXJcclxuICogQHBhcmFtIHBvc0FkZHJlc3MgVGhlIFBPUyBjb250cmFjdCBhZGRyZXNzXHJcbiAqIEBwYXJhbSBwb3NBYmkgVGhlIEFCSSBmb3IgdGhlIFBPUyBjb250cmFjdFxyXG4gKiBAcGFyYW0gZGlzcGF0Y2ggUmVkdXggZGlzcGF0Y2ggZnVuY3Rpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBsb2FkQWxsVGlja2V0c0ZvclBPUyA9IGFzeW5jIChwcm92aWRlciwgcG9zQWRkcmVzcywgcG9zQWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBQT1NfQUJJLCBzaWduZXIpO1xyXG4gICAgLy8gVGhlIFBPUyBjb250cmFjdCAodmlhIE1lbnVUaWNrZXRCYXNlKSBoYXMgYW4gYXJyYXkgVGlja2V0SWRzLCBzbyB3ZSByZWFkIHRoYXRcclxuICAgIGNvbnN0IHRpY2tldElkcyA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldFRpY2tldElkcygpO1xyXG4gICAgY29uc3QgdGlja2V0c0FycmF5ID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrZXRJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgdGlja2V0SWRCTiA9IHRpY2tldElkc1tpXTsgIC8vIEJpZ0ludFxyXG4gICAgICBjb25zdCB0aWNrZXRJZCA9IE51bWJlcih0aWNrZXRJZEJOKTtcclxuICAgICAgY29uc3QgdGlja2V0U3RydWN0ID0gYXdhaXQgcG9zQ29udHJhY3QuZ2V0VGlja2V0KHRpY2tldElkKTsgXHJcbiAgICAgIC8vIHRpY2tldFN0cnVjdCBoYXMgeyBuYW1lLCBvcmRlcnNbXSwgc2VydmVyLCBpZCwgcGFpZCB9XHJcblxyXG4gICAgICB0aWNrZXRzQXJyYXkucHVzaCh7XHJcbiAgICAgICAgaWQ6IHRpY2tldFN0cnVjdC5pZC50b1N0cmluZygpLFxyXG4gICAgICAgIG5hbWU6IHRpY2tldFN0cnVjdC5uYW1lLFxyXG4gICAgICAgIHNlcnZlcjogdGlja2V0U3RydWN0LnNlcnZlcixcclxuICAgICAgICBwYWlkOiB0aWNrZXRTdHJ1Y3QucGFpZCxcclxuICAgICAgICBwb3NBZGRyZXNzOiBwb3NBZGRyZXNzIC8vIFNvIHdlIGtub3cgd2hpY2ggUE9TIHRoaXMgdGlja2V0IGJlbG9uZ3MgdG9cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggdG8gc3RvcmUgaW4gUmVkdXguIFxyXG4gICAgLy8gV2UgY2FuIHN0b3JlIHRoZW0gUE9TLWJ5LVBPUyBvciBpbiBhIHNpbmdsZSBhcnJheS4gXHJcbiAgICAvLyBCZWxvdywgd2UganVzdCBwdXNoIHRoZW0gYWxsIGludG8gYSBzaW5nbGUgYXJyYXkgaW4gUmVkdXg6XHJcbiAgICBkaXNwYXRjaCh7IFxyXG4gICAgICB0eXBlOiAnVElDS0VUU19MT0FERUQnLCBcclxuICAgICAgcGF5bG9hZDogeyBwb3NBZGRyZXNzLCB0aWNrZXRzOiB0aWNrZXRzQXJyYXkgfSBcclxuICAgIH0pO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB0aWNrZXRzIGZvciBQT1M6JywgZXJyb3IpO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnVElDS0VUU19MT0FEX0ZBSUwnLCBlcnJvciB9KTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IHNldEFjdGl2ZVRpY2tldCA9IGFzeW5jIChkaXNwYXRjaCwgdGlja2V0KSA9PiB7XHJcbiAgZGlzcGF0Y2goeyB0eXBlOiAnQUNUSVZFX1RJQ0tFVF9TRVQnLCBwYXlsb2FkOiB0aWNrZXQgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xlYXJzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRpY2tldCBpbiBSZWR1eC5cclxuICogQHBhcmFtIHtPYmplY3R9IGRpc3BhdGNoIFJlZHV4IGRpc3BhdGNoXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2xlYXJBY3RpdmVUaWNrZXQgPSBhc3luYyAoZGlzcGF0Y2gpID0+IHtcclxuICBkaXNwYXRjaCh7IHR5cGU6ICdBQ1RJVkVfVElDS0VUX0NMRUFSJyB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhbGwgbWVudSBpdGVtcyBmb3IgYSBnaXZlbiBQT1MgY29udHJhY3QgYWRkcmVzcyBhbmQgcmV0dXJucyB0aGVtIGFzIGFuIGFycmF5LlxyXG4gKiBPcHRpb25hbGx5LCB5b3UgY291bGQgZGlzcGF0Y2ggYSBSZWR1eCBhY3Rpb24gdG8gc3RvcmUgdGhlbSBpZiBkZXNpcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHByb3ZpZGVyIEV0aGVycyBwcm92aWRlci9zaWduZXJcclxuICogQHBhcmFtIHtTdHJpbmd9IHBvc0FkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIFBPU1xyXG4gKiBAcGFyYW0ge0FycmF5fSBwb3NBYmkgVGhlIEFCSSBmb3IgdGhlIFBPUyBjb250cmFjdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGlzcGF0Y2ggUmVkdXggZGlzcGF0Y2hcclxuICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBtZW51IGl0ZW1zIFt7IGlkLCBuYW1lLCBjb3N0IH0sIC4uLl1cclxuICovXHJcbmV4cG9ydCBjb25zdCBsb2FkTWVudUl0ZW1zRm9yUE9TID0gYXN5bmMgKHByb3ZpZGVyLCBwb3NBZGRyZXNzLCBwb3NBYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIE9wdGlvbmFsOiBkaXNwYXRjaCh7IHR5cGU6ICdNRU5VX0lURU1TX0xPQURfUkVRVUVTVCcgfSk7XHJcblxyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKTtcclxuICAgIGNvbnN0IG1lbnVJdGVtSWRzID0gYXdhaXQgcG9zQ29udHJhY3QuZ2V0TWVudUl0ZW1JZHMoKTtcclxuICAgIFxyXG5cclxuICAgIGxldCBtZW51SXRlbXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVudUl0ZW1JZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgaWQgPSBOdW1iZXIobWVudUl0ZW1JZHNbaV0pO1xyXG4gICAgICBjb25zdCBpdGVtID0gYXdhaXQgcG9zQ29udHJhY3QubWVudShpZCk7XHJcbiAgICAgIC8vIENvbnZlcnQgY29zdCBmcm9tIHdlaSB0byBFdGhlciAob3IgeW91IGNhbiBzdG9yZSByYXcgd2VpKS5cclxuICAgICAgbWVudUl0ZW1zLnB1c2goe1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcclxuICAgICAgICBjb3N0OiBOdW1iZXIoZXRoZXJzLmZvcm1hdEV0aGVyKGl0ZW0uY29zdCkpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPcHRpb25hbDogZGlzcGF0Y2goeyB0eXBlOiAnTUVOVV9JVEVNU19GT1JfUE9TX0xPQURFRCcsIHBheWxvYWQ6IG1lbnVJdGVtcyB9KTtcclxuXHJcbiAgICByZXR1cm4gbWVudUl0ZW1zO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIG1lbnUgZm9yIFBPUzonLCBlcnJvcik7XHJcbiAgICAvLyBPcHRpb25hbDogZGlzcGF0Y2goeyB0eXBlOiAnTUVOVV9JVEVNU19MT0FEX0ZBSUwnLCBlcnJvciB9KTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGFkZFRpY2tldE9yZGVycyA9IGFzeW5jIChcclxuICBwcm92aWRlcixcclxuICBwb3NBZGRyZXNzLFxyXG4gIHBvc0FiaSxcclxuICB0aWNrZXRJZCxcclxuICBpdGVtcywgLy8gYXJyYXkgb2YgeyBjb3N0LCBuYW1lIH0gdG8gYmUgYXBwZW5kZWRcclxuICBkaXNwYXRjaFxyXG4pID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKTtcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9zQ29udHJhY3QuYWRkVGlja2V0T3JkZXJzKHRpY2tldElkLCBpdGVtcyk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgLy8gT3B0aW9uYWxseSByZWxvYWQgdGhlIHVwZGF0ZWQgdGlja2V0Li4uXHJcbiAgICAvLyBhd2FpdCBsb2FkQWxsVGlja2V0c0ZvclBPUyhwcm92aWRlciwgcG9zQWRkcmVzcywgcG9zQWJpLCBkaXNwYXRjaCk7XHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQUREX1RJQ0tFVF9PUkRFUlNfU1VDQ0VTUycgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBvcmRlcnM6JywgZXJyb3IpO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQUREX1RJQ0tFVF9PUkRFUlNfRkFJTCcsIGVycm9yIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkRnVsbFRpY2tldERldGFpbHMgPSBhc3luYyAoXHJcbiAgcHJvdmlkZXIsXHJcbiAgcG9zQWRkcmVzcyxcclxuICBwb3NBYmksXHJcbiAgdGlja2V0SWQsXHJcbiAgZGlzcGF0Y2hcclxuKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIFBPU19BQkksIHNpZ25lcik7XHJcblxyXG4gICAgLy8gR3JhYiB0aGUgZW50aXJlIHRpY2tldCBzdHJ1Y3QgZnJvbSB0aGUgY29udHJhY3RcclxuICAgIGNvbnN0IHRpY2tldFN0cnVjdCA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldFRpY2tldCh0aWNrZXRJZCk7XHJcbiAgICAvLyB0aWNrZXRTdHJ1Y3QgLT4geyBuYW1lLCBvcmRlcnNbXSwgc2VydmVyLCBpZCwgcGFpZCB9XHJcblxyXG4gICAgLy8gQ29udmVydCBvcmRlcnNbXSBmcm9tIGNvbnRyYWN0IChjb3N0IGluIHdlaSkgdG8gYSBmcmllbmRsaWVyIEpTIGFycmF5XHJcbiAgICBjb25zdCBvcmRlcnMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja2V0U3RydWN0Lm9yZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBvcmRlckl0ZW0gPSB0aWNrZXRTdHJ1Y3Qub3JkZXJzW2ldO1xyXG4gICAgICBvcmRlcnMucHVzaCh7XHJcbiAgICAgICAgbmFtZTogb3JkZXJJdGVtLm5hbWUsXHJcbiAgICAgICAgY29zdDogTnVtYmVyKGV0aGVycy5mb3JtYXRFdGhlcihvcmRlckl0ZW0uY29zdCkpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmdWxsVGlja2V0ID0ge1xyXG4gICAgICBpZDogTnVtYmVyKHRpY2tldFN0cnVjdC5pZCkudG9TdHJpbmcoKSxcclxuICAgICAgbmFtZTogdGlja2V0U3RydWN0Lm5hbWUsXHJcbiAgICAgIHNlcnZlcjogdGlja2V0U3RydWN0LnNlcnZlcixcclxuICAgICAgcGFpZDogdGlja2V0U3RydWN0LnBhaWQsXHJcbiAgICAgIHBvc0FkZHJlc3MsXHJcbiAgICAgIG9yZGVyc1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBEaXNwYXRjaCBzbyBSZWR1eCBrbm93cyBhYm91dCB0aGUgZnVsbHkgZGV0YWlsZWQgdGlja2V0XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdBQ1RJVkVfVElDS0VUX0RFVEFJTFNfTE9BREVEJywgcGF5bG9hZDogZnVsbFRpY2tldCB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBmdWxsIHRpY2tldCBkZXRhaWxzOicsIGVycm9yKTtcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FDVElWRV9USUNLRVRfREVUQUlMU19GQUlMJywgZXJyb3IgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGJ1ZmZlckl0ZW1Gb3JUaWNrZXQgPSAodGlja2V0SWQsIGl0ZW0pID0+IHtcclxuICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdBRERfSVRFTV9UT19QRU5ESU5HX0JVRkZFUicsXHJcbiAgICAgIHBheWxvYWQ6IHsgdGlja2V0SWQsIGl0ZW0gfVxyXG4gICAgfSk7XHJcbiAgfTtcclxufTtcclxuXHJcbi8vIDIpIEEgZnVuY3Rpb24gdGhhdCAqcmluZ3MqIGFsbCBidWZmZXJlZCBpdGVtcyBmb3IgYSBnaXZlbiB0aWNrZXRJZFxyXG4vLyAgICBieSBjYWxsaW5nIGBhZGRUaWNrZXRPcmRlcnNgIGluIHRoZSBQT1MgY29udHJhY3QuXHJcblxyXG5leHBvcnQgY29uc3QgcmluZ0J1ZmZlcmVkSXRlbXMgPSBhc3luYyAoXHJcbiAgcHJvdmlkZXIsXHJcbiAgcG9zQWRkcmVzcyxcclxuICBwZW5kaW5nT3JkZXJCdWZmZXIsXHJcbiAgcG9zQWJpLFxyXG4gIHRpY2tldElkLCAgICAgICAvLyBjb3VsZCBiZSBhIG51bWJlciBvciBzdHJpbmdcclxuICBkaXNwYXRjaCxcclxuICBnZXRTdGF0ZVxyXG4pID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc3RyaW5nSWQgPSB0aWNrZXRJZC50b1N0cmluZygpXHJcblxyXG4gICAgLy8gR2V0IHRoZSBlbnRpcmUgcGVuZGluZyBidWZmZXJcclxuICAgXHJcbiAgICBjb25zdCBpdGVtc1RvUmluZyA9IHBlbmRpbmdPcmRlckJ1ZmZlcltzdHJpbmdJZF0gfHwgW11cclxuXHJcbiAgICBpZiAoaXRlbXNUb1JpbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdObyBpdGVtcyB0byByaW5nIGZvciB0aGlzIHRpY2tldC4nKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3JtYXQgdGhlbSBmb3IgdGhlIGNvbnRyYWN0XHJcbiAgICBjb25zdCBydW5nSXRlbXMgPSBpdGVtc1RvUmluZy5tYXAoKGl0ZW0pID0+ICh7XHJcbiAgICAgIGNvc3Q6IGV0aGVycy5wYXJzZVVuaXRzKGl0ZW0uY29zdC50b1N0cmluZygpLCAnZXRoZXInKSxcclxuICAgICAgbmFtZTogaXRlbS5uYW1lXHJcbiAgICB9KSlcclxuXHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKVxyXG4gICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIHBvc0FiaSwgc2lnbmVyKVxyXG5cclxuICAgIC8vIFNlbmQgdHJhbnNhY3Rpb25cclxuICAgIGNvbnNvbGUubG9nKCdmdW4nKVxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBwb3NDb250cmFjdC5hZGRUaWNrZXRPcmRlcnModGlja2V0SWQsIHJ1bmdJdGVtcylcclxuICAgIGF3YWl0IHR4LndhaXQoKVxyXG4gICAgY29uc29sZS5sb2coJ2Z1bicpXHJcblxyXG4gICAgLy8gTm93IHRlbGwgUmVkdXggd2Ugc3VjY2VlZGVkXHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdPUkRFUl9SSU5HX1NVQ0NFU1MnLFxyXG4gICAgICBwYXlsb2FkOiB7IFxyXG4gICAgICAgIHRpY2tldElkOiB0aWNrZXRJZCwgIC8vIHBhc3MgYSBzdHJpbmdcclxuICAgICAgICBydW5nSXRlbXM6IGl0ZW1zVG9SaW5nXHJcbiAgICAgIH1cclxuXHJcbiAgICB9KVxyXG4gICAgICBcclxuICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmFuZyBpdGVtcyBmb3IgdGlja2V0OiAke3N0cmluZ0lkfWApXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJpbmdCdWZmZXJlZEl0ZW1zOicsIGVycm9yKVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiZXRoZXJzIiwiUkVTVEFVUkFOVF9BQkkiLCJERUNFTlRSQVRBTElUWVNFUlZJQ0VGQUNUT1JZX0FCSSIsIlBPU19BQkkiLCJ1c2VTZWxlY3RvciIsIkdsb2JhbFJlc3RhdXJhbnRzIiwibG9hZFByb3ZpZGVyIiwiZGlzcGF0Y2giLCJjb25uZWN0aW9uIiwiQnJvd3NlclByb3ZpZGVyIiwid2luZG93IiwiZXRoZXJldW0iLCJ0eXBlIiwibG9hZEFjY291bnQiLCJwcm92aWRlciIsImFjY291bnRzIiwic2VuZCIsImFjY291bnQiLCJnZXRBZGRyZXNzIiwibG9hZE5ldHdvcmsiLCJjaGFpbklkIiwiZ2V0TmV0d29yayIsIk51bWJlciIsInN1YnNjcmliZVRvRXZlbnRzIiwicmVzdGF1cmFudEZhY3RvcnkiLCJSZXN0YXVyYW50cyIsIm9uIiwicmVzdGF1cmFudCIsImlkIiwib3duZXIiLCJldmVudCIsIl9yZXN0YXVyYW50IiwiYXJncyIsInRpbWVzdGFtcCIsImpvYiIsImxvYWRGYWN0b3J5IiwiYWRkcmVzcyIsInVzZXIiLCJnZXRTaWduZXIiLCJkZWNlbnRyYXRhbGl0eVNlcnZpY2VGYWN0b3J5IiwiQ29udHJhY3QiLCJhYmkiLCJsb2FkQWxsUmVzdGF1cmFudHMiLCJmYWN0b3J5IiwiYmxvY2tTdGVwIiwiYmxvY2siLCJnZXRCbG9ja051bWJlciIsInJlc3RhdXJhbnRTdHJlYW0iLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwiTWF0aCIsIm1pbiIsImV2ZW50cyIsInF1ZXJ5RmlsdGVyIiwicHVzaCIsIlJlc3RhdXJhbnRzUmF3IiwibWFwIiwiaSIsImxlbmd0aCIsImZvcm1hdHRlZFJlc3RhdXJhbnQiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwia2V5IiwiaXNOYU4iLCJsb2FkTXlSZXN0YXVyYW50cyIsIm15UmVzdGF1cmFudHMiLCJmaWx0ZXIiLCJkZWNvcmF0ZU15UmVzdGF1cmFudHMiLCJkZWNvcmF0ZWRSZXN0YXVyYW50cyIsImNvbnRyYWN0IiwibmFtZSIsImNhc2giLCJnZXRCYWxhbmNlIiwiZXJyb3IiLCJjb25zb2xlIiwiY3JlYXRlTmV3UmVzdGF1cmFudCIsInJlc3RhdXJhbnROYW1lIiwidG90YWxDb3N0V2VpIiwibG9nIiwiYmFsYW5jZSIsImFsZXJ0IiwidHgiLCJjcmVhdGVSZXN0YXVyYW50IiwidmFsdWUiLCJ3YWl0IiwibG9hZERhc2hib2FyZFJlc3RhdXJhbnRDb250cmFjdERhdGEiLCJSZXN0YXVyYW50IiwiY29udHJhY3RBZGRyZXNzIiwibXlDYXNoIiwidG9TdHJpbmciLCJjcmVhdGVOZXdKb2IiLCJ3YWdlIiwiYWRkSm9iIiwibG9hZEFsbEpvYnMiLCJoaXJlTmV3RW1wbG95ZWUiLCJqb2JJZCIsImVtcGxveWVlQWRkcmVzcyIsImhpcmVFbXBsb3llZSIsImxvYWRBbGxFbXBsb3llZXMiLCJlbXBsb3llZUlkcyIsImdldEVtcGxveWVlSWRzIiwiZW1wbG95ZWVzQXJyYXkiLCJlbXBsb3llZUlkIiwiZW1wbG95ZWUiLCJlbXBsb3llZXMiLCJjbG9ja1N0YW1wIiwiZW1wbG95ZWVQZW5zaW9uIiwiam9iSWRzIiwiZ2V0Sm9iSWRzIiwiam9ic0FycmF5Iiwiam9icyIsImhvdXJseVdhZ2VJbldlaSIsImpvYk5hbWUiLCJtZXNzYWdlIiwic3RhcnRTZXJ2aWNlIiwicmVjZWlwdCIsImdldEJsb2NrIiwiYmxvY2tOdW1iZXIiLCJzZXJ2aWNlU3RhcnRUaW1lIiwibG9hZEFsbFNlcnZpY2VzIiwic2VydmljZUlkcyIsImdldFNlcnZpY2VJZHMiLCJzZXJ2aWNlc0FycmF5Iiwic2VydmljZUlkIiwic2VydmljZSIsInNlcnZpY2VzIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImNvc3QiLCJwcm9maXQiLCJyZXZlbnVlIiwiZW5kU2VydmljZSIsImNyZWF0ZVBPUyIsInNpZ25lciIsImxvZ3MiLCJpbnRlcmZhY2UiLCJwYXJzZUxvZyIsImZpbmQiLCJwYXJzZWRMb2ciLCJwb3NJZCIsInBvc0FkZHJlc3MiLCJwb3MiLCJsb2FkQWxsUE9TIiwicG9zSWRzIiwiZ2V0UE9TSWRzIiwicG9zQXJyYXkiLCJQT1NNYXBwaW5nIiwicG9zQ29udHJhY3QiLCJwb3NOYW1lIiwiZ2V0TmFtZSIsImxvYWRBbGxNZW51SXRlbXMiLCJyZXN0YXVyYW50Q29udHJhY3QiLCJwb3NBZGRyZXNzZXMiLCJnZXRBbGxQT1NBZGRyZXNzZXMiLCJwYXlsb2FkIiwiZmlyc3RQT1NBZGRyZXNzIiwibWVudUl0ZW1JZHMiLCJnZXRNZW51SXRlbUlkcyIsIm1lbnVJdGVtcyIsIm1lbnVJdGVtIiwibWVudSIsImZvcm1hdEV0aGVyIiwiYWRkTmV3TWVudUl0ZW0iLCJjb3N0SW5XZWkiLCJwYXJzZVVuaXRzIiwiYWRkTWVudUl0ZW0iLCJsb2FkRW1wbG95ZWVSZWxldmFudFBPUyIsInJlc3RhdXJhbnRBZGRyZXNzIiwiY3JlYXRlVGlja2V0Rm9yUE9TIiwicG9zQWJpIiwidGlja2V0TmFtZSIsInNlcnZlckFkZHJlc3MiLCJjcmVhdGVUaWNrZXQiLCJsb2FkQWxsVGlja2V0c0ZvclBPUyIsInRpY2tldElkcyIsImdldFRpY2tldElkcyIsInRpY2tldHNBcnJheSIsInRpY2tldElkQk4iLCJ0aWNrZXRJZCIsInRpY2tldFN0cnVjdCIsImdldFRpY2tldCIsInNlcnZlciIsInBhaWQiLCJ0aWNrZXRzIiwic2V0QWN0aXZlVGlja2V0IiwidGlja2V0IiwiY2xlYXJBY3RpdmVUaWNrZXQiLCJsb2FkTWVudUl0ZW1zRm9yUE9TIiwiaXRlbSIsImFkZFRpY2tldE9yZGVycyIsIml0ZW1zIiwibG9hZEZ1bGxUaWNrZXREZXRhaWxzIiwib3JkZXJzIiwib3JkZXJJdGVtIiwiZnVsbFRpY2tldCIsImJ1ZmZlckl0ZW1Gb3JUaWNrZXQiLCJyaW5nQnVmZmVyZWRJdGVtcyIsInBlbmRpbmdPcmRlckJ1ZmZlciIsImdldFN0YXRlIiwic3RyaW5nSWQiLCJpdGVtc1RvUmluZyIsInJ1bmdJdGVtcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/store/interactions.js\n"));

/***/ })

});