"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/RestaurantDashboard",{

/***/ "./src/store/interactions.js":
/*!***********************************!*\
  !*** ./src/store/interactions.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNewMenuItem: function() { return /* binding */ addNewMenuItem; },\n/* harmony export */   addTicketOrders: function() { return /* binding */ addTicketOrders; },\n/* harmony export */   bufferItemForTicket: function() { return /* binding */ bufferItemForTicket; },\n/* harmony export */   clearActiveTicket: function() { return /* binding */ clearActiveTicket; },\n/* harmony export */   clockInEmployee: function() { return /* binding */ clockInEmployee; },\n/* harmony export */   clockOutEmployee: function() { return /* binding */ clockOutEmployee; },\n/* harmony export */   createNewJob: function() { return /* binding */ createNewJob; },\n/* harmony export */   createNewRestaurant: function() { return /* binding */ createNewRestaurant; },\n/* harmony export */   createPOS: function() { return /* binding */ createPOS; },\n/* harmony export */   createTicketForPOS: function() { return /* binding */ createTicketForPOS; },\n/* harmony export */   decorateMyRestaurants: function() { return /* binding */ decorateMyRestaurants; },\n/* harmony export */   endService: function() { return /* binding */ endService; },\n/* harmony export */   fetchEmployeeStatusFromServer: function() { return /* binding */ fetchEmployeeStatusFromServer; },\n/* harmony export */   hireNewEmployee: function() { return /* binding */ hireNewEmployee; },\n/* harmony export */   loadAccount: function() { return /* binding */ loadAccount; },\n/* harmony export */   loadAllEmployees: function() { return /* binding */ loadAllEmployees; },\n/* harmony export */   loadAllJobs: function() { return /* binding */ loadAllJobs; },\n/* harmony export */   loadAllMenuItems: function() { return /* binding */ loadAllMenuItems; },\n/* harmony export */   loadAllPOS: function() { return /* binding */ loadAllPOS; },\n/* harmony export */   loadAllRestaurants: function() { return /* binding */ loadAllRestaurants; },\n/* harmony export */   loadAllServices: function() { return /* binding */ loadAllServices; },\n/* harmony export */   loadAllTicketsForPOS: function() { return /* binding */ loadAllTicketsForPOS; },\n/* harmony export */   loadDashboardRestaurantContractData: function() { return /* binding */ loadDashboardRestaurantContractData; },\n/* harmony export */   loadEmployeeRelevantPOS: function() { return /* binding */ loadEmployeeRelevantPOS; },\n/* harmony export */   loadFactory: function() { return /* binding */ loadFactory; },\n/* harmony export */   loadFullTicketDetails: function() { return /* binding */ loadFullTicketDetails; },\n/* harmony export */   loadMenuItemsForPOS: function() { return /* binding */ loadMenuItemsForPOS; },\n/* harmony export */   loadMyRestaurants: function() { return /* binding */ loadMyRestaurants; },\n/* harmony export */   loadNetwork: function() { return /* binding */ loadNetwork; },\n/* harmony export */   loadProvider: function() { return /* binding */ loadProvider; },\n/* harmony export */   ringBufferedItems: function() { return /* binding */ ringBufferedItems; },\n/* harmony export */   setActiveTicket: function() { return /* binding */ setActiveTicket; },\n/* harmony export */   startService: function() { return /* binding */ startService; },\n/* harmony export */   subscribeToEvents: function() { return /* binding */ subscribeToEvents; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abis/Restaurant.json */ \"./src/abis/Restaurant.json\");\n/* harmony import */ var _abis_decentratalityServiceFactory_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../abis/decentratalityServiceFactory.json */ \"./src/abis/decentratalityServiceFactory.json\");\n/* harmony import */ var _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abis/POS.json */ \"./src/abis/POS.json\");\n// src/store/interactions.js\n\n\n\n\n\nlet GlobalRestaurants = [];\nconst loadProvider = async (dispatch)=>{\n    const connection = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.BrowserProvider(window.ethereum);\n    dispatch({\n        type: \"PROVIDER_LOADED\",\n        connection\n    });\n    return connection;\n};\nconst loadAccount = async (provider1, dispatch)=>{\n    const accounts = await provider1.send(\"eth_requestAccounts\", []);\n    const account = ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.getAddress(accounts[0]);\n    dispatch({\n        type: \"ACCOUNT_LOADED\",\n        account\n    });\n    return account;\n};\nconst loadNetwork = async (provider1, dispatch)=>{\n    let { chainId } = await provider1.getNetwork();\n    chainId = Number(chainId);\n    dispatch({\n        type: \"NETWORK_LOADED\",\n        chainId\n    });\n    return chainId;\n};\nconst subscribeToEvents = async function(restaurantFactory, dispatch) {\n    for(var _len = arguments.length, Restaurants = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        Restaurants[_key - 2] = arguments[_key];\n    }\n    restaurantFactory.on(\"RestaurantCreated\", (restaurant1, id, owner, event)=>{\n        const _restaurant = event.args;\n        dispatch({\n            type: \"NEW_RESTAURANT_CREATION_SUCCESS\",\n            _restaurant,\n            event\n        });\n    });\n    for(restaurant in Restaurants){\n        restaurant.on(\"JobAdded\", (id, timestamp, job, event)=>{});\n    }\n};\nconst loadFactory = async (user, address1, dispatch)=>{\n    const { provider: provider1, address } = await user;\n    const decentratalityServiceFactory = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(address1, _abis_decentratalityServiceFactory_json__WEBPACK_IMPORTED_MODULE_1__.abi, await provider1.getSigner());\n    dispatch({\n        type: \"DECENTRATALITY_SERVICE_FACTORY_LOADED\",\n        decentratalityServiceFactory\n    });\n    return decentratalityServiceFactory;\n};\nconst loadAllRestaurants = async (user, factory, dispatch)=>{\n    const { provider: provider1, address } = await user;\n    const Restaurants = [];\n    // Call the `getAllRestaurants` function from the factory contract\n    const restaurantAddresses = await factory.getAllRestaurants();\n    // Iterate through the returned restaurant addresses\n    for(let i = 0; i < restaurantAddresses.length; i++){\n        const restaurantAddress = restaurantAddresses[i];\n        // Create a new contract instance for the restaurant\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurantAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n        // Fetch restaurant details\n        const name = await restaurantContract.name();\n        const owner = await restaurantContract.owner();\n        const balance = await provider1.getBalance(restaurantAddress);\n        // Format the restaurant data\n        Restaurants.push({\n            id: i + 1,\n            address: restaurantAddress,\n            name,\n            owner,\n            balance: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(balance))\n        });\n    }\n    // Update global state or Redux store\n    console.log(Restaurants);\n    dispatch({\n        type: \"ALL_RESTAURANTS_LOADED\",\n        Restaurants\n    });\n    return Restaurants;\n};\nconst loadMyRestaurants = async (provider1, user, Restaurants, dispatch)=>{\n    const myRestaurants = Restaurants.filter((restaurant1)=>restaurant1.owner === user);\n    // Assuming `owner` is the correct key\n    if (myRestaurants.length === 0) return;\n    dispatch({\n        type: \"MY_RESTAURANTS_LOADED\",\n        myRestaurants\n    });\n    return myRestaurants;\n};\nconst decorateMyRestaurants = async (user, myRestaurants)=>{\n    const decoratedRestaurants = [];\n    if (myRestaurants) {\n        for (const restaurant1 of myRestaurants){\n            try {\n                const { provider: provider1, address } = await user;\n                const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurant1.address, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n                const name = await contract.name; // Use the new getName() function\n                const myName = name.toString();\n                const cash = Number(await provider1.getBalance(restaurant1.address));\n                decoratedRestaurants.push({\n                    ...restaurant1,\n                    myName,\n                    cash\n                });\n            } catch (error) {\n                console.error(\"Error decorating restaurant \".concat(restaurant1.address, \":\"), error);\n            }\n        }\n    }\n    return decoratedRestaurants;\n};\nconst createNewRestaurant = async (user, factory, restaurantName, totalCostWei, dispatch)=>{\n    try {\n        const { provider: provider1, address } = await user;\n        console.log(factory);\n        // Ensure totalCostWei is converted to an integer BigInt by truncating decimals\n        const totalCost = BigInt(Math.floor(Number(totalCostWei)));\n        // Check if the user has enough balance\n        const balance = await provider1.getBalance(address);\n        if (BigInt(balance) < totalCost) {\n            alert(\"Insufficient funds to create restaurant\");\n            return;\n        }\n        // Call the contract function with the converted total cost\n        const tx = await factory.createRestaurant(restaurantName, totalCost, {\n            value: totalCost\n        });\n        // Wait for the transaction to be mined\n        await tx.wait();\n        // Dispatch success action\n        dispatch({\n            type: \"RESTAURANT_CREATION_SUCCESS\",\n            restaurant: tx\n        });\n    } catch (error) {\n        console.error(\"Error creating restaurant:\", error);\n        dispatch({\n            type: \"RESTAURANT_CREATION_FAIL\",\n            error\n        });\n    }\n};\nconst loadDashboardRestaurantContractData = async (provider1, user, Restaurant, dispatch)=>{\n    const contractAddress = Restaurant.address;\n    const abi = _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__;\n    const contract = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n    const name = await contract.name();\n    const myCash = await provider1.getBalance(contractAddress);\n    const cash = Number(myCash).toString();\n    dispatch({\n        type: \"DASHBOARD_RESTAURANT_LOADED\",\n        contractAddress,\n        abi,\n        name,\n        cash\n    });\n    return contract;\n};\n// interactions.js\nconst createNewJob = async (user, contractAddress, abi, name, wage, dispatch)=>{\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n    // Call the contract function to add a new job\n    const tx = await contract.addJob(wage, name);\n    // Wait for the transaction to be mined\n    await tx.wait();\n    // Reload all jobs\n    await loadAllJobs(provider, contractAddress, abi, dispatch);\n};\nconst hireNewEmployee = async (user, contractAddress, abi, jobId, name, employeeAddress, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Call the contract function to hire a new employee\n        const tx = await contract.hireEmployee(jobId, name, employeeAddress);\n        // Wait for the transaction to be mined\n        await tx.wait();\n        // Reload all employees\n        await loadAllEmployees(provider, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error in hireNewEmployee:\", error);\n    }\n};\nconst loadAllEmployees = async (user, contractAddress, abi, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of employee IDs\n        const employeeIds = await contract.getEmployeeIds();\n        const employeesArray = [];\n        for(let i = 0; i < employeeIds.length; i++){\n            const employeeId = Number(employeeIds[i]); // Convert BigNumber to Number\n            const employee = await contract.employees(employeeId);\n            employeesArray.push({\n                id: employeeId.toString(),\n                jobId: employee.jobId.toString(),\n                name: employee.name,\n                address: employee.employeeAddress,\n                clockStamp: employee.clockStamp.toString(),\n                employeePension: employee.employeePension.toString()\n            });\n        }\n        // Dispatch action to update employees in Redux store\n        dispatch({\n            type: \"EMPLOYEES_LOADED\",\n            employees: employeesArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllEmployees:\", error);\n    }\n};\nconst loadAllJobs = async (user, contractAddress, abi, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of job IDs\n        const jobIds = await contract.getJobIds();\n        const jobsArray = [];\n        for(let i = 0; i < jobIds.length; i++){\n            const jobId = Number(jobIds[i]); // Convert BigNumber to Number\n            const job = await contract.jobs(jobId);\n            jobsArray.push({\n                id: jobId.toString(),\n                hourlyWageInWei: job.hourlyWageInWei.toString(),\n                jobName: job.jobName\n            });\n        }\n        // Dispatch action to update jobs in Redux store\n        dispatch({\n            type: \"JOBS_LOADED\",\n            jobs: jobsArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllJobs:\", error.message);\n    }\n};\nconst startService = async (user, contractAddress, abi, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        const tx = await contract.startService();\n        const receipt = await tx.wait();\n        // Get the block timestamp from the transaction receipt\n        const block = await provider.getBlock(receipt.blockNumber);\n        const serviceStartTime = block.timestamp;\n        // Dispatch the service start time\n        dispatch({\n            type: \"SERVICE_STARTED\",\n            serviceStartTime\n        });\n    } catch (error) {\n        console.error(\"Error in startService:\", error);\n    }\n};\nconst loadAllServices = async (user, contractAddress, abi, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        // Fetch the array of service IDs\n        const serviceIds = await contract.getServiceIds();\n        const servicesArray = [];\n        for(let i = 0; i < serviceIds.length; i++){\n            const serviceId = Number(serviceIds[i]);\n            const service = await contract.services(serviceId);\n            servicesArray.push({\n                id: serviceId.toString(),\n                startTime: service.startTime.toString(),\n                endTime: service.endTime.toString(),\n                cost: service.cost.toString(),\n                profit: service.profit.toString(),\n                revenue: service.revenue.toString()\n            });\n        }\n        // Dispatch action to update services in Redux store\n        dispatch({\n            type: \"SERVICES_LOADED\",\n            services: servicesArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllServices:\", error);\n    }\n};\nconst endService = async (user, contractAddress, abi, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, user);\n        const tx = await contract.endService();\n        await tx.wait();\n        // Optionally dispatch an action to update the service status in Redux\n        dispatch({\n            type: \"SERVICE_STOPPED\"\n        });\n    } catch (error) {\n        console.error(\"Error in endService:\", error);\n    }\n};\nconst createPOS = async (signer, contractAddress, abi, name, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n        // Call the createPOS function on the contract\n        const tx = await contract.createPOS(name);\n        const receipt = await tx.wait();\n        // Extract the POSCreated event from the receipt\n        const event = receipt.logs.map((log)=>{\n            try {\n                return contract.interface.parseLog(log);\n            } catch (e) {\n                return null;\n            }\n        }).find((parsedLog)=>parsedLog && parsedLog.name === \"POSCreated\");\n        if (event) {\n            const posId = event.args.id.toString();\n            const posAddress = event.args.pos;\n        // Dispatch action to update Redux store\n        }\n        // Reload POS list\n        await loadAllPOS(provider, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error in createPOS:\", error);\n    }\n};\nconst loadAllPOS = async (signer, contractAddress, abi, dispatch)=>{\n    try {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        // Fetch the array of POS IDs\n        const posIds = await contract.getPOSIds();\n        const posArray = [];\n        for(let i = 0; i < posIds.length; i++){\n            const posId = Number(posIds[i]);\n            const posAddress = await contract.POSMapping(posId);\n            const posContract = await new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            const posName = await posContract.getName();\n            posArray.push({\n                id: posId.toString(),\n                address: posAddress,\n                name: posName.toString()\n            });\n        }\n        // Dispatch action to update POS in Redux store\n        dispatch({\n            type: \"POS_LOADED\",\n            posArray\n        });\n    } catch (error) {\n        console.error(\"Error in loadAllPOS:\", error);\n    }\n};\nconst loadAllMenuItems = async (user, contractAddress, abi, dispatch)=>{\n    try {\n        c;\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, user);\n        // Get all POS addresses associated with the restaurant\n        const posAddresses = await restaurantContract.getAllPOSAddresses();\n        console.log(\"hello\");\n        if (posAddresses.length === 0) {\n            dispatch({\n                type: \"LOAD_ALL_MENU_ITEMS_SUCCESS\",\n                payload: []\n            });\n            return;\n        }\n        const firstPOSAddress = posAddresses[0];\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(firstPOSAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, provider);\n        const menuItemIds = await posContract.getMenuItemIds();\n        let menuItems = [];\n        for(let i = 0; i < menuItemIds.length; i++){\n            const id = Number(menuItemIds[i]);\n            const menuItem = await posContract.menu(id);\n            menuItems.push({\n                id: id,\n                cost: ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(menuItem.cost),\n                name: menuItem.name\n            });\n        }\n        dispatch({\n            type: \"LOAD_ALL_MENU_ITEMS_SUCCESS\",\n            payload: menuItems\n        });\n    } catch (error) {\n        console.error(\"Error loading menu items:\", error);\n    }\n};\nconst addNewMenuItem = async (signer, contractAddress, abi, cost, name, dispatch)=>{\n    try {\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        // Get all POS addresses from the restaurant contract\n        const posAddresses = await restaurantContract.getAllPOSAddresses();\n        // Loop through each POS address and add the menu item\n        for(let i = 0; i < posAddresses.length; i++){\n            const posAddress = posAddresses[i];\n            // Create a new contract instance for each POS\n            const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            // Call the addMenuItem function on each POS contract\n            const costInWei = ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.parseUnits(cost.toString(), \"ether\");\n            const tx = await posContract.addMenuItem(costInWei, name);\n            await tx.wait();\n        }\n        dispatch({\n            type: \"MENU_ITEM_ADDED\",\n            payload: {\n                cost,\n                name\n            }\n        });\n        await loadAllMenuItems(provider, contractAddress, abi, dispatch);\n    } catch (error) {\n        console.error(\"Error adding new menu item:\", error);\n    }\n};\n// In interactions.js (near loadAllPOS or after it):\nconst loadEmployeeRelevantPOS = async (signer, restaurantAddress, dispatch)=>{\n    try {\n        const restaurantContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(restaurantAddress, _abis_Restaurant_json__WEBPACK_IMPORTED_MODULE_0__, signer);\n        const posIds = await restaurantContract.getPOSIds();\n        const posArray = [];\n        for(let i = 0; i < posIds.length; i++){\n            const posId = Number(posIds[i]);\n            const posAddress = await restaurantContract.POSMapping(posId);\n            const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n            const posName = await posContract.getName();\n            posArray.push({\n                id: posId.toString(),\n                address: posAddress,\n                name: posName.toString()\n            });\n            console.log(\"1\");\n        }\n        console.log(posArray);\n        // Dispatch an action that specifically stores POS addresses relevant to the current employee's restaurant\n        dispatch({\n            type: \"RELEVANT_POS_LOADED_FOR_EMPLOYEE\",\n            payload: posArray\n        });\n        return posArray;\n    } catch (error) {\n        console.error(\"Error in loadEmployeeRelevantPOS:\", error);\n    }\n};\nconst createTicketForPOS = async (signer, posAddress, posAbi, ticketName, serverAddress, dispatch)=>{\n    try {\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, posAbi, signer);\n        // The POS contract extends MenuTicketBase, which has createTicket(_server, _name)\n        const tx = await posContract.createTicket(serverAddress, ticketName);\n        await tx.wait();\n        // After creation, reload tickets so the UI remains up-to-date\n        await loadAllTicketsForPOS(provider, posAddress, posAbi, dispatch);\n        dispatch({\n            type: \"CREATE_TICKET_SUCCESS\"\n        });\n    } catch (error) {\n        console.error(\"Error creating ticket:\", error);\n        dispatch({\n            type: \"CREATE_TICKET_FAIL\",\n            error\n        });\n    }\n};\n/**\r\n * Loads all tickets from a given POS contract.\r\n * @param provider Ethers provider/signer\r\n * @param posAddress The POS contract address\r\n * @param posAbi The ABI for the POS contract\r\n * @param dispatch Redux dispatch function\r\n */ const loadAllTicketsForPOS = async (signer, posAddress, posAbi, dispatch)=>{\n    try {\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        // The POS contract (via MenuTicketBase) has an array TicketIds, so we read that\n        const ticketIds = await posContract.getTicketIds();\n        const ticketsArray = [];\n        for(let i = 0; i < ticketIds.length; i++){\n            const ticketIdBN = ticketIds[i]; // BigInt\n            const ticketId = Number(ticketIdBN);\n            const ticketStruct = await posContract.getTicket(ticketId);\n            // ticketStruct has { name, orders[], server, id, paid }\n            ticketsArray.push({\n                id: ticketStruct.id.toString(),\n                name: ticketStruct.name,\n                server: ticketStruct.server,\n                paid: ticketStruct.paid,\n                posAddress: posAddress // So we know which POS this ticket belongs to\n            });\n        }\n        // Dispatch to store in Redux. \n        // We can store them POS-by-POS or in a single array. \n        // Below, we just push them all into a single array in Redux:\n        dispatch({\n            type: \"TICKETS_LOADED\",\n            payload: {\n                posAddress,\n                tickets: ticketsArray\n            }\n        });\n    } catch (error) {\n        console.error(\"Error loading tickets for POS:\", error);\n        dispatch({\n            type: \"TICKETS_LOAD_FAIL\",\n            error\n        });\n    }\n};\nconst setActiveTicket = async (dispatch, ticket)=>{\n    dispatch({\n        type: \"ACTIVE_TICKET_SET\",\n        payload: ticket\n    });\n};\n/**\r\n * Clears the currently active ticket in Redux.\r\n * @param {Object} dispatch Redux dispatch\r\n */ const clearActiveTicket = async (dispatch)=>{\n    dispatch({\n        type: \"ACTIVE_TICKET_CLEAR\"\n    });\n};\n/**\r\n * Loads all menu items for a given POS contract address and returns them as an array.\r\n * Optionally, you could dispatch a Redux action to store them if desired.\r\n *\r\n * @param {*} provider Ethers provider/signer\r\n * @param {String} posAddress The address of the POS\r\n * @param {Array} posAbi The ABI for the POS contract\r\n * @param {Object} dispatch Redux dispatch\r\n * @returns {Array} An array of menu items [{ id, name, cost }, ...]\r\n */ const loadMenuItemsForPOS = async (signer, posAddress, posAbi, dispatch)=>{\n    try {\n        // Optional: dispatch({ type: 'MENU_ITEMS_LOAD_REQUEST' });\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        const menuItemIds = await posContract.getMenuItemIds();\n        let menuItems = [];\n        for(let i = 0; i < menuItemIds.length; i++){\n            const id = Number(menuItemIds[i]);\n            const item = await posContract.menu(id);\n            // Convert cost from wei to Ether (or you can store raw wei).\n            menuItems.push({\n                id,\n                name: item.name,\n                cost: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(item.cost))\n            });\n        }\n        // Optional: dispatch({ type: 'MENU_ITEMS_FOR_POS_LOADED', payload: menuItems });\n        return menuItems;\n    } catch (error) {\n        console.error(\"Error loading menu for POS:\", error);\n        // Optional: dispatch({ type: 'MENU_ITEMS_LOAD_FAIL', error });\n        return [];\n    }\n};\nconst addTicketOrders = async (provider1, posAddress, posAbi, ticketId, items, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        const tx = await posContract.addTicketOrders(ticketId, items);\n        await tx.wait();\n        // Optionally reload the updated ticket...\n        // await loadAllTicketsForPOS(provider, posAddress, posAbi, dispatch);\n        dispatch({\n            type: \"ADD_TICKET_ORDERS_SUCCESS\"\n        });\n    } catch (error) {\n        console.error(\"Error adding orders:\", error);\n        dispatch({\n            type: \"ADD_TICKET_ORDERS_FAIL\",\n            error\n        });\n    }\n};\nconst loadFullTicketDetails = async (provider1, posAddress, posAbi, ticketId, dispatch)=>{\n    try {\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, _abis_POS_json__WEBPACK_IMPORTED_MODULE_2__, signer);\n        // Grab the entire ticket struct from the contract\n        const ticketStruct = await posContract.getTicket(ticketId);\n        // ticketStruct -> { name, orders[], server, id, paid }\n        // Convert orders[] from contract (cost in wei) to a friendlier JS array\n        const orders = [];\n        for(let i = 0; i < ticketStruct.orders.length; i++){\n            const orderItem = ticketStruct.orders[i];\n            orders.push({\n                name: orderItem.name,\n                cost: Number(ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.formatEther(orderItem.cost))\n            });\n        }\n        const fullTicket = {\n            id: Number(ticketStruct.id).toString(),\n            name: ticketStruct.name,\n            server: ticketStruct.server,\n            paid: ticketStruct.paid,\n            posAddress,\n            orders\n        };\n        // Dispatch so Redux knows about the fully detailed ticket\n        dispatch({\n            type: \"ACTIVE_TICKET_DETAILS_LOADED\",\n            payload: fullTicket\n        });\n    } catch (error) {\n        console.error(\"Error loading full ticket details:\", error);\n        dispatch({\n            type: \"ACTIVE_TICKET_DETAILS_FAIL\",\n            error\n        });\n    }\n};\nconst bufferItemForTicket = (ticketId, item)=>{\n    return (dispatch)=>{\n        dispatch({\n            type: \"ADD_ITEM_TO_PENDING_BUFFER\",\n            payload: {\n                ticketId,\n                item\n            }\n        });\n    };\n};\n// 2) A function that *rings* all buffered items for a given ticketId\n//    by calling `addTicketOrders` in the POS contract.\nconst ringBufferedItems = async (provider1, posAddress, pendingOrderBuffer, posAbi, ticketId, dispatch, getState)=>{\n    try {\n        const stringId = ticketId.toString();\n        // Get the entire pending buffer\n        const itemsToRing = pendingOrderBuffer[stringId] || [];\n        if (itemsToRing.length === 0) {\n            console.log(\"No items to ring for this ticket.\");\n            return;\n        }\n        // Format them for the contract\n        const rungItems = itemsToRing.map((item)=>({\n                cost: ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.parseUnits(item.cost.toString(), \"ether\"),\n                name: item.name\n            }));\n        const signer = await provider1.getSigner();\n        const posContract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(posAddress, posAbi, signer);\n        // Send transaction\n        console.log(\"fun\");\n        const tx = await posContract.addTicketOrders(ticketId, rungItems);\n        await tx.wait();\n        console.log(\"fun\");\n        // Now tell Redux we succeeded\n        dispatch({\n            type: \"ORDER_RING_SUCCESS\",\n            payload: {\n                ticketId: ticketId,\n                rungItems: itemsToRing\n            }\n        });\n        console.log(\"Successfully rang items for ticket: \".concat(stringId));\n    } catch (error) {\n        console.error(\"Error in ringBufferedItems:\", error);\n    }\n};\nconst clockInEmployee = async (provider1, contractAddress, abi, employeeId)=>{\n    const signer = await provider1.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n    const tx = await contract.clockIn(employeeId);\n    await tx.wait();\n};\nconst clockOutEmployee = async (provider1, contractAddress, abi, employeeId)=>{\n    const signer = await provider1.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.ethers.Contract(contractAddress, abi, signer);\n    const tx = await contract.clockOut(employeeId);\n    await tx.wait();\n};\n// In store/interactions.js\n// store/interactions.js\nconst fetchEmployeeStatusFromServer = (param)=>{\n    let { signer, contractAddress, abi, jobName } = param;\n    return async (dispatch, getState)=>{\n        try {\n            // 1) The public address of the user\n            const userAddress = await signer.getAddress();\n            // 2) Build the payload\n            const payload = {\n                contractAddress,\n                userAddress,\n                abi,\n                jobName\n            };\n            // 3) POST to your custom route\n            const response = await fetch(\"/api/employeeStatus\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(payload)\n            });\n            if (!response.ok) {\n                throw new Error(\"Server error: \".concat(response.statusText));\n            }\n            const data = await response.json();\n            // 4) Dispatch if you want to store in Redux\n            dispatch({\n                type: \"EMPLOYEE_STATUS_FROM_SERVER\",\n                payload: data\n            });\n        } catch (error) {\n            console.error(\"Error in fetchEmployeeStatusFromServer:\", error);\n            dispatch({\n                type: \"EMPLOYEE_STATUS_FROM_SERVER_ERROR\",\n                error\n            });\n        }\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc3RvcmUvaW50ZXJhY3Rpb25zLmpzXHJcblxyXG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnXHJcbmltcG9ydCBSRVNUQVVSQU5UX0FCSSBmcm9tIFwiLi4vYWJpcy9SZXN0YXVyYW50Lmpzb25cIlxyXG5pbXBvcnQgREVDRU5UUkFUQUxJVFlTRVJWSUNFRkFDVE9SWV9BQkkgZnJvbSBcIi4uL2FiaXMvZGVjZW50cmF0YWxpdHlTZXJ2aWNlRmFjdG9yeS5qc29uXCJcclxuaW1wb3J0IFBPU19BQkkgZnJvbSBcIi4uL2FiaXMvUE9TLmpzb25cIjtcclxuaW1wb3J0IHsgdXNlU2VsZWN0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCdcclxuXHJcbmxldCBHbG9iYWxSZXN0YXVyYW50cyA9IFtdXHJcbmV4cG9ydCBjb25zdCBsb2FkUHJvdmlkZXIgPSBhc3luYyAoZGlzcGF0Y2gpID0+IHtcclxuXHRjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcclxuICAgIFxyXG4gICAgXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdQUk9WSURFUl9MT0FERUQnLCBjb25uZWN0aW9uIH0pXHJcblxyXG4gICAgcmV0dXJuIGNvbm5lY3Rpb25cclxufVxyXG5leHBvcnQgY29uc3QgbG9hZEFjY291bnQgPSBhc3luYyAocHJvdmlkZXIsIGRpc3BhdGNoKSA9PiB7XHJcblx0Y29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLCBbXSk7XHJcblx0Y29uc3QgYWNjb3VudCA9IGV0aGVycy5nZXRBZGRyZXNzKGFjY291bnRzWzBdKTsgXHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQUNDT1VOVF9MT0FERUQnLCBhY2NvdW50fSlcclxuXHJcbiAgICByZXR1cm4gYWNjb3VudFxyXG59XHJcbmV4cG9ydCBjb25zdCBsb2FkTmV0d29yayA9IGFzeW5jIChwcm92aWRlciwgZGlzcGF0Y2gpID0+IHtcclxuICAgIGxldCB7IGNoYWluSWQgfSA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKVxyXG4gICAgY2hhaW5JZCA9IE51bWJlcihjaGFpbklkKVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnTkVUV09SS19MT0FERUQnLCBjaGFpbklkIH0pXHJcblxyXG4gICAgcmV0dXJuIGNoYWluSWRcclxufVxyXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlVG9FdmVudHMgPSBhc3luYyAocmVzdGF1cmFudEZhY3RvcnksIGRpc3BhdGNoLCAuLi5SZXN0YXVyYW50cykgPT4ge1xyXG4gICAgICAgIHJlc3RhdXJhbnRGYWN0b3J5Lm9uKCdSZXN0YXVyYW50Q3JlYXRlZCcsIChyZXN0YXVyYW50LCBpZCwgb3duZXIsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgX3Jlc3RhdXJhbnQgPSBldmVudC5hcmdzXHJcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnTkVXX1JFU1RBVVJBTlRfQ1JFQVRJT05fU1VDQ0VTUycsIF9yZXN0YXVyYW50LCBldmVudCB9KVxyXG4gICAgfSlcclxuICAgICAgICBmb3IocmVzdGF1cmFudCBpbiBSZXN0YXVyYW50cykge1xyXG4gICAgICAgICAgICByZXN0YXVyYW50Lm9uKCdKb2JBZGRlZCcsIChpZCwgdGltZXN0YW1wLCBqb2IsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICBcclxufVxyXG5leHBvcnQgY29uc3QgbG9hZEZhY3RvcnkgPSBhc3luYyAodXNlciwgYWRkcmVzczEsIGRpc3BhdGNoKSA9PiB7XHJcbiAgICAgY29uc3QgeyBwcm92aWRlciwgYWRkcmVzcyB9ID0gYXdhaXQgdXNlclxyXG4gICAgY29uc3QgZGVjZW50cmF0YWxpdHlTZXJ2aWNlRmFjdG9yeSA9IG5ldyBldGhlcnMuQ29udHJhY3QoYWRkcmVzczEsIERFQ0VOVFJBVEFMSVRZU0VSVklDRUZBQ1RPUllfQUJJLmFiaSwgYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCkpO1xyXG4gICAgXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdERUNFTlRSQVRBTElUWV9TRVJWSUNFX0ZBQ1RPUllfTE9BREVEJywgZGVjZW50cmF0YWxpdHlTZXJ2aWNlRmFjdG9yeSB9KVxyXG4gICAgcmV0dXJuIGRlY2VudHJhdGFsaXR5U2VydmljZUZhY3RvcnlcclxufVxyXG5leHBvcnQgY29uc3QgbG9hZEFsbFJlc3RhdXJhbnRzID0gYXN5bmMgKHVzZXIsIGZhY3RvcnksIGRpc3BhdGNoKSA9PiB7XHJcbiAgICBcclxuICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBhZGRyZXNzIH0gPSBhd2FpdCB1c2VyXHJcbiAgICAgICAgY29uc3QgUmVzdGF1cmFudHMgPSBbXTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgYGdldEFsbFJlc3RhdXJhbnRzYCBmdW5jdGlvbiBmcm9tIHRoZSBmYWN0b3J5IGNvbnRyYWN0XHJcbiAgICAgICAgY29uc3QgcmVzdGF1cmFudEFkZHJlc3NlcyA9IGF3YWl0IGZhY3RvcnkuZ2V0QWxsUmVzdGF1cmFudHMoKTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByZXR1cm5lZCByZXN0YXVyYW50IGFkZHJlc3Nlc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdGF1cmFudEFkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCByZXN0YXVyYW50QWRkcmVzcyA9IHJlc3RhdXJhbnRBZGRyZXNzZXNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29udHJhY3QgaW5zdGFuY2UgZm9yIHRoZSByZXN0YXVyYW50XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3RhdXJhbnRDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXHJcbiAgICAgICAgICAgICAgICByZXN0YXVyYW50QWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIFJFU1RBVVJBTlRfQUJJLFxyXG4gICAgICAgICAgICAgICAgdXNlclxyXG4gICAgICAgICAgICApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIEZldGNoIHJlc3RhdXJhbnQgZGV0YWlsc1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0Lm5hbWUoKTtcclxuICAgICAgICAgICAgY29uc3Qgb3duZXIgPSBhd2FpdCByZXN0YXVyYW50Q29udHJhY3Qub3duZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UocmVzdGF1cmFudEFkZHJlc3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gRm9ybWF0IHRoZSByZXN0YXVyYW50IGRhdGFcclxuICAgICAgICAgICAgUmVzdGF1cmFudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpZDogaSArIDEsXHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXN0YXVyYW50QWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICBvd25lcixcclxuICAgICAgICAgICAgICAgIGJhbGFuY2U6IE51bWJlcihldGhlcnMuZm9ybWF0RXRoZXIoYmFsYW5jZSkpLCAvLyBDb252ZXJ0IGJhbGFuY2UgdG8gRXRoZXIgZm9yIGVhc2llciByZWFkYWJpbGl0eVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgc3RhdGUgb3IgUmVkdXggc3RvcmVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coUmVzdGF1cmFudHMpXHJcblxyXG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJBTExfUkVTVEFVUkFOVFNfTE9BREVEXCIsIFJlc3RhdXJhbnRzIH0pO1xyXG4gICAgICAgIHJldHVybiBSZXN0YXVyYW50cztcclxuICAgIFxyXG59O1xyXG5cclxuXHJcblxyXG5leHBvcnQgY29uc3QgbG9hZE15UmVzdGF1cmFudHMgPSBhc3luYyAocHJvdmlkZXIsIHVzZXIsIFJlc3RhdXJhbnRzLCBkaXNwYXRjaCkgPT4ge1xyXG4gICAgY29uc3QgbXlSZXN0YXVyYW50cyA9IFJlc3RhdXJhbnRzLmZpbHRlcigocmVzdGF1cmFudCkgPT4gcmVzdGF1cmFudC5vd25lciA9PT0gdXNlcik7IFxyXG4gICAgLy8gQXNzdW1pbmcgYG93bmVyYCBpcyB0aGUgY29ycmVjdCBrZXlcclxuICAgIGlmIChteVJlc3RhdXJhbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ01ZX1JFU1RBVVJBTlRTX0xPQURFRCcsIG15UmVzdGF1cmFudHMgfSk7XHJcblxyXG4gICAgcmV0dXJuIG15UmVzdGF1cmFudHM7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVjb3JhdGVNeVJlc3RhdXJhbnRzID0gYXN5bmMgKHVzZXIsIG15UmVzdGF1cmFudHMpID0+IHtcclxuICAgIFxyXG4gICAgY29uc3QgZGVjb3JhdGVkUmVzdGF1cmFudHMgPSBbXTtcclxuICAgIFxyXG4gICAgaWYgKG15UmVzdGF1cmFudHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlc3RhdXJhbnQgb2YgbXlSZXN0YXVyYW50cykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIGFkZHJlc3MgfSA9IGF3YWl0IHVzZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChyZXN0YXVyYW50LmFkZHJlc3MsIFJFU1RBVVJBTlRfQUJJLCB1c2VyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCBjb250cmFjdC5uYW1lOyAvLyBVc2UgdGhlIG5ldyBnZXROYW1lKCkgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IG15TmFtZSA9IG5hbWUudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FzaCA9IE51bWJlcihhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKHJlc3RhdXJhbnQuYWRkcmVzcykpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlY29yYXRlZFJlc3RhdXJhbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnJlc3RhdXJhbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbXlOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2gsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlY29yYXRpbmcgcmVzdGF1cmFudCAke3Jlc3RhdXJhbnQuYWRkcmVzc306YCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZGVjb3JhdGVkUmVzdGF1cmFudHM7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlTmV3UmVzdGF1cmFudCA9IGFzeW5jICh1c2VyLCBmYWN0b3J5LCByZXN0YXVyYW50TmFtZSwgdG90YWxDb3N0V2VpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBcclxuICAgIGNvbnN0IHsgcHJvdmlkZXIsIGFkZHJlc3MgfSA9IGF3YWl0IHVzZXJcclxuICAgIGNvbnNvbGUubG9nKCBmYWN0b3J5KVxyXG4gICAgLy8gRW5zdXJlIHRvdGFsQ29zdFdlaSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBCaWdJbnQgYnkgdHJ1bmNhdGluZyBkZWNpbWFsc1xyXG4gICAgY29uc3QgdG90YWxDb3N0ID0gQmlnSW50KE1hdGguZmxvb3IoTnVtYmVyKHRvdGFsQ29zdFdlaSkpKTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGUgdXNlciBoYXMgZW5vdWdoIGJhbGFuY2VcclxuICAgIFxyXG4gICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UoYWRkcmVzcyk7XHJcbiAgICBpZiAoQmlnSW50KGJhbGFuY2UpIDwgdG90YWxDb3N0KSB7XHJcbiAgICAgIGFsZXJ0KFwiSW5zdWZmaWNpZW50IGZ1bmRzIHRvIGNyZWF0ZSByZXN0YXVyYW50XCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsbCB0aGUgY29udHJhY3QgZnVuY3Rpb24gd2l0aCB0aGUgY29udmVydGVkIHRvdGFsIGNvc3RcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgZmFjdG9yeS5jcmVhdGVSZXN0YXVyYW50KHJlc3RhdXJhbnROYW1lLCB0b3RhbENvc3QsIHtcclxuICAgICAgdmFsdWU6IHRvdGFsQ29zdCwgLy8gQXR0YWNoIHRoZSBmdW5kcyBpbiBXZWlcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBtaW5lZFxyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIERpc3BhdGNoIHN1Y2Nlc3MgYWN0aW9uXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6IFwiUkVTVEFVUkFOVF9DUkVBVElPTl9TVUNDRVNTXCIsIHJlc3RhdXJhbnQ6IHR4IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgcmVzdGF1cmFudDpcIiwgZXJyb3IpO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiBcIlJFU1RBVVJBTlRfQ1JFQVRJT05fRkFJTFwiLCBlcnJvciB9KTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9hZERhc2hib2FyZFJlc3RhdXJhbnRDb250cmFjdERhdGEgPSBhc3luYyAocHJvdmlkZXIsIHVzZXIsIFJlc3RhdXJhbnQsIGRpc3BhdGNoKSA9PiB7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IFJlc3RhdXJhbnQuYWRkcmVzc1xyXG4gICAgY29uc3QgYWJpID0gUkVTVEFVUkFOVF9BQklcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gYXdhaXQgbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcilcclxuICAgIGNvbnN0IG5hbWUgPSBhd2FpdCBjb250cmFjdC5uYW1lKClcclxuICAgIGNvbnN0IG15Q2FzaCA9IGF3YWl0IHByb3ZpZGVyLmdldEJhbGFuY2UoY29udHJhY3RBZGRyZXNzKVxyXG4gICAgY29uc3QgY2FzaCA9IE51bWJlcihteUNhc2gpLnRvU3RyaW5nKClcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdEQVNIQk9BUkRfUkVTVEFVUkFOVF9MT0FERUQnLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgbmFtZSwgY2FzaCB9KVxyXG5cclxuICAgIHJldHVybiBjb250cmFjdFxyXG4gICAgXHJcbn1cclxuLy8gaW50ZXJhY3Rpb25zLmpzXHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlTmV3Sm9iID0gYXN5bmMgKHVzZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBuYW1lLCB3YWdlLCBkaXNwYXRjaCkgPT4ge1xyXG4gIFxyXG4gIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gIC8vIENhbGwgdGhlIGNvbnRyYWN0IGZ1bmN0aW9uIHRvIGFkZCBhIG5ldyBqb2JcclxuICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmFkZEpvYih3YWdlLCBuYW1lKTtcclxuXHJcbiAgLy8gV2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkXHJcbiAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAvLyBSZWxvYWQgYWxsIGpvYnNcclxuICBhd2FpdCBsb2FkQWxsSm9icyhwcm92aWRlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKTtcclxufTtcclxuZXhwb3J0IGNvbnN0IGhpcmVOZXdFbXBsb3llZSA9IGFzeW5jICh1c2VyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgam9iSWQsIG5hbWUsIGVtcGxveWVlQWRkcmVzcywgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgXHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAgIC8vIENhbGwgdGhlIGNvbnRyYWN0IGZ1bmN0aW9uIHRvIGhpcmUgYSBuZXcgZW1wbG95ZWVcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuaGlyZUVtcGxveWVlKGpvYklkLCBuYW1lLCBlbXBsb3llZUFkZHJlc3MpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBtaW5lZFxyXG4gICAgYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIFJlbG9hZCBhbGwgZW1wbG95ZWVzXHJcbiAgICBhd2FpdCBsb2FkQWxsRW1wbG95ZWVzKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBoaXJlTmV3RW1wbG95ZWU6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkQWxsRW1wbG95ZWVzID0gYXN5bmMgKHVzZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIGVtcGxveWVlIElEc1xyXG4gICAgY29uc3QgZW1wbG95ZWVJZHMgPSBhd2FpdCBjb250cmFjdC5nZXRFbXBsb3llZUlkcygpO1xyXG5cclxuICAgIGNvbnN0IGVtcGxveWVlc0FycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVtcGxveWVlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVtcGxveWVlSWQgPSBOdW1iZXIoZW1wbG95ZWVJZHNbaV0pOyAvLyBDb252ZXJ0IEJpZ051bWJlciB0byBOdW1iZXJcclxuICAgICAgY29uc3QgZW1wbG95ZWUgPSBhd2FpdCBjb250cmFjdC5lbXBsb3llZXMoZW1wbG95ZWVJZCk7XHJcblxyXG4gICAgICBlbXBsb3llZXNBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogZW1wbG95ZWVJZC50b1N0cmluZygpLFxyXG4gICAgICAgIGpvYklkOiBlbXBsb3llZS5qb2JJZC50b1N0cmluZygpLFxyXG4gICAgICAgIG5hbWU6IGVtcGxveWVlLm5hbWUsXHJcbiAgICAgICAgYWRkcmVzczogZW1wbG95ZWUuZW1wbG95ZWVBZGRyZXNzLFxyXG4gICAgICAgIGNsb2NrU3RhbXA6IGVtcGxveWVlLmNsb2NrU3RhbXAudG9TdHJpbmcoKSxcclxuICAgICAgICBlbXBsb3llZVBlbnNpb246IGVtcGxveWVlLmVtcGxveWVlUGVuc2lvbi50b1N0cmluZygpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIGVtcGxveWVlcyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnRU1QTE9ZRUVTX0xPQURFRCcsIGVtcGxveWVlczogZW1wbG95ZWVzQXJyYXkgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWRBbGxFbXBsb3llZXM6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxKb2JzID0gYXN5bmMgKHVzZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIGpvYiBJRHNcclxuICAgIGNvbnN0IGpvYklkcyA9IGF3YWl0IGNvbnRyYWN0LmdldEpvYklkcygpO1xyXG5cclxuICAgIGNvbnN0IGpvYnNBcnJheSA9IFtdO1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpvYklkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBqb2JJZCA9IE51bWJlcihqb2JJZHNbaV0pOyAvLyBDb252ZXJ0IEJpZ051bWJlciB0byBOdW1iZXJcclxuICAgICAgY29uc3Qgam9iID0gYXdhaXQgY29udHJhY3Quam9icyhqb2JJZCk7XHJcblxyXG4gICAgICBqb2JzQXJyYXkucHVzaCh7XHJcbiAgICAgICAgaWQ6IGpvYklkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgaG91cmx5V2FnZUluV2VpOiBqb2IuaG91cmx5V2FnZUluV2VpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgam9iTmFtZTogam9iLmpvYk5hbWUsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BhdGNoIGFjdGlvbiB0byB1cGRhdGUgam9icyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnSk9CU19MT0FERUQnLCBqb2JzOiBqb2JzQXJyYXkgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWRBbGxKb2JzOicsIGVycm9yLm1lc3NhZ2UpO1xyXG4gIH1cclxufTtcclxuZXhwb3J0IGNvbnN0IHN0YXJ0U2VydmljZSA9IGFzeW5jICh1c2VyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgXHJcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBhYmksIHVzZXIpO1xyXG5cclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3Quc3RhcnRTZXJ2aWNlKCk7XHJcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xyXG5cclxuICAgIC8vIEdldCB0aGUgYmxvY2sgdGltZXN0YW1wIGZyb20gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcclxuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2socmVjZWlwdC5ibG9ja051bWJlcik7XHJcbiAgICBjb25zdCBzZXJ2aWNlU3RhcnRUaW1lID0gYmxvY2sudGltZXN0YW1wO1xyXG5cclxuICAgIC8vIERpc3BhdGNoIHRoZSBzZXJ2aWNlIHN0YXJ0IHRpbWVcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFUlZJQ0VfU1RBUlRFRCcsIHNlcnZpY2VTdGFydFRpbWUgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHN0YXJ0U2VydmljZTonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRBbGxTZXJ2aWNlcyA9IGFzeW5jICh1c2VyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICBcclxuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdXNlcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIHNlcnZpY2UgSURzXHJcbiAgICBjb25zdCBzZXJ2aWNlSWRzID0gYXdhaXQgY29udHJhY3QuZ2V0U2VydmljZUlkcygpO1xyXG5cclxuICAgIGNvbnN0IHNlcnZpY2VzQXJyYXkgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VydmljZUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBzZXJ2aWNlSWQgPSBOdW1iZXIoc2VydmljZUlkc1tpXSk7XHJcbiAgICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBjb250cmFjdC5zZXJ2aWNlcyhzZXJ2aWNlSWQpO1xyXG5cclxuICAgICAgc2VydmljZXNBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogc2VydmljZUlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgc3RhcnRUaW1lOiBzZXJ2aWNlLnN0YXJ0VGltZS50b1N0cmluZygpLFxyXG4gICAgICAgIGVuZFRpbWU6IHNlcnZpY2UuZW5kVGltZS50b1N0cmluZygpLFxyXG4gICAgICAgIGNvc3Q6IHNlcnZpY2UuY29zdC50b1N0cmluZygpLFxyXG4gICAgICAgIHByb2ZpdDogc2VydmljZS5wcm9maXQudG9TdHJpbmcoKSxcclxuICAgICAgICByZXZlbnVlOiBzZXJ2aWNlLnJldmVudWUudG9TdHJpbmcoKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggYWN0aW9uIHRvIHVwZGF0ZSBzZXJ2aWNlcyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VSVklDRVNfTE9BREVEJywgc2VydmljZXM6IHNlcnZpY2VzQXJyYXkgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWRBbGxTZXJ2aWNlczonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGVuZFNlcnZpY2UgPSBhc3luYyAodXNlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIFxyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB1c2VyKTtcclxuXHJcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVuZFNlcnZpY2UoKTtcclxuICAgIGF3YWl0IHR4LndhaXQoKTtcclxuXHJcbiAgICAvLyBPcHRpb25hbGx5IGRpc3BhdGNoIGFuIGFjdGlvbiB0byB1cGRhdGUgdGhlIHNlcnZpY2Ugc3RhdHVzIGluIFJlZHV4XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVJWSUNFX1NUT1BQRUQnIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlbmRTZXJ2aWNlOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlUE9TID0gYXN5bmMgKHNpZ25lciwgY29udHJhY3RBZGRyZXNzLCBhYmksIG5hbWUsIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIFxyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCBzaWduZXIpO1xyXG5cclxuICAgIC8vIENhbGwgdGhlIGNyZWF0ZVBPUyBmdW5jdGlvbiBvbiB0aGUgY29udHJhY3RcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuY3JlYXRlUE9TKG5hbWUpO1xyXG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IHRoZSBQT1NDcmVhdGVkIGV2ZW50IGZyb20gdGhlIHJlY2VpcHRcclxuICAgIGNvbnN0IGV2ZW50ID0gcmVjZWlwdC5sb2dzXHJcbiAgICAgIC5tYXAoKGxvZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLnBhcnNlTG9nKGxvZyk7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5maW5kKChwYXJzZWRMb2cpID0+IHBhcnNlZExvZyAmJiBwYXJzZWRMb2cubmFtZSA9PT0gJ1BPU0NyZWF0ZWQnKTtcclxuXHJcbiAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgY29uc3QgcG9zSWQgPSBldmVudC5hcmdzLmlkLnRvU3RyaW5nKCk7XHJcbiAgICAgIGNvbnN0IHBvc0FkZHJlc3MgPSBldmVudC5hcmdzLnBvcztcclxuXHJcbiAgICAgIC8vIERpc3BhdGNoIGFjdGlvbiB0byB1cGRhdGUgUmVkdXggc3RvcmVcclxuICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVsb2FkIFBPUyBsaXN0XHJcbiAgICBhd2FpdCBsb2FkQWxsUE9TKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBjcmVhdGVQT1M6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkQWxsUE9TID0gYXN5bmMgKHNpZ25lciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIFxyXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgUkVTVEFVUkFOVF9BQkksIHNpZ25lcik7XHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIGFycmF5IG9mIFBPUyBJRHNcclxuICAgIGNvbnN0IHBvc0lkcyA9IGF3YWl0IGNvbnRyYWN0LmdldFBPU0lkcygpO1xyXG5cclxuICAgIGNvbnN0IHBvc0FycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc0lkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwb3NJZCA9IE51bWJlcihwb3NJZHNbaV0pO1xyXG4gICAgICBjb25zdCBwb3NBZGRyZXNzID0gYXdhaXQgY29udHJhY3QuUE9TTWFwcGluZyhwb3NJZCk7XHJcbiAgICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gYXdhaXQgbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBQT1NfQUJJLCBzaWduZXIpXHJcbiAgICAgIGNvbnN0IHBvc05hbWUgPSBhd2FpdCBwb3NDb250cmFjdC5nZXROYW1lKClcclxuICAgICAgXHJcblxyXG4gICAgICBwb3NBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogcG9zSWQudG9TdHJpbmcoKSxcclxuICAgICAgICBhZGRyZXNzOiBwb3NBZGRyZXNzLFxyXG4gICAgICAgIG5hbWU6IHBvc05hbWUudG9TdHJpbmcoKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCBhY3Rpb24gdG8gdXBkYXRlIFBPUyBpbiBSZWR1eCBzdG9yZVxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnUE9TX0xPQURFRCcsIHBvc0FycmF5IH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBsb2FkQWxsUE9TOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcbiAgZXhwb3J0IGNvbnN0IGxvYWRBbGxNZW51SXRlbXMgPSBhc3luYyAodXNlciwgY29udHJhY3RBZGRyZXNzLCBhYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNcclxuICAgIGNvbnN0IHJlc3RhdXJhbnRDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBSRVNUQVVSQU5UX0FCSSwgdXNlcik7XHJcblxyXG4gICAgLy8gR2V0IGFsbCBQT1MgYWRkcmVzc2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzdGF1cmFudFxyXG4gICAgY29uc3QgcG9zQWRkcmVzc2VzID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0LmdldEFsbFBPU0FkZHJlc3NlcygpO1xyXG4gICAgY29uc29sZS5sb2coJ2hlbGxvJylcclxuICAgIGlmIChwb3NBZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0xPQURfQUxMX01FTlVfSVRFTVNfU1VDQ0VTUycsIHBheWxvYWQ6IFtdIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmlyc3RQT1NBZGRyZXNzID0gcG9zQWRkcmVzc2VzWzBdO1xyXG5cclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChmaXJzdFBPU0FkZHJlc3MsIFBPU19BQkksIHByb3ZpZGVyKTtcclxuXHJcbiAgICBjb25zdCBtZW51SXRlbUlkcyA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldE1lbnVJdGVtSWRzKCk7XHJcbiAgICBsZXQgbWVudUl0ZW1zID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZW51SXRlbUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBpZCA9IE51bWJlcihtZW51SXRlbUlkc1tpXSk7XHJcbiAgICAgIGNvbnN0IG1lbnVJdGVtID0gYXdhaXQgcG9zQ29udHJhY3QubWVudShpZCk7XHJcblxyXG4gICAgICBtZW51SXRlbXMucHVzaCh7XHJcbiAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgIGNvc3Q6IGV0aGVycy5mb3JtYXRFdGhlcihtZW51SXRlbS5jb3N0KSxcclxuICAgICAgICBuYW1lOiBtZW51SXRlbS5uYW1lLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdMT0FEX0FMTF9NRU5VX0lURU1TX1NVQ0NFU1MnLCBwYXlsb2FkOiBtZW51SXRlbXMgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbWVudSBpdGVtczonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBhZGROZXdNZW51SXRlbSA9IGFzeW5jIChzaWduZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBjb3N0LCBuYW1lLCBkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3RhdXJhbnRDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBSRVNUQVVSQU5UX0FCSSwgc2lnbmVyKTtcclxuXHJcbiAgICAvLyBHZXQgYWxsIFBPUyBhZGRyZXNzZXMgZnJvbSB0aGUgcmVzdGF1cmFudCBjb250cmFjdFxyXG4gICAgY29uc3QgcG9zQWRkcmVzc2VzID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0LmdldEFsbFBPU0FkZHJlc3NlcygpO1xyXG5cclxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIFBPUyBhZGRyZXNzIGFuZCBhZGQgdGhlIG1lbnUgaXRlbVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NBZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgcG9zQWRkcmVzcyA9IHBvc0FkZHJlc3Nlc1tpXTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnN0YW5jZSBmb3IgZWFjaCBQT1NcclxuICAgICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIFBPU19BQkksIHNpZ25lcik7XHJcblxyXG4gICAgICAvLyBDYWxsIHRoZSBhZGRNZW51SXRlbSBmdW5jdGlvbiBvbiBlYWNoIFBPUyBjb250cmFjdFxyXG4gICAgICBjb25zdCBjb3N0SW5XZWkgPSBldGhlcnMucGFyc2VVbml0cyhjb3N0LnRvU3RyaW5nKCksICdldGhlcicpO1xyXG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHBvc0NvbnRyYWN0LmFkZE1lbnVJdGVtKGNvc3RJbldlaSwgbmFtZSk7XHJcbiAgICAgIGF3YWl0IHR4LndhaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdNRU5VX0lURU1fQURERUQnLCBwYXlsb2FkOiB7IGNvc3QsIG5hbWUgfSB9KTtcclxuXHJcbiAgICBhd2FpdCBsb2FkQWxsTWVudUl0ZW1zKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZGlzcGF0Y2gpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgbmV3IG1lbnUgaXRlbTonLCBlcnJvcik7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gSW4gaW50ZXJhY3Rpb25zLmpzIChuZWFyIGxvYWRBbGxQT1Mgb3IgYWZ0ZXIgaXQpOlxyXG5leHBvcnQgY29uc3QgbG9hZEVtcGxveWVlUmVsZXZhbnRQT1MgPSBhc3luYyAoc2lnbmVyLCByZXN0YXVyYW50QWRkcmVzcywgZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgXHJcbiAgICBjb25zdCByZXN0YXVyYW50Q29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHJlc3RhdXJhbnRBZGRyZXNzLCBSRVNUQVVSQU5UX0FCSSwgc2lnbmVyKTtcclxuICAgIGNvbnN0IHBvc0lkcyA9IGF3YWl0IHJlc3RhdXJhbnRDb250cmFjdC5nZXRQT1NJZHMoKTtcclxuICAgIFxyXG4gICAgY29uc3QgcG9zQXJyYXkgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc0lkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwb3NJZCA9IE51bWJlcihwb3NJZHNbaV0pO1xyXG4gICAgICBjb25zdCBwb3NBZGRyZXNzID0gYXdhaXQgcmVzdGF1cmFudENvbnRyYWN0LlBPU01hcHBpbmcocG9zSWQpO1xyXG4gICAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKTtcclxuICAgICAgY29uc3QgcG9zTmFtZSA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldE5hbWUoKTtcclxuICAgICAgcG9zQXJyYXkucHVzaCh7XHJcbiAgICAgICAgaWQ6IHBvc0lkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgYWRkcmVzczogcG9zQWRkcmVzcyxcclxuICAgICAgICBuYW1lOiBwb3NOYW1lLnRvU3RyaW5nKClcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcxJylcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKHBvc0FycmF5KVxyXG5cclxuICAgIC8vIERpc3BhdGNoIGFuIGFjdGlvbiB0aGF0IHNwZWNpZmljYWxseSBzdG9yZXMgUE9TIGFkZHJlc3NlcyByZWxldmFudCB0byB0aGUgY3VycmVudCBlbXBsb3llZSdzIHJlc3RhdXJhbnRcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1JFTEVWQU5UX1BPU19MT0FERURfRk9SX0VNUExPWUVFJywgcGF5bG9hZDogcG9zQXJyYXkgfSk7XHJcbiAgICByZXR1cm4gcG9zQXJyYXk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWRFbXBsb3llZVJlbGV2YW50UE9TOicsIGVycm9yKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRpY2tldEZvclBPUyA9IGFzeW5jIChcclxuICBzaWduZXIsXHJcbiAgcG9zQWRkcmVzcyxcclxuICBwb3NBYmksXHJcbiAgdGlja2V0TmFtZSxcclxuICBzZXJ2ZXJBZGRyZXNzLFxyXG4gIGRpc3BhdGNoXHJcbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBcclxuICAgIGNvbnN0IHBvc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChwb3NBZGRyZXNzLCBwb3NBYmksIHNpZ25lcik7XHJcblxyXG4gICAgLy8gVGhlIFBPUyBjb250cmFjdCBleHRlbmRzIE1lbnVUaWNrZXRCYXNlLCB3aGljaCBoYXMgY3JlYXRlVGlja2V0KF9zZXJ2ZXIsIF9uYW1lKVxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBwb3NDb250cmFjdC5jcmVhdGVUaWNrZXQoc2VydmVyQWRkcmVzcywgdGlja2V0TmFtZSk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgLy8gQWZ0ZXIgY3JlYXRpb24sIHJlbG9hZCB0aWNrZXRzIHNvIHRoZSBVSSByZW1haW5zIHVwLXRvLWRhdGVcclxuICAgIGF3YWl0IGxvYWRBbGxUaWNrZXRzRm9yUE9TKHByb3ZpZGVyLCBwb3NBZGRyZXNzLCBwb3NBYmksIGRpc3BhdGNoKTtcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdDUkVBVEVfVElDS0VUX1NVQ0NFU1MnIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB0aWNrZXQ6JywgZXJyb3IpO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQ1JFQVRFX1RJQ0tFVF9GQUlMJywgZXJyb3IgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvYWRzIGFsbCB0aWNrZXRzIGZyb20gYSBnaXZlbiBQT1MgY29udHJhY3QuXHJcbiAqIEBwYXJhbSBwcm92aWRlciBFdGhlcnMgcHJvdmlkZXIvc2lnbmVyXHJcbiAqIEBwYXJhbSBwb3NBZGRyZXNzIFRoZSBQT1MgY29udHJhY3QgYWRkcmVzc1xyXG4gKiBAcGFyYW0gcG9zQWJpIFRoZSBBQkkgZm9yIHRoZSBQT1MgY29udHJhY3RcclxuICogQHBhcmFtIGRpc3BhdGNoIFJlZHV4IGRpc3BhdGNoIGZ1bmN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbG9hZEFsbFRpY2tldHNGb3JQT1MgPSBhc3luYyAoc2lnbmVyLCBwb3NBZGRyZXNzLCBwb3NBYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIFxyXG4gICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIFBPU19BQkksIHNpZ25lcik7XHJcbiAgICAvLyBUaGUgUE9TIGNvbnRyYWN0ICh2aWEgTWVudVRpY2tldEJhc2UpIGhhcyBhbiBhcnJheSBUaWNrZXRJZHMsIHNvIHdlIHJlYWQgdGhhdFxyXG4gICAgY29uc3QgdGlja2V0SWRzID0gYXdhaXQgcG9zQ29udHJhY3QuZ2V0VGlja2V0SWRzKCk7XHJcbiAgICBjb25zdCB0aWNrZXRzQXJyYXkgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tldElkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCB0aWNrZXRJZEJOID0gdGlja2V0SWRzW2ldOyAgLy8gQmlnSW50XHJcbiAgICAgIGNvbnN0IHRpY2tldElkID0gTnVtYmVyKHRpY2tldElkQk4pO1xyXG4gICAgICBjb25zdCB0aWNrZXRTdHJ1Y3QgPSBhd2FpdCBwb3NDb250cmFjdC5nZXRUaWNrZXQodGlja2V0SWQpOyBcclxuICAgICAgLy8gdGlja2V0U3RydWN0IGhhcyB7IG5hbWUsIG9yZGVyc1tdLCBzZXJ2ZXIsIGlkLCBwYWlkIH1cclxuXHJcbiAgICAgIHRpY2tldHNBcnJheS5wdXNoKHtcclxuICAgICAgICBpZDogdGlja2V0U3RydWN0LmlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgbmFtZTogdGlja2V0U3RydWN0Lm5hbWUsXHJcbiAgICAgICAgc2VydmVyOiB0aWNrZXRTdHJ1Y3Quc2VydmVyLFxyXG4gICAgICAgIHBhaWQ6IHRpY2tldFN0cnVjdC5wYWlkLFxyXG4gICAgICAgIHBvc0FkZHJlc3M6IHBvc0FkZHJlc3MgLy8gU28gd2Uga25vdyB3aGljaCBQT1MgdGhpcyB0aWNrZXQgYmVsb25ncyB0b1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCB0byBzdG9yZSBpbiBSZWR1eC4gXHJcbiAgICAvLyBXZSBjYW4gc3RvcmUgdGhlbSBQT1MtYnktUE9TIG9yIGluIGEgc2luZ2xlIGFycmF5LiBcclxuICAgIC8vIEJlbG93LCB3ZSBqdXN0IHB1c2ggdGhlbSBhbGwgaW50byBhIHNpbmdsZSBhcnJheSBpbiBSZWR1eDpcclxuICAgIGRpc3BhdGNoKHsgXHJcbiAgICAgIHR5cGU6ICdUSUNLRVRTX0xPQURFRCcsIFxyXG4gICAgICBwYXlsb2FkOiB7IHBvc0FkZHJlc3MsIHRpY2tldHM6IHRpY2tldHNBcnJheSB9IFxyXG4gICAgfSk7XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHRpY2tldHMgZm9yIFBPUzonLCBlcnJvcik7XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdUSUNLRVRTX0xPQURfRkFJTCcsIGVycm9yIH0pO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5leHBvcnQgY29uc3Qgc2V0QWN0aXZlVGlja2V0ID0gYXN5bmMgKGRpc3BhdGNoLCB0aWNrZXQpID0+IHtcclxuICBkaXNwYXRjaCh7IHR5cGU6ICdBQ1RJVkVfVElDS0VUX1NFVCcsIHBheWxvYWQ6IHRpY2tldCB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGVhcnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGlja2V0IGluIFJlZHV4LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGlzcGF0Y2ggUmVkdXggZGlzcGF0Y2hcclxuICovXHJcbmV4cG9ydCBjb25zdCBjbGVhckFjdGl2ZVRpY2tldCA9IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gIGRpc3BhdGNoKHsgdHlwZTogJ0FDVElWRV9USUNLRVRfQ0xFQVInIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvYWRzIGFsbCBtZW51IGl0ZW1zIGZvciBhIGdpdmVuIFBPUyBjb250cmFjdCBhZGRyZXNzIGFuZCByZXR1cm5zIHRoZW0gYXMgYW4gYXJyYXkuXHJcbiAqIE9wdGlvbmFsbHksIHlvdSBjb3VsZCBkaXNwYXRjaCBhIFJlZHV4IGFjdGlvbiB0byBzdG9yZSB0aGVtIGlmIGRlc2lyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gcHJvdmlkZXIgRXRoZXJzIHByb3ZpZGVyL3NpZ25lclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zQWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGUgUE9TXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBvc0FiaSBUaGUgQUJJIGZvciB0aGUgUE9TIGNvbnRyYWN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkaXNwYXRjaCBSZWR1eCBkaXNwYXRjaFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIG1lbnUgaXRlbXMgW3sgaWQsIG5hbWUsIGNvc3QgfSwgLi4uXVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxvYWRNZW51SXRlbXNGb3JQT1MgPSBhc3luYyAoc2lnbmVyLCBwb3NBZGRyZXNzLCBwb3NBYmksIGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIE9wdGlvbmFsOiBkaXNwYXRjaCh7IHR5cGU6ICdNRU5VX0lURU1TX0xPQURfUkVRVUVTVCcgfSk7XHJcblxyXG4gICAgXHJcbiAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKTtcclxuICAgIGNvbnN0IG1lbnVJdGVtSWRzID0gYXdhaXQgcG9zQ29udHJhY3QuZ2V0TWVudUl0ZW1JZHMoKTtcclxuICAgIFxyXG5cclxuICAgIGxldCBtZW51SXRlbXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVudUl0ZW1JZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgaWQgPSBOdW1iZXIobWVudUl0ZW1JZHNbaV0pO1xyXG4gICAgICBjb25zdCBpdGVtID0gYXdhaXQgcG9zQ29udHJhY3QubWVudShpZCk7XHJcbiAgICAgIC8vIENvbnZlcnQgY29zdCBmcm9tIHdlaSB0byBFdGhlciAob3IgeW91IGNhbiBzdG9yZSByYXcgd2VpKS5cclxuICAgICAgbWVudUl0ZW1zLnB1c2goe1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcclxuICAgICAgICBjb3N0OiBOdW1iZXIoZXRoZXJzLmZvcm1hdEV0aGVyKGl0ZW0uY29zdCkpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPcHRpb25hbDogZGlzcGF0Y2goeyB0eXBlOiAnTUVOVV9JVEVNU19GT1JfUE9TX0xPQURFRCcsIHBheWxvYWQ6IG1lbnVJdGVtcyB9KTtcclxuXHJcbiAgICByZXR1cm4gbWVudUl0ZW1zO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIG1lbnUgZm9yIFBPUzonLCBlcnJvcik7XHJcbiAgICAvLyBPcHRpb25hbDogZGlzcGF0Y2goeyB0eXBlOiAnTUVOVV9JVEVNU19MT0FEX0ZBSUwnLCBlcnJvciB9KTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGFkZFRpY2tldE9yZGVycyA9IGFzeW5jIChcclxuICBwcm92aWRlcixcclxuICBwb3NBZGRyZXNzLFxyXG4gIHBvc0FiaSxcclxuICB0aWNrZXRJZCxcclxuICBpdGVtcywgLy8gYXJyYXkgb2YgeyBjb3N0LCBuYW1lIH0gdG8gYmUgYXBwZW5kZWRcclxuICBkaXNwYXRjaFxyXG4pID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgICBjb25zdCBwb3NDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QocG9zQWRkcmVzcywgUE9TX0FCSSwgc2lnbmVyKTtcclxuICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9zQ29udHJhY3QuYWRkVGlja2V0T3JkZXJzKHRpY2tldElkLCBpdGVtcyk7XHJcbiAgICBhd2FpdCB0eC53YWl0KCk7XHJcblxyXG4gICAgLy8gT3B0aW9uYWxseSByZWxvYWQgdGhlIHVwZGF0ZWQgdGlja2V0Li4uXHJcbiAgICAvLyBhd2FpdCBsb2FkQWxsVGlja2V0c0ZvclBPUyhwcm92aWRlciwgcG9zQWRkcmVzcywgcG9zQWJpLCBkaXNwYXRjaCk7XHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQUREX1RJQ0tFVF9PUkRFUlNfU1VDQ0VTUycgfSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBvcmRlcnM6JywgZXJyb3IpO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQUREX1RJQ0tFVF9PUkRFUlNfRkFJTCcsIGVycm9yIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkRnVsbFRpY2tldERldGFpbHMgPSBhc3luYyAoXHJcbiAgcHJvdmlkZXIsXHJcbiAgcG9zQWRkcmVzcyxcclxuICBwb3NBYmksXHJcbiAgdGlja2V0SWQsXHJcbiAgZGlzcGF0Y2hcclxuKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIFBPU19BQkksIHNpZ25lcik7XHJcblxyXG4gICAgLy8gR3JhYiB0aGUgZW50aXJlIHRpY2tldCBzdHJ1Y3QgZnJvbSB0aGUgY29udHJhY3RcclxuICAgIGNvbnN0IHRpY2tldFN0cnVjdCA9IGF3YWl0IHBvc0NvbnRyYWN0LmdldFRpY2tldCh0aWNrZXRJZCk7XHJcbiAgICAvLyB0aWNrZXRTdHJ1Y3QgLT4geyBuYW1lLCBvcmRlcnNbXSwgc2VydmVyLCBpZCwgcGFpZCB9XHJcblxyXG4gICAgLy8gQ29udmVydCBvcmRlcnNbXSBmcm9tIGNvbnRyYWN0IChjb3N0IGluIHdlaSkgdG8gYSBmcmllbmRsaWVyIEpTIGFycmF5XHJcbiAgICBjb25zdCBvcmRlcnMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja2V0U3RydWN0Lm9yZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBvcmRlckl0ZW0gPSB0aWNrZXRTdHJ1Y3Qub3JkZXJzW2ldO1xyXG4gICAgICBvcmRlcnMucHVzaCh7XHJcbiAgICAgICAgbmFtZTogb3JkZXJJdGVtLm5hbWUsXHJcbiAgICAgICAgY29zdDogTnVtYmVyKGV0aGVycy5mb3JtYXRFdGhlcihvcmRlckl0ZW0uY29zdCkpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmdWxsVGlja2V0ID0ge1xyXG4gICAgICBpZDogTnVtYmVyKHRpY2tldFN0cnVjdC5pZCkudG9TdHJpbmcoKSxcclxuICAgICAgbmFtZTogdGlja2V0U3RydWN0Lm5hbWUsXHJcbiAgICAgIHNlcnZlcjogdGlja2V0U3RydWN0LnNlcnZlcixcclxuICAgICAgcGFpZDogdGlja2V0U3RydWN0LnBhaWQsXHJcbiAgICAgIHBvc0FkZHJlc3MsXHJcbiAgICAgIG9yZGVyc1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBEaXNwYXRjaCBzbyBSZWR1eCBrbm93cyBhYm91dCB0aGUgZnVsbHkgZGV0YWlsZWQgdGlja2V0XHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdBQ1RJVkVfVElDS0VUX0RFVEFJTFNfTE9BREVEJywgcGF5bG9hZDogZnVsbFRpY2tldCB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBmdWxsIHRpY2tldCBkZXRhaWxzOicsIGVycm9yKTtcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FDVElWRV9USUNLRVRfREVUQUlMU19GQUlMJywgZXJyb3IgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGJ1ZmZlckl0ZW1Gb3JUaWNrZXQgPSAodGlja2V0SWQsIGl0ZW0pID0+IHtcclxuICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdBRERfSVRFTV9UT19QRU5ESU5HX0JVRkZFUicsXHJcbiAgICAgIHBheWxvYWQ6IHsgdGlja2V0SWQsIGl0ZW0gfVxyXG4gICAgfSk7XHJcbiAgfTtcclxufTtcclxuXHJcbi8vIDIpIEEgZnVuY3Rpb24gdGhhdCAqcmluZ3MqIGFsbCBidWZmZXJlZCBpdGVtcyBmb3IgYSBnaXZlbiB0aWNrZXRJZFxyXG4vLyAgICBieSBjYWxsaW5nIGBhZGRUaWNrZXRPcmRlcnNgIGluIHRoZSBQT1MgY29udHJhY3QuXHJcblxyXG5leHBvcnQgY29uc3QgcmluZ0J1ZmZlcmVkSXRlbXMgPSBhc3luYyAoXHJcbiAgcHJvdmlkZXIsXHJcbiAgcG9zQWRkcmVzcyxcclxuICBwZW5kaW5nT3JkZXJCdWZmZXIsXHJcbiAgcG9zQWJpLFxyXG4gIHRpY2tldElkLCAgICAgICAvLyBjb3VsZCBiZSBhIG51bWJlciBvciBzdHJpbmdcclxuICBkaXNwYXRjaCxcclxuICBnZXRTdGF0ZVxyXG4pID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc3RyaW5nSWQgPSB0aWNrZXRJZC50b1N0cmluZygpXHJcblxyXG4gICAgLy8gR2V0IHRoZSBlbnRpcmUgcGVuZGluZyBidWZmZXJcclxuICAgXHJcbiAgICBjb25zdCBpdGVtc1RvUmluZyA9IHBlbmRpbmdPcmRlckJ1ZmZlcltzdHJpbmdJZF0gfHwgW11cclxuXHJcbiAgICBpZiAoaXRlbXNUb1JpbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdObyBpdGVtcyB0byByaW5nIGZvciB0aGlzIHRpY2tldC4nKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3JtYXQgdGhlbSBmb3IgdGhlIGNvbnRyYWN0XHJcbiAgICBjb25zdCBydW5nSXRlbXMgPSBpdGVtc1RvUmluZy5tYXAoKGl0ZW0pID0+ICh7XHJcbiAgICAgIGNvc3Q6IGV0aGVycy5wYXJzZVVuaXRzKGl0ZW0uY29zdC50b1N0cmluZygpLCAnZXRoZXInKSxcclxuICAgICAgbmFtZTogaXRlbS5uYW1lXHJcbiAgICB9KSlcclxuXHJcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKVxyXG4gICAgY29uc3QgcG9zQ29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHBvc0FkZHJlc3MsIHBvc0FiaSwgc2lnbmVyKVxyXG5cclxuICAgIC8vIFNlbmQgdHJhbnNhY3Rpb25cclxuICAgIGNvbnNvbGUubG9nKCdmdW4nKVxyXG4gICAgY29uc3QgdHggPSBhd2FpdCBwb3NDb250cmFjdC5hZGRUaWNrZXRPcmRlcnModGlja2V0SWQsIHJ1bmdJdGVtcylcclxuICAgIGF3YWl0IHR4LndhaXQoKVxyXG4gICAgY29uc29sZS5sb2coJ2Z1bicpXHJcblxyXG4gICAgLy8gTm93IHRlbGwgUmVkdXggd2Ugc3VjY2VlZGVkXHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdPUkRFUl9SSU5HX1NVQ0NFU1MnLFxyXG4gICAgICBwYXlsb2FkOiB7IFxyXG4gICAgICAgIHRpY2tldElkOiB0aWNrZXRJZCwgIC8vIHBhc3MgYSBzdHJpbmdcclxuICAgICAgICBydW5nSXRlbXM6IGl0ZW1zVG9SaW5nXHJcbiAgICAgIH1cclxuXHJcbiAgICB9KVxyXG4gICAgICBcclxuICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmFuZyBpdGVtcyBmb3IgdGlja2V0OiAke3N0cmluZ0lkfWApXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJpbmdCdWZmZXJlZEl0ZW1zOicsIGVycm9yKVxyXG4gIH1cclxufVxyXG5leHBvcnQgY29uc3QgY2xvY2tJbkVtcGxveWVlID0gYXN5bmMgKHByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgZW1wbG95ZWVJZCkgPT4ge1xyXG4gIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xyXG4gIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgc2lnbmVyKTtcclxuICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmNsb2NrSW4oZW1wbG95ZWVJZCk7XHJcbiAgYXdhaXQgdHgud2FpdCgpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNsb2NrT3V0RW1wbG95ZWUgPSBhc3luYyAocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcywgYWJpLCBlbXBsb3llZUlkKSA9PiB7XHJcbiAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XHJcbiAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCBzaWduZXIpO1xyXG4gIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuY2xvY2tPdXQoZW1wbG95ZWVJZCk7XHJcbiAgYXdhaXQgdHgud2FpdCgpO1xyXG59O1xyXG5cclxuXHJcbi8vIEluIHN0b3JlL2ludGVyYWN0aW9ucy5qc1xyXG5cclxuLy8gc3RvcmUvaW50ZXJhY3Rpb25zLmpzXHJcbmV4cG9ydCBjb25zdCBmZXRjaEVtcGxveWVlU3RhdHVzRnJvbVNlcnZlciA9XHJcbiAgKHsgc2lnbmVyLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgam9iTmFtZSB9KSA9PlxyXG4gIGFzeW5jIChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIDEpIFRoZSBwdWJsaWMgYWRkcmVzcyBvZiB0aGUgdXNlclxyXG4gICAgICBjb25zdCB1c2VyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XHJcblxyXG4gICAgICAvLyAyKSBCdWlsZCB0aGUgcGF5bG9hZFxyXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICB1c2VyQWRkcmVzcyxcclxuICAgICAgICBhYmksXHJcbiAgICAgICAgam9iTmFtZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gMykgUE9TVCB0byB5b3VyIGN1c3RvbSByb3V0ZVxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2VtcGxveWVlU3RhdHVzJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgLy8gNCkgRGlzcGF0Y2ggaWYgeW91IHdhbnQgdG8gc3RvcmUgaW4gUmVkdXhcclxuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnRU1QTE9ZRUVfU1RBVFVTX0ZST01fU0VSVkVSJywgcGF5bG9hZDogZGF0YSB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGZldGNoRW1wbG95ZWVTdGF0dXNGcm9tU2VydmVyOicsIGVycm9yKTtcclxuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnRU1QTE9ZRUVfU1RBVFVTX0ZST01fU0VSVkVSX0VSUk9SJywgZXJyb3IgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuIl0sIm5hbWVzIjpbImV0aGVycyIsIlJFU1RBVVJBTlRfQUJJIiwiREVDRU5UUkFUQUxJVFlTRVJWSUNFRkFDVE9SWV9BQkkiLCJQT1NfQUJJIiwidXNlU2VsZWN0b3IiLCJHbG9iYWxSZXN0YXVyYW50cyIsImxvYWRQcm92aWRlciIsImRpc3BhdGNoIiwiY29ubmVjdGlvbiIsIkJyb3dzZXJQcm92aWRlciIsIndpbmRvdyIsImV0aGVyZXVtIiwidHlwZSIsImxvYWRBY2NvdW50IiwicHJvdmlkZXIiLCJhY2NvdW50cyIsInNlbmQiLCJhY2NvdW50IiwiZ2V0QWRkcmVzcyIsImxvYWROZXR3b3JrIiwiY2hhaW5JZCIsImdldE5ldHdvcmsiLCJOdW1iZXIiLCJzdWJzY3JpYmVUb0V2ZW50cyIsInJlc3RhdXJhbnRGYWN0b3J5IiwiUmVzdGF1cmFudHMiLCJvbiIsInJlc3RhdXJhbnQiLCJpZCIsIm93bmVyIiwiZXZlbnQiLCJfcmVzdGF1cmFudCIsImFyZ3MiLCJ0aW1lc3RhbXAiLCJqb2IiLCJsb2FkRmFjdG9yeSIsInVzZXIiLCJhZGRyZXNzMSIsImFkZHJlc3MiLCJkZWNlbnRyYXRhbGl0eVNlcnZpY2VGYWN0b3J5IiwiQ29udHJhY3QiLCJhYmkiLCJnZXRTaWduZXIiLCJsb2FkQWxsUmVzdGF1cmFudHMiLCJmYWN0b3J5IiwicmVzdGF1cmFudEFkZHJlc3NlcyIsImdldEFsbFJlc3RhdXJhbnRzIiwiaSIsImxlbmd0aCIsInJlc3RhdXJhbnRBZGRyZXNzIiwicmVzdGF1cmFudENvbnRyYWN0IiwibmFtZSIsImJhbGFuY2UiLCJnZXRCYWxhbmNlIiwicHVzaCIsImZvcm1hdEV0aGVyIiwiY29uc29sZSIsImxvZyIsImxvYWRNeVJlc3RhdXJhbnRzIiwibXlSZXN0YXVyYW50cyIsImZpbHRlciIsImRlY29yYXRlTXlSZXN0YXVyYW50cyIsImRlY29yYXRlZFJlc3RhdXJhbnRzIiwiY29udHJhY3QiLCJteU5hbWUiLCJ0b1N0cmluZyIsImNhc2giLCJlcnJvciIsImNyZWF0ZU5ld1Jlc3RhdXJhbnQiLCJyZXN0YXVyYW50TmFtZSIsInRvdGFsQ29zdFdlaSIsInRvdGFsQ29zdCIsIkJpZ0ludCIsIk1hdGgiLCJmbG9vciIsImFsZXJ0IiwidHgiLCJjcmVhdGVSZXN0YXVyYW50IiwidmFsdWUiLCJ3YWl0IiwibG9hZERhc2hib2FyZFJlc3RhdXJhbnRDb250cmFjdERhdGEiLCJSZXN0YXVyYW50IiwiY29udHJhY3RBZGRyZXNzIiwibXlDYXNoIiwiY3JlYXRlTmV3Sm9iIiwid2FnZSIsImFkZEpvYiIsImxvYWRBbGxKb2JzIiwiaGlyZU5ld0VtcGxveWVlIiwiam9iSWQiLCJlbXBsb3llZUFkZHJlc3MiLCJoaXJlRW1wbG95ZWUiLCJsb2FkQWxsRW1wbG95ZWVzIiwiZW1wbG95ZWVJZHMiLCJnZXRFbXBsb3llZUlkcyIsImVtcGxveWVlc0FycmF5IiwiZW1wbG95ZWVJZCIsImVtcGxveWVlIiwiZW1wbG95ZWVzIiwiY2xvY2tTdGFtcCIsImVtcGxveWVlUGVuc2lvbiIsImpvYklkcyIsImdldEpvYklkcyIsImpvYnNBcnJheSIsImpvYnMiLCJob3VybHlXYWdlSW5XZWkiLCJqb2JOYW1lIiwibWVzc2FnZSIsInN0YXJ0U2VydmljZSIsInJlY2VpcHQiLCJibG9jayIsImdldEJsb2NrIiwiYmxvY2tOdW1iZXIiLCJzZXJ2aWNlU3RhcnRUaW1lIiwibG9hZEFsbFNlcnZpY2VzIiwic2VydmljZUlkcyIsImdldFNlcnZpY2VJZHMiLCJzZXJ2aWNlc0FycmF5Iiwic2VydmljZUlkIiwic2VydmljZSIsInNlcnZpY2VzIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImNvc3QiLCJwcm9maXQiLCJyZXZlbnVlIiwiZW5kU2VydmljZSIsImNyZWF0ZVBPUyIsInNpZ25lciIsImxvZ3MiLCJtYXAiLCJpbnRlcmZhY2UiLCJwYXJzZUxvZyIsImZpbmQiLCJwYXJzZWRMb2ciLCJwb3NJZCIsInBvc0FkZHJlc3MiLCJwb3MiLCJsb2FkQWxsUE9TIiwicG9zSWRzIiwiZ2V0UE9TSWRzIiwicG9zQXJyYXkiLCJQT1NNYXBwaW5nIiwicG9zQ29udHJhY3QiLCJwb3NOYW1lIiwiZ2V0TmFtZSIsImxvYWRBbGxNZW51SXRlbXMiLCJjIiwicG9zQWRkcmVzc2VzIiwiZ2V0QWxsUE9TQWRkcmVzc2VzIiwicGF5bG9hZCIsImZpcnN0UE9TQWRkcmVzcyIsIm1lbnVJdGVtSWRzIiwiZ2V0TWVudUl0ZW1JZHMiLCJtZW51SXRlbXMiLCJtZW51SXRlbSIsIm1lbnUiLCJhZGROZXdNZW51SXRlbSIsImNvc3RJbldlaSIsInBhcnNlVW5pdHMiLCJhZGRNZW51SXRlbSIsImxvYWRFbXBsb3llZVJlbGV2YW50UE9TIiwiY3JlYXRlVGlja2V0Rm9yUE9TIiwicG9zQWJpIiwidGlja2V0TmFtZSIsInNlcnZlckFkZHJlc3MiLCJjcmVhdGVUaWNrZXQiLCJsb2FkQWxsVGlja2V0c0ZvclBPUyIsInRpY2tldElkcyIsImdldFRpY2tldElkcyIsInRpY2tldHNBcnJheSIsInRpY2tldElkQk4iLCJ0aWNrZXRJZCIsInRpY2tldFN0cnVjdCIsImdldFRpY2tldCIsInNlcnZlciIsInBhaWQiLCJ0aWNrZXRzIiwic2V0QWN0aXZlVGlja2V0IiwidGlja2V0IiwiY2xlYXJBY3RpdmVUaWNrZXQiLCJsb2FkTWVudUl0ZW1zRm9yUE9TIiwiaXRlbSIsImFkZFRpY2tldE9yZGVycyIsIml0ZW1zIiwibG9hZEZ1bGxUaWNrZXREZXRhaWxzIiwib3JkZXJzIiwib3JkZXJJdGVtIiwiZnVsbFRpY2tldCIsImJ1ZmZlckl0ZW1Gb3JUaWNrZXQiLCJyaW5nQnVmZmVyZWRJdGVtcyIsInBlbmRpbmdPcmRlckJ1ZmZlciIsImdldFN0YXRlIiwic3RyaW5nSWQiLCJpdGVtc1RvUmluZyIsInJ1bmdJdGVtcyIsImNsb2NrSW5FbXBsb3llZSIsImNsb2NrSW4iLCJjbG9ja091dEVtcGxveWVlIiwiY2xvY2tPdXQiLCJmZXRjaEVtcGxveWVlU3RhdHVzRnJvbVNlcnZlciIsInVzZXJBZGRyZXNzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/store/interactions.js\n"));

/***/ })

});